{"pages":[],"posts":[{"title":"ES6 Let 和 Const","text":"在JS中用var声明变量存在变量提升，比如： if (false) { var a = 1;}console.log(a);//undefined 这段代码输出的是undefined，而不是ReferenceError。这是因为var有变量提升，实际这段代码相当于： var a;if (false) { a = 1;}console.log(a);//undefined 还有在for循环中： var result = [];for (var i = 0; i &lt; 5; i++) { result.push(function () { console.log(i) });}console.log(result[0]());//5console.log(result[1]());//5console.log(result[2]());//5console.log(result[3]());//5console.log(result[4]());//5console.log(i);//5 数组里输出的值都是5，并且for循环结束了，还是可以访问i的值。在ES6之前，是没有块级作用域，在ES6中引入了块级作用域，块级作用域是指： 函数内部 块中(字符 { 和 } 之间的区域) let 和 constlet和const是用来声明块级作用域变量，它们有以下特性： 1. 不会被提升if (false) { let a = 1;}console.log(a);//Uncaught ReferenceError: a is not defined 2. 重复声明会报错var a = 1;let a = 2; //Uncaught SyntaxError: Identifier 'a' has already been declared 3. 不绑定全局作用域在全局作用就里使用var声明变量，这个变量会作为全局对象的属性。 var a = 1;console.log(window.a);//1 但是用let和const不会： let a = 1;const b = 2;console.log(window.a);//undefinedconsole.log(window.b);//undefined let和const的区别const用来声明常量，一旦初始化，就不能再被修改，否则会报错。但是对于const声明的对象，对象的引用不能被修改，但是对象里的属性值是可以被修改的： const data = { a: 1}data.a = 2;//可以被修改data.b = 3;//会加一个属性bdata = {};//报错：Uncaught TypeError: Assignment to constant variable 暂时性死区(Temporal Dead Zone)let和const什么的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会报错： console.log(a);//Uncaught ReferenceError: Cannot access 'a' before initializationlet a = 1; 在JS引擎扫描代码发现变量声明时，遇到var声明就提升到作用域顶部，遇到let和const就把这些声明放在暂时性死区。对于let和const变量，如果在执行它们的声明语句之前访问会报错，只有执行完声明语句之后才会从暂时性死区移出。 循环中的块级作用域之前有代码： var result = [];for (var i = 0; i &lt; 5; i++) { result.push(function () { console.log(i) });}console.log(result[0]());//5console.log(result[1]());//5console.log(result[2]());//5console.log(result[3]());//5console.log(result[4]());//5 我们实际想要的输出0 1 2 3 4，解决方案有： var result = []for (var i = 0; i &lt; 5; i++) { result.push((function (i) { console.log(i) })(i));}console.log(result[0]());//0console.log(result[1]());//1console.log(result[2]());//2console.log(result[3]());//3console.log(result[4]());//4 还可以用ES6中的let： var result = []for (let i = 0; i &lt; 5; i++) { result.push(function () { console.log(i) });}console.log(result[0]());//0console.log(result[1]());//1console.log(result[2]());//2console.log(result[3]());//3console.log(result[4]());//4 之前说过，let不提升，不能重复定义，在第二次循环的时候，又用let声明了i，为什么在这里不报错，可以正确输出值呢？比如： for (let i = 0; i &lt; 3; i++) { let i = 'abc'; console.log(i);} 这里会输出三个abc，但是用var： for (var i = 0; i &lt; 3; i++) { var i = 'abc'; console.log(i);} 只会输出一个abc。 JS引擎对var和let使用了不同的方式处理，对于let每次循环都会创建一个新变量，对于代码： var result = []for (let i = 0; i &lt; 5; i++) { result.push(function () { console.log(i) });} 实际相当于： (let i = 0) { result[0]= function () { console.log(0) };}(let i = 1) { result[1]= function () { console.log(1) };}(let i = 2) { result[2]= function () { console.log(2) };}............(let i = 4) { result[4]= function () { console.log(4) };} 但是在上面代码里不能用const，虽然我们每次创建了一个新的变量，但是我们尝试修改const的值，所以会报错。 总结在开发过程中，默认推荐使用const，只有当确定变量的值会发生改变使用let。","link":"/2019/10/21/ES6-Let-%E5%92%8CConst/"},{"title":"JS：深入理解JavaScript-this","text":"在上一篇文章【JS：深入理解JavaScript-执行上下文】中介绍了执行上下文是如何工作的。在这篇文章里会介绍执行上下文中的ThisBinding，也就是JavaScript中的this。 有四种可执行代码可以创建执行上下文，分别是global code function code module和eval code。接下来分别介绍这global code function code可执行代码中的this（ThisBinding）到底指的是什么。 global code的this在JS引擎运行global code之前，会创建一个全局执行上下文压入执行栈的栈底，这个全局执行上文的ThisBinding绑定的是全局对象，在浏览器里指的就是window。 function code的this在文章【JS：深入理解JavaScript-词法环境】提到过JavaScript是静态作用域，词法环境是由代码结构决定的，开发把代码写成什么样，词法环境就是怎么样，跟方法在哪里调用没有关系。但是对于函数的this刚好反过来，跟代码在哪里定义没有关系，而跟代码在哪里调用有关系。一般我们调用函数有以下四种方式： 普通函数调用，比如foo()或者(functon(){})() 作为对象方法调用，比如obj.foo() 构造函数调用，比如new foo() 使用call、apply、bind等方法调用 在介绍着几种函数调用之前，我们先来看下ECMAScript对this的规范： ECMAScript规范： 严格模式时，函数内的this绑定严格指向传入的thisArgument。非严格模式时，若传入的thisArgument不为undefined或null时，函数内的this绑定指向传入的thisArgument；为undefined或null时，函数内的this绑定指向全局的this。 普通函数调用普通函数的调用，包括函数调用foo()和立即调用函数表达式(functon(){})()，传到函数里的thisArgument是undefined。根据ECMAScript规范，如果在非严格模式下，普通函数里的this就是全局对象，而在严格模式下就为undefined。 比如有以下代码： var a = 2;function foo() { console.log(this.a)}foo(); //2 如果把foo方法改为严格模式： var a = 2;function foo() { \"use strict\" console.log(this.a)}foo(); 执行上面这段代码，会报错： VM162:4 Uncaught TypeError: Cannot read property &apos;a&apos; of undefined at foo (&lt;anonymous&gt;:4:22) 对象方法调用作为对象方法调用，传到函数里的thisArgument是该对象。比如有如下代码： function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};obj.foo(); //2 需要注意的是，只有离函数最近的这个对象，才是该函数的this，比如有代码： function foo() { console.log( this.a );}var obj2 = { a: 42, foo: foo};var obj1 = { a: 2, obj2: obj2};obj1.obj2.foo(); //42 还有一种比较看起来像对象方法调用，实际上是普通函数调用： function foo() { console.log(this.a);}var obj = { a: 2, foo: foo}var bar = obj.foo; var a = \"global variable\";bar(); // global variable 构造函数调用new functionname()构造函数调用，this指的是构造出来的新对象。 function foo(a) { this.a = a;}var bar = new foo( 2 );console.log( bar.a ); // 2 使用call、apply、bind等方法调用call、apply、bind调用，可以显示传递对象给函数的thisArg，默认这几个函数的第一个形参是thisArg: Function.prototype.apply( thisArg, argArray )Function.prototype.call( thisArg , arg1, [ arg2, ... ] )Function.prototype.bind( thisArg , [ arg1, [ arg2, ... ] ] ) 需要注意的是当thisArg为null或者undefined，在非严格模式下，this是全局对象。 var obj = { a: 1};function print() { console.log(this);}print.call(null);//windowprint.call(undefined);//windowprint.call(obj);//obj 箭头函数的this箭头函数在调用的时候不会绑定this，它会去词法环境链上寻找this，所以箭头函数的this取决于它定义的位置。 window.a = 10const foo = () =&gt; { console.log(this.a)}foo.call({a: 20}) // 10let obj = { a: 20, foo: foo}obj.foo() //10function bar() { foo()}bar.call({a: 20}) //10 回调函数的thiswindow.a = 10let obj = { a: 20, foo: function () { console.log(this.a) }}setTimeout(obj.foo, 0) //10 上面代码运行结果是10，作为回调函数的时候，传递的是函数体，并不是函数名。在执行栈里，obj.foo已经执行完成被弹出执行栈，此时执行栈里只有全局执行上下文，setTimeout回调函数体执行的时候this为全局对象。 要想避免这种情况，有两种方法，第一种方法是使用bind返回的指定好this绑定的函数作为回调函数传入： 使用bind指定this setTimeout(obj.foo.bind({a: 20}), 0) // 20 使用箭头函数 window.a = 10function foo() { return () =&gt; { console.log(this.a) }}const arrowFn = foo.call({a: 20})arrowFn() // 20setTimeout(arrowFn, 0) //20 总结 箭头函数中没有this绑定，this的值取决于其创建时所在词法环境链中最近的this绑定 非严格模式下，函数普通调用，this指向全局对象 严格模式下，函数普通调用，this为undefined 函数作为对象方法调用，this指向该对象 函数作为构造函数配合new调用，this指向构造出的新对象 非严格模式下，函数通过call、apply、bind等间接调用，this指向传入的第一个参数, 传入的第一个参数若为undefined或null，this指向全局对象 格模式下函数通过call、apply、bind等间接调用，this严格指向传入的第一个参数","link":"/2019/10/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript-this/"},{"title":"git 常见命令","text":"git init # 初始化本地git仓库（创建新仓库）git config –global user.name “xxx” # 配置用户名git config –global user.email “xxx@xxx.com“ # 配置邮件git config –global color.ui true # git status等命令自动着色git config –global color.status autogit config –global color.diff autogit config –global color.branch autogit config –global color.interactive autogit clone git+ssh://git@000.000.00.000/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m ‘xxx’ # 提交git commit –amend -m ‘xxx’ # 合并上一次提交（用于反复修改）git commit -am ‘xxx’ # 将add和commit合为一步git rm xxx # 删除index中的文件git rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log –stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m ‘xxx’ # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff –cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD – ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master –stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch –contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch –merged # 显示所有已合并到当前分支的分支git branch –no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout . # 取消对所有文件的修改git checkout – # 取消对文件的修改。还原到最近的版本，废弃本地做的修改。git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout –track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout – README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push –tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch –prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset –hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch –all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@{5}git show master@{yesterday} # 显示master分支昨天的状态git log –pretty=format:’%h %s’ –graph # 图示提交日志git show HEAD~3git show -s –pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@{0} # 参考第一次暂存git stash apply stash@{0} # 应用第一次暂存git grep “delete from” # 文件中搜索文本“delete from”git grep -e ‘#define’ –and -e SORT_DIRENTgit gcgit fsck输入“git remote -v”查看项目远程地址","link":"/2019/09/21/git-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[]}