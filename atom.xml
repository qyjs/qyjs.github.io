<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QYJS</title>
  
  <subtitle>FlyingFishSauce</subtitle>
  <link href="https://qyjs.github.io/atom.xml" rel="self"/>
  
  <link href="https://qyjs.github.io/"/>
  <updated>2023-10-17T02:14:11.350Z</updated>
  <id>https://qyjs.github.io/</id>
  
  <author>
    <name>qyjs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ng-template, ng-container 和 ngTemplateOutlet 的完整使用指南</title>
    <link href="https://qyjs.github.io/2023/10/17/ng-template,%20ng-container%20%E5%92%8C%20ngTemplateOutlet%20%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://qyjs.github.io/2023/10/17/ng-template,%20ng-container%20%E5%92%8C%20ngTemplateOutlet%20%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2023-10-17T07:30:18.000Z</published>
    <updated>2023-10-17T02:14:11.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ng-template-ng-container-和-ngTemplateOutlet"><a href="#ng-template-ng-container-和-ngTemplateOutlet" class="headerlink" title="ng-template, ng-container 和 ngTemplateOutlet"></a>ng-template, ng-container 和 ngTemplateOutlet</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="title class_">Directive</span>(&#123;<span class="attr">selector</span>: <span class="string">&#x27;[ngIf]&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NgIf</span> &#123;</span><br><span class="line">  private <span class="attr">_hasView</span>: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TemplateRef 是 `&lt;ng-template&gt;` 的实例引用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">private _viewContainer: ViewContainerRef, private _template: TemplateRef&lt;<span class="built_in">Object</span>&gt;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Input</span>()</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">ngIf</span>(<span class="params">condition: any</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition &amp;&amp; !<span class="variable language_">this</span>.<span class="property">_hasView</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_hasView</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_viewContainer</span>.<span class="title function_">createEmbeddedView</span>(<span class="variable language_">this</span>.<span class="property">_template</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!condition &amp;&amp; <span class="variable language_">this</span>.<span class="property">_hasView</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_hasView</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_viewContainer</span>.<span class="title function_">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ng-template 指令和相关的 ngTemplateOutlet 指令，它们是非常强大的 <span class="title class_">Angular</span> 特性，能支持 【各种各样】 的高级用例。这些指令经常与 ng-container 一起使用，学习它们是非常有帮助的，我们将会围绕每个指令讲更详细的内容。</span><br><span class="line"></span><br><span class="line">现在让我们来看看这些指令的高级用法。注意：原文所有的代码都在这个仓库里<span class="attr">https</span>:<span class="comment">//github.com/angular-university/ng-template-example</span></span><br><span class="line"></span><br><span class="line">本文要点</span><br><span class="line">ng-template 指令介绍</span><br><span class="line">模板输入变量</span><br><span class="line">ng-template 与 ngIf 联合使用</span><br><span class="line">ng-template 与 ngIf 的无糖化语法</span><br><span class="line">ng-template 模板引用与可注入的 <span class="title class_">TemplateRef</span></span><br><span class="line">通过模板类型的 @<span class="title class_">Input</span>() 实现可配置化组件</span><br><span class="line">什么时候使用 ng-container ?</span><br><span class="line">使用 ngTemplateOutlet 自定义指令创建动态模板</span><br><span class="line"><span class="title class_">Template</span> outlet @<span class="title class_">Input</span> <span class="title class_">Properties</span></span><br><span class="line">完整的联合使用的例子</span><br><span class="line">总结和结论</span><br><span class="line">ng-template 指令介绍</span><br><span class="line">从字面理解，ng-template 指令代表一个 <span class="title class_">Angular</span> 模板，在这个标签里的内容是组件模板的一部分，然后和其他的模板一起组合成组件最终的模板。在 ng 底层，已经用 ng-template 实现了很多我们会经常使用的结构性指令，包括： ngIf，ngFor 和 ngSwitch。</span><br><span class="line"></span><br><span class="line">现在通过一个例子开始我们的学习。在一个 tab 组件中定义两个 tab 按钮（后面会有更多的例子）。在线例子</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&quot;app-root&quot;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ng-template&gt;</span></span><br><span class="line"><span class="string">      &lt;button class=&quot;tab-button&quot; (click)=&quot;login()&quot;&gt;&#123;&#123; loginText &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button class=&quot;tab-button&quot; (click)=&quot;signUp()&quot;&gt;&#123;&#123; signUpText &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  loginText = <span class="string">&quot;Login&quot;</span>;</span><br><span class="line">  signUpText = <span class="string">&quot;Sign Up&quot;</span>;</span><br><span class="line">  lessons = [<span class="string">&quot;Lesson 1&quot;</span>, <span class="string">&quot;Lessons 2&quot;</span>];</span><br><span class="line">  <span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Login&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">signUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Sign Up&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">关于 ng-template，你首先会注意到的是</span><br><span class="line">如果你运行上面的例子，你会发现，屏幕上根本没有渲染任何东西。这是正常的，也是预期的行为。这是因为 ng-template 标签只是简单地定义了一个模板，但我们还没有使用它。接着我们会展示一个例子，用一些常用的 <span class="title class_">Angular</span> 指令就能让模板渲染出来。</span><br><span class="line"></span><br><span class="line">ng-template 指令和 ngIf</span><br><span class="line">你可能是在第一次使用 ngIf/<span class="keyword">else</span> 实现一些功能时用到了 ng-template，就像下面这个例子一样：</span><br><span class="line"></span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;lessons-list&quot;</span> *ngIf=<span class="string">&quot;lessons else loading&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">loading</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span></span><br><span class="line">这是一个非常常见的 ngIf/<span class="keyword">else</span> 用例：我们在等待后端数据返回时，用一个“加载中”来代替数据的展示。如我们所见，这个 <span class="keyword">else</span> 指向了一个叫 loading 的模板。通过使用 #loading 这样的语法，把模板引用赋值给了 loading。</span><br><span class="line"></span><br><span class="line">但除了我们写的这个 ng-template，使用 ngIf 也会创建第二个模板，不过它是隐式的。让我们看看到底发生了什么：</span><br><span class="line"></span><br><span class="line">&lt;ng-template [ngIf]=<span class="string">&quot;lessons&quot;</span> [ngIfElse]=<span class="string">&quot;loading&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lessons-list&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/ng-template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">loading</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span></span><br><span class="line">译注：原文中的 desugars，在 wiki 上的解释是，<span class="title class_">To</span> translate the source code <span class="keyword">of</span> a computer program into a functionally equivalent form devoid <span class="keyword">of</span> syntactic sugar. 直译为，将计算机程序的源代码转换成功能相当的无语法糖的形式。</span><br><span class="line"><span class="title class_">Angular</span> 在内部通过这种无语法糖的操作（译注：简称无糖化），但是编码更为简洁明了，实现了 *ngIf 整个结构指令语法。现在来看看在无糖化过程中发现了什么。</span><br><span class="line"></span><br><span class="line">结构指令 ngIf 所在的元素被移到了 ng-template 中</span><br><span class="line">*ngIf 所对应的表达式被拆分到了两个独立的指令中，前者用于 [ngIf]，后者用于可接收模板的 [ngIfElse] 中。</span><br><span class="line">译注： 这是 <span class="title class_">Angular</span> <span class="number">12.0</span><span class="number">.0</span> 的源码</span><br><span class="line"><span class="comment">// https://github.com/angular/angular/blob/b31e90575459f27b29ad77626e2e23cad3e50435/packages/common/src/directives/ng_if.ts#L194</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The Boolean expression to evaluate as the condition for showing a template.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">@<span class="title class_">Input</span>()</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">ngIf</span>(<span class="params">condition: T</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_context</span>.<span class="property">$implicit</span> = <span class="variable language_">this</span>.<span class="property">_context</span>.<span class="property">ngIf</span> = condition;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_updateView</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A template to show if the condition expression evaluates to false.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Input</span>()</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">ngIfElse</span>(<span class="params">templateRef: TemplateRef&lt;NgIfContext&lt;T&gt;&gt;|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="title function_">assertTemplate</span>(<span class="string">&#x27;ngIfElse&#x27;</span>, templateRef);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_elseTemplateRef</span> = templateRef;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_elseViewRef</span> = <span class="literal">null</span>;  <span class="comment">// clear previous view if any.</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_updateView</span>();</span><br><span class="line">&#125;</span><br><span class="line">这只是 ngIf 的一个特例。但 ngFor 和 ngSwitch 也会发生类似的过程。这些指令都非常常用，所以这意味着这些模板在 <span class="title class_">Angular</span> 中随处可见，或隐式或显式。</span><br><span class="line"></span><br><span class="line">但基于这个例子，有个问题可能会出现在脑海中: 如果有多个结构指令应用于同一个元素，这又如何工作?</span><br><span class="line"></span><br><span class="line">多个结构指令</span><br><span class="line">当我们在一个元素上使用 ngIf 和 ngFor 时：</span><br><span class="line"></span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;lesson&quot;</span> *ngIf=<span class="string">&quot;lessons&quot;</span> *ngFor=<span class="string">&quot;let lesson of lessons&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lesson-detail&quot;</span>&gt;</span>&#123;&#123;lesson | json&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">这样并不能正常运行。只会得到以下错误：</span><br><span class="line"></span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">Error</span>: <span class="title class_">Template</span> parse <span class="attr">errors</span>:</span><br><span class="line"><span class="title class_">Can</span><span class="string">&#x27;t have multiple template bindings on one element. Use only one attribute</span></span><br><span class="line"><span class="string">named &#x27;</span>template<span class="string">&#x27; or prefixed with *</span></span><br><span class="line"><span class="string">报错的意思就是，不能在一个元素上同时使用两个结构性指令。如果有这样的需求，可以采用下面的方法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;div *ngIf=&quot;lessons&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;lesson&quot; *ngFor=&quot;let lesson of lessons&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;lesson-detail&quot;&gt;&#123;&#123;lesson | json&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">在这个例子中，把 ngIf 指令放到了外层的 div 上，但是为了保证代码的正常工作却创建了一个多余的 div。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这样虽然能工作，但能不能既能让代码的正常工作，又不创建多余的元素呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">答案就是，我们可以使用 ng-containter 结构指令来解决这个问题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ng-container 指令</span></span><br><span class="line"><span class="string">为了避免创建多余的 div，我们能用 ng-container 来代替 div。就像这样：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;ng-container *ngIf=&quot;lessons&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;lesson&quot; *ngFor=&quot;let lesson of lessons&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;lesson-detail&quot;&gt;&#123;&#123;lesson | json&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">正如我们所看到的，ng-container 指令为我们提供了一个元素，通过它我们可以将结构指令附加到页面的某个区域，而无需为此创建额外的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ng-container 指令还有另一个主要的用例：它还可以提供一个占位符来动态地将模板注入页面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用 ngTemplateOutlet 指令动态创建模板</span></span><br><span class="line"><span class="string">ngIf，只是个开始。我们也可以通过 ngTemplateOutlet 指令将模板本身实例化到页面上的任何地方，紧接着上面的那个 loading 例子，这里做一下改动:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;ng-template #loading&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">&lt;ng-container *ngTemplateOutlet=&quot;loading&quot;&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">具体用法就是，通过模板引用语法 #loading 来引用 loading 模板，将 loading 赋值给 ngTemplateOutlet 结构指令，使其实例化模板。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们可以在页面上增加更多的 ngTemplateOutlet，并实例化各种不同的模板。稍后会介绍如何通过 ngTemplateOutlet 把一些值传递给模板。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在我们知道了如何实例化模板，让我们讨论一下模板可以访问什么或不能访问什么。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">模板上下文</span></span><br><span class="line"><span class="string">关于模板的一个关键问题是，它们里面有什么是可见的? 模板是否有自己独立的变量作用域，模板可以看到哪些变量?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 ng-template 标签中，我们可以访问与外部模板中相同的上下文变量，例如变量 lesson。这是因为所有 ng-template 实例都可以访问它们所嵌入的同一个上下文。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;ng-container *ngIf=&quot;lessons&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;lesson&quot; *ngFor=&quot;let lesson of lessons&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;lesson-detail&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;ng-container *ngIf=&quot;lesson else empty&quot;&gt; &#123;&#123;lesson | json&#125;&#125; &lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">      &lt;ng-template #empty&gt; &#123;&#123;lesson | json&#125;&#125; &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">但是每个模板也可以定义自己的一组输入变量! 实际上，每个模板都关联了一个上下文对象，该对象包含所有特定于模板的输入变量。在线例子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@Component(&#123;</span></span><br><span class="line"><span class="string">  selector: &quot;app-root&quot;,</span></span><br><span class="line"><span class="string">  template: `</span></span><br><span class="line"><span class="string">    &lt;ng-template #estimateTemplate let-lessonsCounter=&quot;estimate&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;Approximately &#123;&#123; lessonsCounter &#125;&#125; lessons ...&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    &lt;ng-container *ngTemplateOutlet=&quot;estimateTemplate; context: ctx&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">  `,</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">export class AppComponent &#123;</span></span><br><span class="line"><span class="string">  totalEstimate = 10;</span></span><br><span class="line"><span class="string">  ctx = &#123; estimate: this.totalEstimate &#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">以下是对这个例子的分析：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">与前面的模板不同，这个模板有一个输入变量（它也可以有几个）</span></span><br><span class="line"><span class="string">通过 ng-template 上前缀为 let- 的属性来定义了一个输入变量 lessonsCounter</span></span><br><span class="line"><span class="string">lessonsCounter 变量只能在 ng-template 内部可见</span></span><br><span class="line"><span class="string">该变量的内容由赋给 let-lessonsCounter 属性的表达式 estimate 决定</span></span><br><span class="line"><span class="string">estimate 表达式根据上下文对象 context 求值，并将其与要实例化的模板一起传递给 ngTemplateOutlet</span></span><br><span class="line"><span class="string">上下文对象 context 有一个名为 estimate 的属性，以便在模板中显示该值</span></span><br><span class="line"><span class="string">还可以给 ctx 对象添加其他属性，然后通过 ngTemplateOutlet 的 context 输入到 ng-template，从而可以拿到更多的输入变量</span></span><br><span class="line"><span class="string">最终在屏幕上展示的结果是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Approximately 10 lessons ...</span></span><br><span class="line"><span class="string">这让我们对如何定义和实例化自己的模板有了一个很好的概览。使用这样的方式还可以在 component 中通过模板进行编码，接下来就会介绍。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Template References</span></span><br><span class="line"><span class="string">与在页面上使用模板引用名来引用 loading 模板相同（采用这样的方式#loading），我们也可以使用 ViewChild 装饰器直接把模板引用注入到组件里。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@Component(&#123;</span></span><br><span class="line"><span class="string">  selector: &quot;app-root&quot;,</span></span><br><span class="line"><span class="string">  template: `</span></span><br><span class="line"><span class="string">    &lt;ng-template #defaultTabButtons&gt;</span></span><br><span class="line"><span class="string">      &lt;button class=&quot;tab-button&quot; (click)=&quot;login()&quot;&gt;&#123;&#123; loginText &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button class=&quot;tab-button&quot; (click)=&quot;signUp()&quot;&gt;&#123;&#123; signUpText &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">  `,</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">export class AppComponent implements OnInit &#123;</span></span><br><span class="line"><span class="string">  @ViewChild(&quot;defaultTabButtons&quot;)</span></span><br><span class="line"><span class="string">  private defaultTabButtonsTpl: TemplateRef&lt;any&gt;;</span></span><br><span class="line"><span class="string">  ngOnInit() &#123;</span></span><br><span class="line"><span class="string">    console.log(this.defaultTabButtonsTpl);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">译注：@ViewChild 属性装饰器，用于配置一个视图查询。 变更检测器会在视图的 DOM 中查找能匹配上该选择器的第一个元素或指令。 如果视图的 DOM 发生了变化，出现了匹配该选择器的新的子节点，该属性就会被更新。 官网地址</span></span><br><span class="line"><span class="string">正如我们所看到的，可以像注入任何其他 DOM 元素或组件一样，通过提供模板引用名来注入模板，将 defaultTabButtons 设置到 ViewChild 装饰器上。通过这样的方式，在 component class 里，我们可以访问这个模板引用，还可以把它传递给子组件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重点：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这个例子表明，当想设计一个支持定制化的组件时，不仅仅是通过传入配置参数或配置对象来实现，还可以通过传入模板来实现。在线例子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 传入配置参数或配置对象</span></span><br><span class="line"><span class="string">  @Input() title: string;</span></span><br><span class="line"><span class="string">  // 传入模板</span></span><br><span class="line"><span class="string">  @Input() titleTpl: TemplateRef&lt;any&gt;;</span></span><br><span class="line"><span class="string">通过模板类型的 @Input() 实现可配置化组件</span></span><br><span class="line"><span class="string">让我们以一个选项卡容器为例，我们希望在这个容器中提供可配置选项卡按钮的外观。下面是它的样子，我们将在父组件中定义按钮的模板：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@Component(&#123;</span></span><br><span class="line"><span class="string">  selector: &quot;app-root&quot;,</span></span><br><span class="line"><span class="string">  template: `</span></span><br><span class="line"><span class="string">    &lt;ng-template #customTabButtons&gt;</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;custom-class&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;button class=&quot;tab-button&quot; (click)=&quot;login()&quot;&gt;&#123;&#123; loginText &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;button class=&quot;tab-button&quot; (click)=&quot;signUp()&quot;&gt;</span></span><br><span class="line"><span class="string">          &#123;&#123; signUpText &#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    &lt;tab-container [headerTemplate]=&quot;defaultTabButtons&quot;&gt;&lt;/tab-container&gt;</span></span><br><span class="line"><span class="string">  `,</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">export class AppComponent implements OnInit &#123;&#125;</span></span><br><span class="line"><span class="string">然后在标签容器组件上，我们可以定义一个 input 属性，它是一个名为 headerTemplate 的模板：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@Component(&#123;</span></span><br><span class="line"><span class="string">  selector: &quot;tab-container&quot;,</span></span><br><span class="line"><span class="string">  template: `</span></span><br><span class="line"><span class="string">    &lt;ng-template #defaultTabButtons&gt;</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;default-tab-buttons&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    &lt;ng-container</span></span><br><span class="line"><span class="string">      *ngTemplateOutlet=&quot;headerTemplate ? headerTemplate : defaultTabButtons&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">    ... rest of tab container component ...</span></span><br><span class="line"><span class="string">  `,</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">export class TabContainerComponent &#123;</span></span><br><span class="line"><span class="string">  @Input()</span></span><br><span class="line"><span class="string">  headerTemplate: TemplateRef&lt;any&gt;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">再来分析下最后的这个例子：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在这个 tab-container 组件里有一个 defaultTabButtons 模板</span></span><br><span class="line"><span class="string">当 headerTemplate 未定义时会使用 defaultTabButtons</span></span><br><span class="line"><span class="string">如果 headerTemplate 是有定义的，则会使用通过 headerTemplate 传进来的模板</span></span><br><span class="line"><span class="string">headerTemplate 在 ng-container 的 ngTemplateOutlet 被实例化</span></span><br><span class="line"><span class="string">目前的逻辑是三元表达式，如果复杂的话，可以通过自定义函数来实现</span></span><br><span class="line"><span class="string">这种设计的最终结果是，如果没有提供自定义模板，选项卡容器将显示选项卡按钮的默认外观，但如果有自定义模板，它将使用自定义模板。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">译注：这个例子是可能是想表达出，在设计定制化组件时，需要考虑默认的显示外观。</span></span><br><span class="line"><span class="string">总结和结论</span></span><br><span class="line"><span class="string">核心指令 ng-container , ng-template 和 ngTemplateOutlet 结合在一起，允许我们创建高度动态的和可定制的组件。我们甚至可以根据 @Input() template 完全改变组件的外观，并且可以定义一个模板并在应用程序的多个位置实例化。而这只是将这些功能结合起来的一种可能方式!</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ng-template-ng-container-和-ngTemplateOutlet&quot;&gt;&lt;a href=&quot;#ng-template-ng-container-和-ngTemplateOutlet&quot; class=&quot;headerlink&quot; title=&quot;ng-tem</summary>
      
    
    
    
    <category term="ng-template, ng-container 和 ngTemplateOutlet 的完整使用指南" scheme="https://qyjs.github.io/categories/ng-template-ng-container-%E5%92%8C-ngTemplateOutlet-%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="ng-template, ng-container 和 ngTemplateOutlet 的完整使用指南" scheme="https://qyjs.github.io/tags/ng-template-ng-container-%E5%92%8C-ngTemplateOutlet-%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>防止网页被嵌入框架的代码</title>
    <link href="https://qyjs.github.io/2023/10/17/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://qyjs.github.io/2023/10/17/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2023-10-17T07:28:18.000Z</published>
    <updated>2023-10-17T02:10:03.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防止网页被嵌入框架的代码"><a href="#防止网页被嵌入框架的代码" class="headerlink" title="防止网页被嵌入框架的代码"></a>防止网页被嵌入框架的代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">　　top.<span class="property">location</span>.<span class="property">hostname</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (top.<span class="property">location</span>.<span class="property">hostname</span> != <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>) &#123;</span><br><span class="line"></span><br><span class="line">　　　　top.<span class="property">location</span>.<span class="property">href</span> =<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">　　top.<span class="property">location</span>.<span class="property">href</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;a href=&quot;#防止网页被嵌入框架的代码&quot; class=&quot;headerlink&quot; title=&quot;防止网页被嵌入框架的代码&quot;&gt;&lt;/a&gt;防止网页被嵌入框架的代码&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="防止网页被嵌入框架的代码" scheme="https://qyjs.github.io/categories/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    
    
    <category term="防止网页被嵌入框架的代码" scheme="https://qyjs.github.io/tags/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>130 个令你眼前一亮的网站</title>
    <link href="https://qyjs.github.io/2021/09/22/130%20%E4%B8%AA%E4%BB%A4%E4%BD%A0%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>https://qyjs.github.io/2021/09/22/130%20%E4%B8%AA%E4%BB%A4%E4%BD%A0%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E7%BD%91%E7%AB%99/</id>
    <published>2021-09-22T11:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="130-个令你眼前一亮的网站"><a href="#130-个令你眼前一亮的网站" class="headerlink" title="130 个令你眼前一亮的网站"></a>130 个令你眼前一亮的网站</h2><p>搞学习</p><p>CSDN：<a href="https://www.csdn.net/">https://www.csdn.net/</a></p><p>TED（最优质的演讲）：<a href="https://www.ted.com/">https://www.ted.com/</a></p><p>谷粉学术：<a href="https://gfsoso.99lb.net/scholar.html">https://gfsoso.99lb.net/scholar.html</a></p><p>大学资源网：<a href="http://www.dxzy163.com/">http://www.dxzy163.com/</a></p><p>简答题：<a href="http://www.jiandati.com/">http://www.jiandati.com/</a></p><p>网易公开课：<a href="https://open.163.com/ted/">https://open.163.com/ted/</a></p><p>网易云课堂：<a href="https://study.163.com/">https://study.163.com/</a></p><p>中国大学MOOC：<a href="http://www.icourse163.org/">www.icourse163.org</a></p><p>哔哩哔哩弹幕网：<a href="http://www.bilibili.com/">www.bilibili.com</a></p><p>我要自学网：<a href="http://www.51zxw.net/">www.51zxw.net</a></p><p>知乎：<a href="http://www.zhihu.com/">www.zhihu.com</a></p><p>学堂在线：<a href="http://www.xuetangx.com/">www.xuetangx.com</a></p><p>爱课程：<a href="http://www.icourses.cn/">www.icourses.cn</a></p><p>猫咪论文：<a href="https://lunwen.im/">https://lunwen.im/</a></p><p>iData（论文搜索）：<a href="http://www.cn-ki.net/">www.cn-ki.net</a></p><p>文泉考试：<a href="https://www.wqkaoshi.com/">https://www.wqkaoshi.com</a></p><p>找书籍</p><p>书栈网（极力推荐）：<a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a></p><p>码农之家（计算机电子书下载）：<a href="http://www.xz577.com/">www.xz577.com</a></p><p>鸠摩搜书：<a href="http://www.jiumodiary.com/">www.jiumodiary.com</a></p><p>云海电子图书馆：<a href="http://www.pdfbook.cn/">www.pdfbook.cn</a></p><p>周读（书籍搜索）：ireadweek.com</p><p>知轩藏书：<a href="http://www.zxcs.me/">http://www.zxcs.me/</a></p><p>脚本之家电子书下载：<a href="https://www.jb51.net/books/">https://www.jb51.net/books/</a></p><p>搜书VIP-电子书搜索：<a href="http://www.soshuvip.com/all.html">http://www.soshuvip.com/all.html</a></p><p>书格（在线古籍图书馆）：</p><p><a href="https://new.shuge.org/">https://new.shuge.org/</a></p><p>caj云阅读：</p><p><a href="http://cajviewer.cnki.net/cajcloud/">http://cajviewer.cnki.net/cajcloud/</a></p><p>必看网（人生必看的书籍）：</p><p><a href="https://www.biikan.com/">https://www.biikan.com/</a></p><p>冷知识 / 黑科技</p><p>上班摸鱼必备（假装电脑系统升级）：<a href="http://fakeupdate.net/">http://fakeupdate.net/</a></p><p>PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）：</p><p><a href="http://www.species-in-pieces.com/">http://www.species-in-pieces.com/</a></p><p>图片立体像素画：</p><p><a href="https://pissang.github.io/voxelize-image/">https://pissang.github.io/voxelize-image/</a></p><p>福利单词（一个不太正经的背单词网站）：</p><p><a href="http://dict.ftqq.com/">http://dict.ftqq.com</a></p><p>查无此人（刷新网站，展现一张AI 生成的人脸照片）：</p><p><a href="https://thispersondoesnotexist.com/">https://thispersondoesnotexist.com/</a></p><p>在线制作地图图例：<a href="https://mapchart.net/">https://mapchart.net/</a></p><p>创意光线绘画：<a href="http://weavesilk.com/">http://weavesilk.com/</a></p><p>星系观察：<a href="https://stellarium-web.org/">https://stellarium-web.org/</a></p><p>煎蛋：<a href="http://jandan.net/">http://jandan.net/</a></p><p>渣男-说话的艺术：<a href="https://lovelive.tools/">https://lovelive.tools/</a></p><p>全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a></p><p>iData：<a href="https://www.cn-ki.net/">https://www.cn-ki.net/</a></p><p>术语在线：<a href="http://www.termonline.cn/">http://www.termonline.cn/</a></p><p>写代码</p><p>GitHub：<a href="https://github.com/">https://github.com/</a></p><p>码云：<a href="https://gitee.com/">https://gitee.com/</a></p><p>源码之家：<a href="https://www.mycodes.net/">https://www.mycodes.net/</a></p><p>JSON to Dart：</p><p><a href="https://javiercbk.github.io/json_to_dart/">https://javiercbk.github.io/json_to_dart/</a></p><p>Json在线解析验证：</p><p><a href="https://www.json.cn/">https://www.json.cn/</a></p><p>在线接口测试（Getman）：</p><p><a href="https://getman.cn/">https://getman.cn/</a></p><p>资源搜索  </p><p>DogeDoge搜索引擎：<a href="http://www.dogedoge.com/">www.dogedoge.com</a></p><p>秘迹搜索：<a href="https://mijisou.com/">https://mijisou.com/</a></p><p>小白盘：<a href="https://www.xiaobaipan.com/">https://www.xiaobaipan.com/</a></p><p>云盘精灵（资源搜索）：</p><p><a href="http://www.yunpanjingling.com/">www.yunpanjingling.com</a></p><p>虫部落（资源搜索）：</p><p><a href="http://www.chongbuluo.com/">www.chongbuluo.com</a></p><p>如风搜（资源搜索）：</p><p><a href="http://www.rufengso.net/">http://www.rufengso.net/</a></p><p>爱扒：<a href="https://www.zyboe.com/">https://www.zyboe.com/</a></p><p>小工具  </p><p>奶牛快传（在线传输文件利器）：cowtransfer.com</p><p>文叔叔（大文件传输，不限速）：</p><p><a href="https://www.wenshushu.cn/">https://www.wenshushu.cn/</a></p><p>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/">https://uzer.me/</a></p><p>香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：</p><p><a href="https://www.xiangdang.net/">https://www.xiangdang.net/</a></p><p>二维码生成：<a href="https://cli.im/">https://cli.im/</a></p><p>搜狗翻译：fanyi.sogou.com</p><p>熵数（图表制作，数据可视化）：</p><p><a href="https://dydata.io/appv2/#/pages/index/home">https://dydata.io/appv2/#/pages/index/home</a></p><p>拷贝兔：<a href="https://cp.anyknew.com/">https://cp.anyknew.com/</a></p><p>图片无限变放大：<a href="http://bigjpg.com/zh">http://bigjpg.com/zh</a></p><p>幕布（在线大纲笔记工具）：mubu.com</p><p>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/">https://zh.justcnw.com/</a></p><p>调查问卷制作：</p><p><a href="https://www.wenjuan.com/">https://www.wenjuan.com/</a></p><p>果核剥壳（软件下载）：</p><p><a href="https://www.ghpym.com/">https://www.ghpym.com/</a></p><p>软件下载：<a href="https://www.unyoo.com/">https://www.unyoo.com/</a></p><p>MSDN我告诉你（windows10系统镜像下载）：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p><p>导航页（工具集）</p><p>世界各国网址大全：</p><p><a href="http://www.world68.com/">http://www.world68.com/</a></p><p>小森林导航：<a href="http://www.xsldh6.com/">http://www.xsldh6.com/</a></p><p>简捷工具：<a href="http://www.shulijp.com/">http://www.shulijp.com/</a></p><p>NiceTool.net 好工具网：</p><p><a href="http://www.nicetool.net/">http://www.nicetool.net/</a></p><p>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/">http://tool.uixsj.cn/</a></p><p>蓝调网站：<a href="http://lcoc.top/">http://lcoc.top/</a></p><p>偷渡鱼：<a href="https://touduyu.com/">https://touduyu.com/</a></p><p>牛导航：<a href="http://www.ziliao6.com/">http://www.ziliao6.com/</a></p><p>小呆导航：</p><p><a href="https://www.webjike.com/index.html">https://www.webjike.com/index.html</a></p><p>简法主页：<a href="http://www.jianfast.com/">http://www.jianfast.com/</a></p><p>KIM主页：<a href="https://kim.plopco.com/">https://kim.plopco.com/</a></p><p>聚BT：<a href="https://jubt.net/cn/index.html">https://jubt.net/cn/index.html</a></p><p>精准云工具合集：</p><p><a href="https://jingzhunyun.com/">https://jingzhunyun.com/</a></p><p>兔2工具合集：<a href="https://www.tool2.cn/">https://www.tool2.cn/</a></p><p>爱资料工具（在线实用工具集合）：</p><p><a href="http://www.toolnb.com/">www.toolnb.com</a></p><p>工具导航：<a href="https://hao.logosc.cn/">https://hao.logosc.cn/</a></p><p>看视频</p><p>阿木影视：<a href="https://www.aosk.online/">https://www.aosk.online/</a></p><p>电影推荐（分类别致）：</p><p><a href="http://www.mvcat.com/">http://www.mvcat.com</a></p><p>APP影院：<a href="https://app.movie/">https://app.movie</a></p><p>去看TV：<a href="https://www.qukantv.net/">https://www.qukantv.net/</a></p><p>动漫视频网：<a href="http://www.zzzfun.com/">http://www.zzzfun.com/</a></p><p>94神马电影网：<a href="http://www.9rmb.com/">http://www.9rmb.com/</a></p><p>NO视频官网：<a href="http://www.novipnoad.com/">http://www.novipnoad.com/</a></p><p>蓝光画质电影：<a href="http://www.languang.co/">http://www.languang.co/</a></p><p>在线看剧：<a href="http://dy.27234.cn/">http://dy.27234.cn/</a></p><p>大数据导航：<a href="http://hao.199it.com/">http://hao.199it.com/</a></p><p>多功能图片网站：</p><p><a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p><p>牛牛TV：<a href="http://www.ziliao6.com/tv/">http://www.ziliao6.com/tv/</a></p><p>VideoFk解析视频：</p><p><a href="http://www.videofk.com/">http://www.videofk.com/</a></p><p>蓝调网站：<a href="http://lcoc.top/vip2.3/">http://lcoc.top/vip2.3/</a></p><p>永久资源采集网：</p><p><a href="http://www.yongjiuzy1.com/">http://www.yongjiuzy1.com/</a></p><p>学设计</p><p>码力全开（产品/设计师/独立开发者的资源库）：<a href="https://www.maliquankai.com/designnav/">https://www.maliquankai.com/designnav/</a></p><p>免费音频素材：<a href="https://icons8.cn/music">https://icons8.cn/music</a></p><p>新CG儿（视频素材模板，无水印+免费下载）：</p><p><a href="https://www.newcger.com/">https://www.newcger.com/</a></p><p>Iconfont（阿里巴巴矢量图标库）：</p><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p>小图标下载：<a href="https://www.easyicon.net/">https://www.easyicon.net/</a></p><p>Flight Icon：<a href="https://www.flighticon.co/">https://www.flighticon.co/</a></p><p>第一字体转换器：<a href="http://www.diyiziti.com/">http://www.diyiziti.com/</a></p><p>doyoudosh（平面设计）：</p><p><a href="http://www.doyoudo.com/">www.doyoudo.com</a></p><p>企业宣传视频在线制作：<a href="https://duomu.tv/">https://duomu.tv/</a></p><p>MAKE海报设计官网：<a href="http://maka.im/">http://maka.im/</a></p><p>一键海报神器：</p><p><a href="https://www.logosc.cn/photo/utm_source=hao.logosc.cn&amp;utm_medium=referral">https://www.logosc.cn/photo/utm_source=hao.logosc.cn&amp;utm_medium=referral</a></p><p>字由（字体设计）：</p><p><a href="http://www.hellofont.cn/">http://www.hellofont.cn/</a></p><p>查字体网站：<a href="https://fonts.safe.360.cn/">https://fonts.safe.360.cn/</a></p><p>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：<a href="http://www.aigei.com/">http://www.aigei.com/</a></p><p>在线视频剪辑：</p><p><a href="https://bilibili.clipchamp.com/editor">https://bilibili.clipchamp.com/editor</a></p><p>搞文档</p><p>即书（在线制作PPT）：</p><p><a href="https://www.keysuper.com/">https://www.keysuper.com/</a></p><p>PDF处理：<a href="https://smallpdf.com/cn">https://smallpdf.com/cn</a></p><p>PDF处理：<a href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a></p><p>PDF处理：<a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a></p><p>PDF处理：<a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a></p><p>图片压缩，PDF处理：</p><p><a href="https://docsmall.com/">https://docsmall.com/</a></p><p>腾讯文档（在线协作编辑和管理文档）：</p><p>docs.qq.com</p><p>ProcessOn（在线协作制作结构图）：</p><p><a href="http://www.processon.com/">www.processon.com</a></p><p>iLovePDF（在线转换PDF利器）：</p><p><a href="http://www.ilovepdf.com/">www.ilovepdf.com</a></p><p>PPT在线制作：<a href="https://www.woodo.cn/">https://www.woodo.cn/</a></p><p>PDF24工具（pdf处理工具）：</p><p><a href="https://tools.pdf24.org/en">https://tools.pdf24.org/en</a></p><p>IMGBOT（在线图片处理）：</p><p><a href="http://www.imgbot.ai/">www.imgbot.ai</a></p><p>福昕云编辑（在线编辑PDF）：</p><p>edit.foxitcloud.cn</p><p>TinyPNG（在线压缩图片）：tinypng.com</p><p>UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套</p><pre><code>     ）：uzer.me</code></pre><p>优品PPT（模板下载）：</p><p><a href="http://www.ypppt.com/">http://www.ypppt.com/</a></p><p>第一PPT（模板下载）：</p><p><a href="http://www.1ppt.com/xiazai/">http://www.1ppt.com/xiazai/</a></p><p>三顿PPT导航：sandunppt.com</p><p>Excel函数表：</p><p><a href="https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188">https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188</a></p><p>找图片</p><p>电脑壁纸：<a href="http://lcoc.top/bizhi/">http://lcoc.top/bizhi/</a></p><p><a href="https://unsplash.com/">https://unsplash.com/</a></p><p><a href="https://pixabay.com/">https://pixabay.com/</a></p><p><a href="https://www.pexels.com/">https://www.pexels.com/</a></p><p><a href="https://visualhunt.com/">https://visualhunt.com/</a></p><p><a href="https://www.ssyer.com/">https://www.ssyer.com/</a></p><p>彼岸图网：<a href="http://pic.netbian.com/">http://pic.netbian.com/</a></p><p>极像素（超高清大图）：</p><p><a href="https://www.sigoo.com/">https://www.sigoo.com/</a></p><p>免费版权图片搜索：</p><p><a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;130-个令你眼前一亮的网站&quot;&gt;&lt;a href=&quot;#130-个令你眼前一亮的网站&quot; class=&quot;headerlink&quot; title=&quot;130 个令你眼前一亮的网站&quot;&gt;&lt;/a&gt;130 个令你眼前一亮的网站&lt;/h2&gt;&lt;p&gt;搞学习&lt;/p&gt;
&lt;p&gt;CSDN：&lt;a hre</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>8个工程必备的JavaScript代码片段</title>
    <link href="https://qyjs.github.io/2021/09/22/JavaScript%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <id>https://qyjs.github.io/2021/09/22/JavaScript%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</id>
    <published>2021-09-22T06:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-个工程必备的-JavaScript-代码片段"><a href="#8-个工程必备的-JavaScript-代码片段" class="headerlink" title="8 个工程必备的 JavaScript 代码片段"></a>8 个工程必备的 JavaScript 代码片段</h2><h3 id="获取文件后缀名"><a href="#获取文件后缀名" class="headerlink" title="获取文件后缀名"></a>获取文件后缀名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件后缀名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; <span class="variable">filename</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getExt</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> filename == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> filename.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">pop</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;filename must be a string type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getExt</span>(<span class="string">&quot;1.mp4&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="复制内容到剪贴板"><a href="#复制内容到剪贴板" class="headerlink" title="复制内容到剪贴板"></a>复制内容到剪贴板</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">copyToBoard</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;textarea&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element)</span><br><span class="line">    element.<span class="property">value</span> = value</span><br><span class="line">    element.<span class="title function_">select</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>)) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copyToBoard</span>(<span class="string">&#x27;lalallala&#x27;</span>)</span><br><span class="line"></span><br><span class="line">- 创建一个textare元素并调用<span class="title function_">select</span>()方法选中</span><br><span class="line">- <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>)方法，拷贝当前选中内容到剪贴板。</span><br></pre></td></tr></table></figure><h3 id="休眠多少毫秒"><a href="#休眠多少毫秒" class="headerlink" title="休眠多少毫秒"></a>休眠多少毫秒</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 休眠xxxms</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">milliseconds</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成随机id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">length</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">chars</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">uuid</span>(<span class="params">length, chars</span>) &#123;</span><br><span class="line">  chars =</span><br><span class="line">    chars || <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">  length = length || <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    result += chars[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * chars.<span class="property">length</span>)];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">uuid</span>();</span><br></pre></td></tr></table></figure><h3 id="简单的深拷贝"><a href="#简单的深拷贝" class="headerlink" title="简单的深拷贝"></a>简单的深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 缺陷：只拷贝对象、数组以及对象数组，对于大部分场景已经足够</span><br><span class="line"><span class="keyword">const</span> person=&#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="attr">child</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="title function_">deepCopy</span>(person)</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">uniqueArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;The first parameter must be an array&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-原理是利用<span class="title class_">Set</span>中不能出现重复元素的特性;</span><br><span class="line"><span class="title function_">uniqueArray</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="对象转化为-FormData-对象"><a href="#对象转化为-FormData-对象" class="headerlink" title="对象转化为 FormData 对象"></a>对象转化为 FormData 对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转化为formdata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">object</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getFormData</span>(<span class="params">object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(object).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = object[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            value.<span class="title function_">forEach</span>(<span class="function">(<span class="params">subValue, i</span>) =&gt;</span></span><br><span class="line">                formData.<span class="title function_">append</span>(key + <span class="string">`[<span class="subst">$&#123;i&#125;</span>]`</span>, subValue)</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            formData.<span class="title function_">append</span>(key, object[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> formData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 上传文件时我们要新建一个<span class="title class_">FormData</span>对象，然后有多少个参数就append多少次，使用该函数可以简化逻辑</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req=&#123;</span><br><span class="line">    <span class="attr">file</span>:xxx,</span><br><span class="line">    <span class="attr">userId</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">phone</span>:<span class="string">&#x27;15198763636&#x27;</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fetch</span>(<span class="title function_">getFormData</span>(req))</span><br></pre></td></tr></table></figure><h3 id="保留到小数点以后-n-位"><a href="#保留到小数点以后-n-位" class="headerlink" title="保留到小数点以后 n 位"></a>保留到小数点以后 n 位</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留小数点以后几位，默认2位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cutNumber</span>(<span class="params">number, no = <span class="number">2</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> number != <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    number = <span class="title class_">Number</span>(number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>(number.<span class="title function_">toFixed</span>(no));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;8-个工程必备的-JavaScript-代码片段&quot;&gt;&lt;a href=&quot;#8-个工程必备的-JavaScript-代码片段&quot; class=&quot;headerlink&quot; title=&quot;8 个工程必备的 JavaScript 代码片段&quot;&gt;&lt;/a&gt;8 个工程必备的 JavaS</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>加密文章测试</title>
    <link href="https://qyjs.github.io/2021/02/21/private/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/"/>
    <id>https://qyjs.github.io/2021/02/21/private/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/</id>
    <published>2021-02-21T02:14:11.000Z</published>
    <updated>2022-12-21T07:00:17.378Z</updated>
    
    <content type="html"><![CDATA[<h4 id="加密文章测试"><a href="#加密文章测试" class="headerlink" title="加密文章测试"></a>加密文章测试</h4><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p><p>这是一篇加密文章，这里是加密信息！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;加密文章测试&quot;&gt;&lt;a href=&quot;#加密文章测试&quot; class=&quot;headerlink&quot; title=&quot;加密文章测试&quot;&gt;&lt;/a&gt;加密文章测试&lt;/h4&gt;&lt;p&gt;这是一篇加密文章，这里是加密信息！&lt;/p&gt;
&lt;p&gt;这是一篇加密文章，这里是加密信息！&lt;/p&gt;
&lt;p&gt;这是一篇</summary>
      
    
    
    
    <category term="private" scheme="https://qyjs.github.io/categories/private/"/>
    
    
    <category term="加密文章" scheme="https://qyjs.github.io/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://qyjs.github.io/2021/01/27/demo/"/>
    <id>https://qyjs.github.io/2021/01/27/demo/</id>
    <published>2021-01-27T11:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.376Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年前端面试复习必读文章【超三百篇】<br>前端开发 2020-11-03<br>以下文章来源于前端试炼 ，作者axuebin</p><p>来自公众号：前端试炼<br>前言<br>十分全面的前端面试复习导图，覆盖三百篇精选文章，希望能够「授人以鱼，不如授之以渔」，已经有同学照这份导图进行复习，收获满意的offer。</p><p>给大家整理了一下每个 case 一些还算不错的文章吧（还包括一些躺在我收藏夹里的好文章），大家可以自己看文章总结一下答案，这样也会理解更深刻。</p><p>希望是一个抛砖引玉的作用，希望大家也可以锻炼一下找有效资料的能力 ~</p><p>( 文章排序不分前后，随机排序 ~</p><p>由于微信无法打开外链，所有的链接都在文章最底下啦，可以在电脑上打开、收藏这篇文章 ~</p><p>或点击阅读原文打开发在掘金上的这篇文章。</p><p>带👉的文章是微信里可以直接打开的。</p><p>完整面试复习导图在公众号后台回复：面试。</p><span id="more"></span><ol><li>JavaScript 基础<br>图片</li></ol><p>1.1 执行上下文/作用域链/闭包<br>理解 JavaScript 中的执行上下文和执行栈[1]<br>JavaScript深入之执行上下文栈[2]<br>一道js面试题引发的思考[3]<br>JavaScript深入之词法作用域和动态作用域[4]<br>JavaScript深入之作用域链[5]<br>发现 JavaScript 中闭包的强大威力[6]<br>JavaScript闭包的底层运行机制[7]<br>我从来不理解JavaScript闭包，直到有人这样向我解释它…[8]<br>破解前端面试（80% 应聘者不及格系列）：从闭包说起[9]<br>1.2 this/call/apply/bind<br>JavaScript基础心法——this[10]<br>JavaScript深入之从ECMAScript规范解读this[11]<br>前端基础进阶（七）：全方位解读this[12]<br>面试官问：JS的this指向[13]<br>JavaScript深入之call和apply的模拟实现[14]<br>JavaScript基础心法—— call apply bind[15]<br>面试官问：能否模拟实现JS的call和apply方法[16]<br>回味JS基础:call apply 与 bind[17]<br>面试官问：能否模拟实现JS的bind方法[18]<br>不用call和apply方法模拟实现ES5的bind方法[19]<br>1.3 原型/继承<br>👉深入理解 JavaScript 原型<br>【THE LAST TIME】一文吃透所有JS原型相关知识点[20]<br>重新认识构造函数、原型和原型链[21]<br>JavaScript深入之从原型到原型链[22]<br>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）[23]<br>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）[24]<br>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）[25]<br>JavaScript 引擎基础：原型优化[26]<br>Prototypes in JavaScript[27]<br>JavaScript深入之创建对象的多种方式以及优缺点[28]<br>详解JS原型链与继承[29]<br>从__proto__和prototype来深入理解JS对象和原型链[30]<br>代码复用模式[31]<br>JavaScript 中的继承：ES3、ES5 和 ES6[32]<br>1.4 Promise<br>👉100 行代码实现 Promises/A+ 规范<br>你好，JavaScript异步编程—- 理解JavaScript异步的美妙[33]<br>Promise不会？？看这里！！！史上最通俗易懂的Promise！！！[34]<br>一起学习造轮子（一）：从零开始写一个符合Promises/A+规范的promise[35]<br>Promise实现原理（附源码）[36]<br>当 async/await 遇上 forEach[37]<br>Promise 必知必会（十道题）[38]<br>BAT前端经典面试问题：史上最最最详细的手写Promise教程[39]<br>async function async1() {<br>  console.log(‘async1 start’);<br>  await async2();<br>  console.log(‘async1 end’);<br>}</p><p>// 相当于<br>async function async1() {<br>  console.log(‘async1 start’);<br>  Promise.resolve(async2()).then(() =&gt; {<br>    console.log(‘async1 end’);<br>  })<br>}<br>1.5 深浅拷贝<br>JavaScript基础心法——深浅拷贝[40]<br>深拷贝的终极探索（90%的人都不知道）[41]<br>JavaScript专题之深浅拷贝[42]<br>javaScript中浅拷贝和深拷贝的实现[43]<br>深入剖析 JavaScript 的深复制[44]<br>「JavaScript」带你彻底搞清楚深拷贝、浅拷贝和循环引用[45]<br>面试题之如何实现一个深拷贝[46]<br>1.6 事件机制/Event Loop<br>Tasks, microtasks, queues and schedules[47]<br>How JavaScript works[48]<br>从event loop规范探究javaScript异步及浏览器更新渲染时机[49]<br>这一次，彻底弄懂 JavaScript 执行机制[50]<br>【THE LAST TIME】彻底吃透 JavaScript 执行机制[51]<br>一次弄懂Event Loop（彻底解决此类面试问题）[52]<br>浏览器与Node的事件循环(Event Loop)有何区别?[53]<br>深入理解 JavaScript Event Loop[54]<br>The Node.js Event Loop, Timers, and process.nextTick()[55]<br>这个知识点真的是重在理解，一定要理解彻底</p><p>for (macroTask of macroTaskQueue) {<br>  handleMacroTask();</p><p>  for (microTask of microTaskQueue) {<br>    handleMicroTask(microTask);<br>  }<br>}<br>1.7 函数式编程<br>函数式编程指北[56]<br>JavaScript专题之函数柯里化[57]<br>Understanding Functional Programming in Javascript[58]<br>What is Functional Programming?[59]<br>简明 JavaScript 函数式编程——入门篇[60]<br>You Should Learn Functional Programming[61]<br>JavaScript 函数式编程到底是个啥[62]<br>JavaScript-函数式编程[63]<br>1.8 Service Worker / PWA<br>Service Worker：简介[64]<br>JavaScript 是如何工作的：Service Worker 的生命周期及使用场景[65]<br>借助Service Worker和cacheStorage缓存及离线开发[66]<br>PWA Lavas 文档[67]<br>PWA 学习手册[68]<br>面试官：请你实现一个PWA[69]<br>1.9 Web Worker<br>浅谈HTML5 Web Worker[70]<br>JavaScript 中的多线程 – Web Worker[71]<br>JavaScript 性能利器 —— Web Worker[72]<br>A Simple Introduction to Web Workers in JavaScript[73]<br>Speedy Introduction to Web Workers[74]<br>1.10 常用方法<br>太多了… 总的来说就是 API 一定要熟悉…</p><p>近一万字的ES6语法知识点补充[75]<br>ES6、ES7、ES8特性一锅炖<a href="76">ES6、ES7、ES8学习指南</a><br>解锁多种JavaScript数组去重姿势[77]<br>Here’s how you can make better use of JavaScript arrays[78]<br>一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧[79]<br>1.5万字概括ES6全部特性<a href="80">已更新ES2020</a><br>2. CSS 基础<br>图片</p><p>position - CSS: Cascading Style Sheets | MDN[81]<br>position | CSS Tricks[82]<br>杀了个回马枪，还是说说position:sticky吧[83]<br>30 分钟学会 Flex 布局[84]<br>css行高line-height的一些深入理解及应用[85]<br>A Complete Guide to Flexbox[86]<br>写给自己看的display: flex布局教程[87]<br>从网易与淘宝的font-size思考前端设计稿与工作流[88]<br>细说移动端 经典的REM布局 与 新秀VW布局[89]<br>移动端1px解决方案[90]<br>Retina屏的移动设备如何实现真正1px的线？[91]<br>CSS retina hairline, the easy way.[92]<br>浏览器的回流与重绘 <a href="93">Reflow &amp; Repaint</a><br>回流与重绘：CSS性能让JavaScript变慢？[94]<br>CSS实现水平垂直居中的1010种方式（史上最全）[95]<br>干货!各种常见布局实现[96]<br>CSS 常见布局方式[97]<br>彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index[98]<br>深入理解CSS中的层叠上下文和层叠顺序[99]<br>Sass vs. Less[100]<br>2019年，你是否可以抛弃 CSS 预处理器？[101]<br>浅谈 CSS 预处理器（一）：为什么要使用预处理器？[102]<br>浏览器将rem转成px时有精度误差怎么办？[103]<br>Fighting the Space Between Inline Block Elements[104]<br>3. 框架(Vue 为主)<br>图片</p><p>3.1 MVVM<br>50行代码的MVVM，感受闭包的艺术[105]<br>不好意思！耽误你的十分钟，让MVVM原理还给你[106]<br>基于Vue实现一个简易MVVM[107]<br>剖析Vue实现原理 - 如何实现双向绑定mvvm[108]<br>3.2 生命周期<br>Vue 生命周期源码剖析[109]<br>你真的理解 $nextTick么[110]<br>React 源码剖析系列 － 生命周期的管理艺术[111]<br>3.3 数据绑定<br>Vue 深入响应式原理[112]<br>面试官: 实现双向绑定Proxy比defineproperty优劣如何?[113]<br>👉为什么Vue3.0不再使用defineProperty实现数据监听？<br>3.4 状态管理<br>Vuex、Flux、Redux、Redux-saga、Dva、MobX[114]<br>10行代码看尽redux实现[115]<br>Mobx 思想的实现原理，及与 Redux 对比[116]<br>使用原生 JavaScript 构建状态管理系统[117]<br>3.5 组件通信<br>vue中8种组件通信方式, 值得收藏![118]<br>Vue 组件间通信六种方式（完整版）[119]<br>Vue组件间通信[120]<br>3.6 Virtual DOM<br>Vue Virtual DOM 源码剖析[121]<br>面试官: 你对虚拟DOM原理的理解?[122]<br>让虚拟DOM和DOM-diff不再成为你的绊脚石[123]<br>探索Virtual DOM的前世今生[124]<br>👉虚拟 DOM 到底是什么？(长文建议收藏)<br>3.7 Diff<br>详解vue的diff算法[125]<br>Deep In React 之详谈 React 16 Diff 策略<a href="126">二</a><br>React 源码剖析系列 － 不可思议的 react diff[127]<br>浅入浅出图解 Dom Diff[128]<br>3.8 Vue 计算属性 VS 侦听属性<br>Vue 计算属性 VS 侦听属性源码剖析[129]<br>Vue.js的computed和watch是如何工作的？[130]<br>3.9 React Hooks<br>React Hooks 原理[131]<br>React hooks: not magic, just arrays[132]<br>Deep dive: How do React hooks really work?[133]<br>【React深入】从Mixin到HOC再到Hook[134]<br>React Hooks 详解 【近 1W 字】+ 项目实战[135]<br>30分钟精通React今年最劲爆的新特性——React Hooks[136]<br>React Hooks 详解（一）[137]<br>3.10 React Hoc/Vue mixin<br>探索Vue高阶组件[138]<br>React 高阶组件(HOC)入门指南[139]<br>深入理解 React 高阶组件[140]<br>3.11 Vue 和 React 有什么不同<br>从思想、生态、语法、数据、通信、diff等角度自己总结一下吧。</p><ol start="4"><li>工程化<br>图片</li></ol><p>4.1 Webpack<br>前端工程师都得掌握的 webpack Loader[141]<br>👉webpack loader 从上手到理解系列：vue-loader<br>👉webpack loader 从上手到理解系列：style-loader<br>👉一文掌握Webpack编译流程<br>手把手教你撸一个简易的 webpack[142]<br>带你走进webpack世界，成为webpack头号玩家。[143]<br>👉关于webpack4的14个知识点,童叟无欺<br>手把手教你撸一个 Webpack Loader[144]<br>webpack 如何通过作用域分析消除无用代码[145]<br>【webpack进阶】你真的掌握了loader么？- loader十问[146]<br>Webpack小书[147]<br>聊一聊webpack-dev-server和其中socket，HMR的实现[148]<br>使用webpack4提升180%编译速度[149]<br>Webpack 大法之 Code Splitting[150]<br>👉轻松理解webpack热更新原理<br>轻松理解webpack热更新原理[151]<br>揭秘webpack plugin[152]<br>4.2 Babel<br>👉一篇文章了解前端开发必须懂的 Babel<br>不容错过的 Babel7 知识[153]<br>前端工程师需要了解的 Babel 知识[154]<br>深入浅出 Babel 上篇：架构和原理 + 实战[155]<br>深入浅出 Babel 下篇：既生 Plugin 何生 Macros[156]<br>前端工程师的自我修养-关于 Babel 那些事儿[157]<br>前端与编译原理——用JS写一个JS解释器[158]<br>4.3 模板引擎<br>编写一个简单的JavaScript模板引擎[159]<br>JavaScript模板引擎原理，几行代码的事儿[160]<br>Vue 模板编译原理[161]<br>JavaScript template engine in just 20 lines[162]<br>Understanding JavaScript Micro-Templating[163]<br>4.4 前端发布<br>大公司里怎样开发和部署前端代码？[164]<br>前端高级进阶：前端部署的发展历程[165]<br>4.5 weex<br>深入了解 Weex[166]<br>Weex原理概述[167]<br>Weex 是如何在 iOS 客户端上跑起来的[168]<br>详解 Weex 页面的渲染过程[169]<br>JSBridge 介绍及实现原理[170]<br>👉移动混合开发中的 JSBridge<br>4.6 前端监控<br>5 分钟撸一个前端性能监控工具[171]<br>把前端监控做到极致[172]<br>GMTC 大前端时代前端监控的最佳实践[173]<br>前端监控和前端埋点方案设计[174]<br>👉腾讯CDC团队：前端异常监控解决方案<br>5. 性能优化<br>图片</p><p>这个知识点不列文章啦，好多文章，列个知识点，动手搜一下吧 ~</p><p>5.1 打包阶段<br>Webpack优化——将你的构建效率提速翻倍[175]<br>性能优化篇—Webpack构建速度优化[176]<br>webpack构建速度与结果优化[177]<br>让你的Webpack起飞—考拉会员后台Webpack优化实战[178]<br>webpack dllPlugin打包体积和速度优化[179]<br>使用webpack4提升180%编译速度[180]<br>Webpack 打包优化之速度篇[181]<br>多进程并行压缩代码[182]<br>Tree-Shaking性能优化实践 - 原理篇[183]<br>体积减少80%！释放webpack tree-shaking的真正潜力[184]<br>你的Tree-Shaking并没什么卵用[185]<br>webpack 如何通过作用域分析消除无用代码[186]<br>加速Webpack-缩小文件搜索范围[187]<br>Brief introduction to scope hoisting in Webpack[188]<br>通过Scope Hoisting优化Webpack输出[189]<br>webpack 的 scope hoisting 是什么？[190]<br>webpack优化之code splitting[191]<br>webpack 4: Code Splitting和chunks切分优化[192]<br>Webpack 大法之 Code Splitting[193]<br>Better tree shaking with deep scope analysis[194]<br>Front-End Performance Checklist 2020[195]<br>（译）2019年前端性能优化清单 — 上篇[196]<br>5.2 其它优化<br>网站性能优化实战——从12.67s到1.06s的故事[197]<br>浏览器页面资源加载过程与优化[198]<br>聊聊前端开发中的长列表[199]<br>再谈前端虚拟列表的实现[200]<br>浅说虚拟列表的实现原理[201]<br>浏览器IMG图片原生懒加载loading=”lazy”实践指南[202]<br>用 preload 预加载页面资源[203]<br>👉App内网页启动加速实践：静态资源预加载视角<br>👉腾讯HTTPS性能优化实践<br>Preload, Prefetch And Priorities in Chrome[204]<br>Front-End Performance Checklist  [205]<br>图片与视频懒加载的详细指南[206]<br>使用 Intersection Observer 来懒加载图片[207]<br>6. TypeScript<br>图片</p><p>👉TypeScript 是什么<br>为什么要在javascript中进行静态类型检查[208]<br>TypeScript Start: 基础类型[209]<br>👉TypeScript真香系列——接口篇<br>TypeScript 中高级应用与最佳实践[210]<br>👉typescript 高级技巧<br>可能是你需要的 React + TypeScript 50 条规范和经验[211]<br>从 JavaScript 到 TypeScript[212]<br>TypeScript + 大型项目实战[213]<br>TypeScript - 一种思维方式[214]<br>如何编写一个d.ts文件[215]<br>TypeScript 的声明文件的使用与编写[216]<br>TypeScript 进阶：给第三方库编写声明文件[217]<br>TypeScript泛型[218]<br>TypeScript 重构 Axios 经验分享[219]<br>手把手教写 TypeScript Transformer Plugin[220]<br>7. 网络<br>图片</p><p>7.1 HTTP<br>听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？[221]<br>前端基础篇之HTTP协议[222]<br>都9102年了，还问GET和POST的区别[223]<br>HTTP 响应代码 | MDN[224]<br>如何理解HTTP响应的状态码？[225]<br>你所知道的3xx状态码[226]<br>👉关于浏览器缓存你知道多少<br>浏览器缓存[227]<br>HTTP协议头部与Keep-Alive模式详解[228]<br>HTTP keep-alive 二三事[229]<br>7.2 HTTPS/HTTP2<br>深入理解HTTPS工作原理[230]<br>九个问题从入门到熟悉HTTPS[231]<br>谈谈 HTTPS[232]<br>看图学HTTPS[233]<br>分分钟让你理解HTTPS[234]<br>解密HTTP/2与HTTP/3 的新特性[235]<br>浅谈 HTTP/2 Server Push[236]<br>HTTP2基本概念学习笔记[237]<br>7.3 DNS<br>写给前端工程师的DNS基础知识[238]<br>前端优化: DNS预解析提升页面速度[239]<br>DNS解析[240]<br>7.4 TCP<br>通俗大白话来理解TCP协议的三次握手和四次分手[241]<br>就是要你懂 TCP[242]<br>TCP协议详解[243]<br>面试时，你被问到过 TCP/IP 协议吗?[244]<br>“三次握手，四次挥手”你真的懂吗？[245]<br>7.5 CDN<br>五分钟了解CDN[246]<br>漫话：如何给女朋友解释什么是CDN？[247]<br>关于 cdn、回源等问题一网打尽[248]<br>CDN是什么？使用CDN有什么优势？[249]<br>7.6 经典题<br>从输入URL到页面展示，这中间发生了什么？[250]<br>前端经典面试题: 从输入URL到页面加载发生了什么？[251]<br>8. 设计模式<br>图片</p><p>Javascript常用的设计模式详解[252]<br>JavaScript设计模式[253]<br>JavaScript 中常见设计模式整理[254]<br>JavaScript 常见设计模式解析[255]<br>深入 JavaScript 设计模式，从此有了优化代码的理论依据[256]<br>设计模式之美-前端[257]<br>9. 数据结构/算法<br>图片</p><p>Linked Lists in JavaScript <a href="258">ES6 code</a><br>DS with JS — Linked Lists — II[259]<br>LeetCode List[260]<br>JS中的算法与数据结构——链表<a href="261">Linked-list</a><br>前端笔试&amp;面试爬坑系列—算法[262]<br>漫画：什么是红黑树？[263]<br>前端你应该了解的数据结构与算法[264]<br>数据结构和算法在前端领域的应用（前菜）[265]<br>数据结构与算法在前端领域的应用 - 第二篇[266]<br>JavaScript 数据结构与算法之美[267]<br>10. 安全<br>图片</p><p>前端安全系列（一）：如何防止XSS攻击？[268]<br>前端安全系列（二）：如何防止CSRF攻击？[269]<br>Security[270]<br>前端也需要了解的 JSONP 安全[271]<br>【面试篇】寒冬求职之你必须要懂的Web安全[272]<br>谈谈对 Web 安全的理解[273]<br>程序员必须要了解的web安全[274]<br>可信前端之路：代码保护[275]<br>前端如何给 JavaScript 加密（不是混淆）？[276]<br>常见 Web 安全攻防总结[277]<br>11. Node<br>一篇文章构建你的 NodeJS 知识体系[278]<br>真-Node多线程[279]<br>浏览器与Node的事件循环(Event Loop)有何区别?[280]<br>聊聊 Node.js RPC[281]<br>Understanding Streams in Node.js[282]<br>👉深入理解 Node.js 进程与线程<br>如何通过饿了么 Node.js 面试[283]<br>字节跳动面试官：请你实现一个大文件上传和断点续传[284]<br>12. 项目/业务<br>思考题，自由发挥</p><ol start="13"><li>其它<br>深入浅出浏览器渲染原理[285]<br>前端开发如何独立解决跨域问题[286]<br>探索 Serverless 中的前端开发模式[287]<br>「NGW」前端新技术赛场：Serverless SSR 技术内幕[288]<br>JavaScript与Unicode[289]<br>九种跨域方式实现原理（完整版）[290]<br>7分钟理解JS的节流、防抖及使用场景[291]<br>浏览器的工作原理：新式网络浏览器幕后揭秘[292]<br>Different Types Of Observers Supported By Modern Browsers[293]<br>浏览器同源策略与ajax跨域方法汇总[294]</li><li>面试<br>一年半经验如何准备阿里巴巴 P6 前端面试[295]</li></ol><p>面试分享：两年工作经验成功面试阿里P6总结[296]</p><p>总结了17年初到18年初百场前端面试的面试经验<a href="297">含答案</a></p><p>2018春招前端面试: 闯关记(精排精校) | 掘金技术征文[298]</p><p>20道JS原理题助你面试一臂之力！[299]</p><p>一年半经验，百度、有赞、阿里前端面试总结[300]</p><p>22 道高频 JavaScript 手写面试题及答案[301]</p><p>面试分享：专科半年经验面试阿里前端P6+总结<a href="302">附面试真题及答案</a></p><p>写给 女朋友的中级前端面试秘籍[303]</p><p>阿里前端攻城狮们写了一份前端面试题答案，请查收[304]</p><p>字节跳动今日头条前端面经（4轮技术面+hr面）[305]</p><p>「面试题」20+Vue面试题整理<a href="306">持续更新</a></p><p>「吐血整理」再来一打Webpack面试题<a href="307">持续更新</a></p><p>高级前端开发者必会的34道Vue面试题系列[308]</p><ol start="15"><li>书单<br>推荐一些值得看的书，基本都是我看完或者有翻过几页觉得不错但是还没时间看的书。</li></ol><p>JavaScript<br>JavaScript 高级程序设计（高程就不多说了，第四版有英文版）</p><p>JavaScript 设计模式</p><p>你不知道的 JavaScript</p><p>JavaScript 语言精粹</p><p>高性能 JavaScript<br>Learning TypeScript 中文版<br>深入理解 ES6<br>ES6 标准入门<br>深入理解 JavaScript 特性<br>CSS<br>CSS 权威指南（建议看英文版）<br>精通 CSS 高级 Web 标准解决方案<br>CSS 世界（张鑫旭老师的大作，但是建议需要有一定 CSS 实践后再看）<br>Node<br>Node.js 实战<br>了不起的 Node.js<br>计算机基础<br>大话数据结构<br>图解 HTTP<br>计算机/程序是怎样跑起来的<br>学习 JavaScript 数据结构与算法<br>工程化/浏览器/软技能<br>前端工程化体系设计与实践<br>webpack 实战：入门、进阶与优化（了解一下 webpack 的所有会涉及到的知识点）<br>WebKit 技术内幕（讲浏览器的，挺好的）<br>重构：改善既有代码的涉及<br>码农翻- 程序员思维修炼<br>编码：隐匿在计算机软硬件背后的语言<br>写给大家看的设计书<br>技术之瞳：阿里巴巴技术笔试心得<br>16. 结束语<br>上文整理了网上的一些相关文章和躺在我收藏夹里精选文章，有一些文章还没看，还需要持续学习呀~</p><p>参考链接<br>[1]<br>理解 JavaScript 中的执行上下文和执行栈: <a href="https://juejin.im/post/5ba32171f265da0ab719a6d7">https://juejin.im/post/5ba32171f265da0ab719a6d7</a></p><p>[2]<br>JavaScript深入之执行上下文栈: <a href="https://github.com/mqyqingfeng/Blog/issues/4">https://github.com/mqyqingfeng/Blog/issues/4</a></p><p>[3]<br>一道js面试题引发的思考: <a href="https://github.com/kuitos/kuitos.github.io/issues/18">https://github.com/kuitos/kuitos.github.io/issues/18</a></p><p>[4]<br>JavaScript深入之词法作用域和动态作用域: <a href="https://github.com/mqyqingfeng/Blog/issues/3">https://github.com/mqyqingfeng/Blog/issues/3</a></p><p>[5]<br>JavaScript深入之作用域链: <a href="https://github.com/mqyqingfeng/Blog/issues/6">https://github.com/mqyqingfeng/Blog/issues/6</a></p><p>[6]<br>发现 JavaScript 中闭包的强大威力: <a href="https://juejin.im/post/5c4e6a90e51d4552266576d2">https://juejin.im/post/5c4e6a90e51d4552266576d2</a></p><p>[7]<br>JavaScript闭包的底层运行机制: <a href="http://blog.leapoahead.com/2015/09/15/js-closure/">http://blog.leapoahead.com/2015/09/15/js-closure/</a></p><p>[8]<br>我从来不理解JavaScript闭包，直到有人这样向我解释它…: <a href="https://zhuanlan.zhihu.com/p/56490498">https://zhuanlan.zhihu.com/p/56490498</a></p><p>[9]<br>破解前端面试（80% 应聘者不及格系列）：从闭包说起: <a href="https://juejin.im/post/58f1fa6a44d904006cf25d22#heading-0">https://juejin.im/post/58f1fa6a44d904006cf25d22#heading-0</a></p><p>[10]<br>JavaScript基础心法——this: <a href="https://github.com/axuebin/articles/issues/6">https://github.com/axuebin/articles/issues/6</a></p><p>[11]<br>JavaScript深入之从ECMAScript规范解读this: <a href="https://github.com/mqyqingfeng/Blog/issues/7">https://github.com/mqyqingfeng/Blog/issues/7</a></p><p>[12]<br>前端基础进阶（七）：全方位解读this: <a href="https://www.jianshu.com/p/d647aa6d1ae6">https://www.jianshu.com/p/d647aa6d1ae6</a></p><p>[13]<br>面试官问：JS的this指向: <a href="https://juejin.im/post/5c0c87b35188252e8966c78a">https://juejin.im/post/5c0c87b35188252e8966c78a</a></p><p>[14]<br>JavaScript深入之call和apply的模拟实现: <a href="https://juejin.im/post/5907eb99570c3500582ca23c">https://juejin.im/post/5907eb99570c3500582ca23c</a></p><p>[15]<br>JavaScript基础心法—— call apply bind: <a href="https://github.com/axuebin/articles/issues/7">https://github.com/axuebin/articles/issues/7</a></p><p>[16]<br>面试官问：能否模拟实现JS的call和apply方法: <a href="https://juejin.im/post/5bf6c79bf265da6142738b29">https://juejin.im/post/5bf6c79bf265da6142738b29</a></p><p>[17]<br>回味JS基础:call apply 与 bind: <a href="https://juejin.im/post/57dc97f35bbb50005e5b39bd">https://juejin.im/post/57dc97f35bbb50005e5b39bd</a></p><p>[18]<br>面试官问：能否模拟实现JS的bind方法: <a href="https://juejin.im/post/5bec4183f265da616b1044d7">https://juejin.im/post/5bec4183f265da616b1044d7</a></p><p>[19]<br>不用call和apply方法模拟实现ES5的bind方法: <a href="https://github.com/jawil/blog/issues/16">https://github.com/jawil/blog/issues/16</a></p><p>[20]<br>【THE LAST TIME】一文吃透所有JS原型相关知识点: <a href="https://juejin.im/post/5dba456d518825721048bce9">https://juejin.im/post/5dba456d518825721048bce9</a></p><p>[21]<br>重新认识构造函数、原型和原型链: <a href="https://juejin.im/post/5c6a9c10f265da2db87b98f3">https://juejin.im/post/5c6a9c10f265da2db87b98f3</a></p><p>[22]<br>JavaScript深入之从原型到原型链: <a href="https://github.com/mqyqingfeng/blog/issues/2">https://github.com/mqyqingfeng/blog/issues/2</a></p><p>[23]<br>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）: <a href="https://www.jianshu.com/p/dee9f8b14771">https://www.jianshu.com/p/dee9f8b14771</a></p><p>[24]<br>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）: <a href="https://www.jianshu.com/p/652991a67186">https://www.jianshu.com/p/652991a67186</a></p><p>[25]<br>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）: <a href="https://www.jianshu.com/p/a4e1e7b6f4f8">https://www.jianshu.com/p/a4e1e7b6f4f8</a></p><p>[26]<br>JavaScript 引擎基础：原型优化: <a href="https://hijiangtao.github.io/2018/08/21/Prototypes/">https://hijiangtao.github.io/2018/08/21/Prototypes/</a></p><p>[27]<br>Prototypes in JavaScript: <a href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b">https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b</a></p><p>[28]<br>JavaScript深入之创建对象的多种方式以及优缺点: <a href="https://github.com/mqyqingfeng/Blog/issues/15">https://github.com/mqyqingfeng/Blog/issues/15</a></p><p>[29]<br>详解JS原型链与继承: <a href="http://louiszhai.github.io/2015/12/15/prototypeChain/">http://louiszhai.github.io/2015/12/15/prototypeChain/</a></p><p>[30]<br>从__proto__和prototype来深入理解JS对象和原型链: <a href="https://github.com/creeperyang/blog/issues/9">https://github.com/creeperyang/blog/issues/9</a></p><p>[31]<br>代码复用模式: <a href="https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown">https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown</a></p><p>[32]<br>JavaScript 中的继承：ES3、ES5 和 ES6: <a href="http://tianfangye.com/2017/12/31/inheritance-in-javascript-es3-es5-and-es6/">http://tianfangye.com/2017/12/31/inheritance-in-javascript-es3-es5-and-es6/</a></p><p>[33]<br>你好，JavaScript异步编程—- 理解JavaScript异步的美妙: <a href="https://juejin.im/post/5b56c3586fb9a04faa79a8e0">https://juejin.im/post/5b56c3586fb9a04faa79a8e0</a></p><p>[34]<br>Promise不会？？看这里！！！史上最通俗易懂的Promise！！！: <a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b">https://juejin.im/post/5afe6d3bf265da0b9e654c4b</a></p><p>[35]<br>一起学习造轮子（一）：从零开始写一个符合Promises/A+规范的promise: <a href="https://juejin.im/post/5b16800fe51d4506ae719bae#heading-34">https://juejin.im/post/5b16800fe51d4506ae719bae#heading-34</a></p><p>[36]<br>Promise实现原理（附源码）: <a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354">https://juejin.im/post/5b83cb5ae51d4538cc3ec354</a></p><p>[37]<br>当 async/await 遇上 forEach: <a href="https://objcer.com/2017/10/12/async-await-with-forEach/">https://objcer.com/2017/10/12/async-await-with-forEach/</a></p><p>[38]<br>Promise 必知必会（十道题）: <a href="https://juejin.im/post/5a04066351882517c416715d">https://juejin.im/post/5a04066351882517c416715d</a></p><p>[39]<br>BAT前端经典面试问题：史上最最最详细的手写Promise教程: <a href="https://juejin.im/post/5b2f02cd5188252b937548ab#heading-9">https://juejin.im/post/5b2f02cd5188252b937548ab#heading-9</a></p><p>[40]<br>JavaScript基础心法——深浅拷贝: <a href="https://github.com/axuebin/articles/issues/20">https://github.com/axuebin/articles/issues/20</a></p><p>[41]<br>深拷贝的终极探索（90%的人都不知道）: <a href="https://juejin.im/post/5bc1ae9be51d450e8b140b0c">https://juejin.im/post/5bc1ae9be51d450e8b140b0c</a></p><p>[42]<br>JavaScript专题之深浅拷贝: <a href="https://github.com/mqyqingfeng/Blog/issues/32">https://github.com/mqyqingfeng/Blog/issues/32</a></p><p>[43]<br>javaScript中浅拷贝和深拷贝的实现: <a href="https://github.com/wengjq/Blog/issues/3">https://github.com/wengjq/Blog/issues/3</a></p><p>[44]<br>深入剖析 JavaScript 的深复制: <a href="https://jerryzou.com/posts/dive-into-deep-clone-in-javascript/">https://jerryzou.com/posts/dive-into-deep-clone-in-javascript/</a></p><p>[45]<br>「JavaScript」带你彻底搞清楚深拷贝、浅拷贝和循环引用: <a href="https://segmentfault.com/a/1190000015042902">https://segmentfault.com/a/1190000015042902</a></p><p>[46]<br>面试题之如何实现一个深拷贝: <a href="https://github.com/yygmind/blog/issues/29">https://github.com/yygmind/blog/issues/29</a></p><p>[47]<br>Tasks, microtasks, queues and schedules: <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p><p>[48]<br>How JavaScript works: <a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a></p><p>[49]<br>从event loop规范探究javaScript异步及浏览器更新渲染时机: <a href="https://github.com/aooy/blog/issues/5">https://github.com/aooy/blog/issues/5</a></p><p>[50]<br>这一次，彻底弄懂 JavaScript 执行机制: <a href="https://juejin.im/post/59e85eebf265da430d571f89">https://juejin.im/post/59e85eebf265da430d571f89</a></p><p>[51]<br>【THE LAST TIME】彻底吃透 JavaScript 执行机制: <a href="https://juejin.im/post/5d901418518825539312f587">https://juejin.im/post/5d901418518825539312f587</a></p><p>[52]<br>一次弄懂Event Loop（彻底解决此类面试问题）: <a href="https://juejin.im/post/5c3d8956e51d4511dc72c200">https://juejin.im/post/5c3d8956e51d4511dc72c200</a></p><p>[53]<br>浏览器与Node的事件循环(Event Loop)有何区别?: <a href="https://zhuanlan.zhihu.com/p/54882306">https://zhuanlan.zhihu.com/p/54882306</a></p><p>[54]<br>深入理解 JavaScript Event Loop: <a href="https://zhuanlan.zhihu.com/p/34229323">https://zhuanlan.zhihu.com/p/34229323</a></p><p>[55]<br>The Node.js Event Loop, Timers, and process.nextTick(): <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></p><p>[56]<br>函数式编程指北: <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/</a></p><p>[57]<br>JavaScript专题之函数柯里化: <a href="https://github.com/mqyqingfeng/Blog/issues/42">https://github.com/mqyqingfeng/Blog/issues/42</a></p><p>[58]<br>Understanding Functional Programming in Javascript: <a href="https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8">https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8</a></p><p>[59]<br>What is Functional Programming?: <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0</a></p><p>[60]<br>简明 JavaScript 函数式编程——入门篇: <a href="https://juejin.im/post/5d70e25de51d453c11684cc4">https://juejin.im/post/5d70e25de51d453c11684cc4</a></p><p>[61]<br>You Should Learn Functional Programming: <a href="https://dev.to/allanmacgregor/you-should-learn-functional-programming-in-2018-4nff">https://dev.to/allanmacgregor/you-should-learn-functional-programming-in-2018-4nff</a></p><p>[62]<br>JavaScript 函数式编程到底是个啥: <a href="https://segmentfault.com/a/1190000009864459">https://segmentfault.com/a/1190000009864459</a></p><p>[63]<br>JavaScript-函数式编程: <a href="https://github.com/ecmadao/Coding-Guide/blob/master/Notes/JavaScript/JavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">https://github.com/ecmadao/Coding-Guide/blob/master/Notes/JavaScript/JavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md</a></p><p>[64]<br>Service Worker：简介: <a href="https://developers.google.com/web/fundamentals/primers/service-workers">https://developers.google.com/web/fundamentals/primers/service-workers</a></p><p>[65]<br>JavaScript 是如何工作的：Service Worker 的生命周期及使用场景: <a href="https://github.com/qq449245884/xiaozhi/issues/8">https://github.com/qq449245884/xiaozhi/issues/8</a></p><p>[66]<br>借助Service Worker和cacheStorage缓存及离线开发: <a href="https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/">https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/</a></p><p>[67]<br>PWA Lavas 文档: <a href="https://lavas.baidu.com/pwa/README">https://lavas.baidu.com/pwa/README</a></p><p>[68]<br>PWA 学习手册: <a href="https://pwa.alienzhou.com/">https://pwa.alienzhou.com/</a></p><p>[69]<br>面试官：请你实现一个PWA: <a href="https://juejin.im/post/5e26aa785188254c257c462d#heading-24">https://juejin.im/post/5e26aa785188254c257c462d#heading-24</a></p><p>[70]<br>浅谈HTML5 Web Worker: <a href="https://juejin.im/post/59c1b3645188250ea1502e46">https://juejin.im/post/59c1b3645188250ea1502e46</a></p><p>[71]<br>JavaScript 中的多线程 – Web Worker: <a href="https://zhuanlan.zhihu.com/p/25184390">https://zhuanlan.zhihu.com/p/25184390</a></p><p>[72]<br>JavaScript 性能利器 —— Web Worker: <a href="https://juejin.im/post/5c10e5a9f265da611c26d634">https://juejin.im/post/5c10e5a9f265da611c26d634</a></p><p>[73]<br>A Simple Introduction to Web Workers in JavaScript: <a href="https://medium.com/young-coder/a-simple-introduction-to-web-workers-in-javascript-b3504f9d9d1c">https://medium.com/young-coder/a-simple-introduction-to-web-workers-in-javascript-b3504f9d9d1c</a></p><p>[74]<br>Speedy Introduction to Web Workers: <a href="https://auth0.com/blog/speedy-introduction-to-web-workers/">https://auth0.com/blog/speedy-introduction-to-web-workers/</a></p><p>[75]<br>近一万字的ES6语法知识点补充: <a href="https://juejin.im/post/5c6234f16fb9a049a81fcca5">https://juejin.im/post/5c6234f16fb9a049a81fcca5</a></p><p>[76]<br>ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南): <a href="https://juejin.im/post/5b9cb3336fb9a05d290ee47e">https://juejin.im/post/5b9cb3336fb9a05d290ee47e</a></p><p>[77]<br>解锁多种JavaScript数组去重姿势: <a href="https://juejin.im/post/5b0284ac51882542ad774c45">https://juejin.im/post/5b0284ac51882542ad774c45</a></p><p>[78]<br>Here’s how you can make better use of JavaScript arrays: <a href="https://www.freecodecamp.org/news/heres-how-you-can-make-better-use-of-javascript-arrays-3efd6395af3c/">https://www.freecodecamp.org/news/heres-how-you-can-make-better-use-of-javascript-arrays-3efd6395af3c/</a></p><p>[79]<br>一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧: <a href="https://juejin.im/post/5cef46226fb9a07eaf2b7516">https://juejin.im/post/5cef46226fb9a07eaf2b7516</a></p><p>[80]<br>1.5万字概括ES6全部特性(已更新ES2020): <a href="https://juejin.im/post/5d9bf530518825427b27639d">https://juejin.im/post/5d9bf530518825427b27639d</a></p><p>[81]<br>position - CSS: Cascading Style Sheets | MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">https://developer.mozilla.org/en-US/docs/Web/CSS/position</a></p><p>[82]<br>position | CSS Tricks: <a href="https://css-tricks.com/almanac/properties/p/position/">https://css-tricks.com/almanac/properties/p/position/</a></p><p>[83]<br>杀了个回马枪，还是说说position:sticky吧: <a href="https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/">https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/</a></p><p>[84]<br>30 分钟学会 Flex 布局: <a href="https://zhuanlan.zhihu.com/p/25303493">https://zhuanlan.zhihu.com/p/25303493</a></p><p>[85]<br>css行高line-height的一些深入理解及应用: <a href="https://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/">https://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/</a></p><p>[86]<br>A Complete Guide to Flexbox: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p><p>[87]<br>写给自己看的display: flex布局教程: <a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/">https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/</a></p><p>[88]<br>从网易与淘宝的font-size思考前端设计稿与工作流: <a href="https://www.cnblogs.com/lyzg/p/4877277.html">https://www.cnblogs.com/lyzg/p/4877277.html</a></p><p>[89]<br>细说移动端 经典的REM布局 与 新秀VW布局: <a href="https://cloud.tencent.com/developer/article/1352187">https://cloud.tencent.com/developer/article/1352187</a></p><p>[90]<br>移动端1px解决方案: <a href="https://juejin.im/post/5d19b729f265da1bb2774865">https://juejin.im/post/5d19b729f265da1bb2774865</a></p><p>[91]<br>Retina屏的移动设备如何实现真正1px的线？: <a href="https://jinlong.github.io/2015/05/24/css-retina-hairlines/">https://jinlong.github.io/2015/05/24/css-retina-hairlines/</a></p><p>[92]<br>CSS retina hairline, the easy way.: <a href="http://dieulot.net/css-retina-hairline">http://dieulot.net/css-retina-hairline</a></p><p>[93]<br>浏览器的回流与重绘 (Reflow &amp; Repaint): <a href="https://juejin.im/post/5a9923e9518825558251c96a">https://juejin.im/post/5a9923e9518825558251c96a</a></p><p>[94]<br>回流与重绘：CSS性能让JavaScript变慢？: <a href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/">https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/</a></p><p>[95]<br>CSS实现水平垂直居中的1010种方式（史上最全）: <a href="https://juejin.im/post/5b9a4477f265da0ad82bf921">https://juejin.im/post/5b9a4477f265da0ad82bf921</a></p><p>[96]<br>干货!各种常见布局实现: <a href="https://juejin.im/post/5aa252ac518825558001d5de">https://juejin.im/post/5aa252ac518825558001d5de</a></p><p>[97]<br>CSS 常见布局方式: <a href="https://juejin.im/post/599970f4518825243a78b9d5">https://juejin.im/post/599970f4518825243a78b9d5</a></p><p>[98]<br>彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index: <a href="https://juejin.im/post/5b876f86518825431079ddd6">https://juejin.im/post/5b876f86518825431079ddd6</a></p><p>[99]<br>深入理解CSS中的层叠上下文和层叠顺序: <a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/</a></p><p>[100]<br>Sass vs. Less: <a href="https://css-tricks.com/sass-vs-less/">https://css-tricks.com/sass-vs-less/</a></p><p>[101]<br>2019年，你是否可以抛弃 CSS 预处理器？: <a href="https://aotu.io/notes/2019/10/29/css-preprocessor/index.html">https://aotu.io/notes/2019/10/29/css-preprocessor/index.html</a></p><p>[102]<br>浅谈 CSS 预处理器（一）：为什么要使用预处理器？: <a href="https://github.com/cssmagic/blog/issues/73">https://github.com/cssmagic/blog/issues/73</a></p><p>[103]<br>浏览器将rem转成px时有精度误差怎么办？: <a href="https://www.zhihu.com/question/264372456">https://www.zhihu.com/question/264372456</a></p><p>[104]<br>Fighting the Space Between Inline Block Elements: <a href="https://css-tricks.com/fighting-the-space-between-inline-block-elements/">https://css-tricks.com/fighting-the-space-between-inline-block-elements/</a></p><p>[105]<br>50行代码的MVVM，感受闭包的艺术: <a href="https://juejin.im/post/5b1fa77451882513ea5cc2ca">https://juejin.im/post/5b1fa77451882513ea5cc2ca</a></p><p>[106]<br>不好意思！耽误你的十分钟，让MVVM原理还给你: <a href="https://juejin.im/post/5abdd6f6f265da23793c4458">https://juejin.im/post/5abdd6f6f265da23793c4458</a></p><p>[107]<br>基于Vue实现一个简易MVVM: <a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992">https://juejin.im/post/5cd8a7c1f265da037a3d0992</a></p><p>[108]<br>剖析Vue实现原理 - 如何实现双向绑定mvvm: <a href="https://github.com/DMQ/mvvm">https://github.com/DMQ/mvvm</a></p><p>[109]<br>Vue 生命周期源码剖析: <a href="https://ustbhuangyi.github.io/vue-analysis/v2/components/lifecycle.html">https://ustbhuangyi.github.io/vue-analysis/v2/components/lifecycle.html</a></p><p>[110]<br>你真的理解 $nextTick么: <a href="https://juejin.im/post/5cd9854b5188252035420a13">https://juejin.im/post/5cd9854b5188252035420a13</a></p><p>[111]<br>React 源码剖析系列 － 生命周期的管理艺术: <a href="https://zhuanlan.zhihu.com/p/20312691">https://zhuanlan.zhihu.com/p/20312691</a></p><p>[112]<br>Vue 深入响应式原理: <a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/">https://ustbhuangyi.github.io/vue-analysis/v2/reactive/</a></p><p>[113]<br>面试官: 实现双向绑定Proxy比defineproperty优劣如何?: <a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf">https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf</a></p><p>[114]<br>Vuex、Flux、Redux、Redux-saga、Dva、MobX: <a href="https://zhuanlan.zhihu.com/p/53599723">https://zhuanlan.zhihu.com/p/53599723</a></p><p>[115]<br>10行代码看尽redux实现: <a href="https://juejin.im/post/5def4831e51d45584b585000">https://juejin.im/post/5def4831e51d45584b585000</a></p><p>[116]<br>Mobx 思想的实现原理，及与 Redux 对比: <a href="https://zhuanlan.zhihu.com/p/25585910">https://zhuanlan.zhihu.com/p/25585910</a></p><p>[117]<br>使用原生 JavaScript 构建状态管理系统: <a href="https://juejin.im/post/5b763528e51d45559e3a5b64">https://juejin.im/post/5b763528e51d45559e3a5b64</a></p><p>[118]<br>vue中8种组件通信方式, 值得收藏!: <a href="https://juejin.im/post/5d267dcdf265da1b957081a3">https://juejin.im/post/5d267dcdf265da1b957081a3</a></p><p>[119]<br>Vue 组件间通信六种方式（完整版）: <a href="https://juejin.im/post/5cde0b43f265da03867e78d3">https://juejin.im/post/5cde0b43f265da03867e78d3</a></p><p>[120]<br>Vue组件间通信: <a href="https://github.com/answershuto/learnVue/blob/master/docs/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.MarkDown">https://github.com/answershuto/learnVue/blob/master/docs/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.MarkDown</a></p><p>[121]<br>Vue Virtual DOM 源码剖析: <a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/virtual-dom.html">https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/virtual-dom.html</a></p><p>[122]<br>面试官: 你对虚拟DOM原理的理解?: <a href="https://juejin.im/post/5d3f3bf36fb9a06af824b3e2">https://juejin.im/post/5d3f3bf36fb9a06af824b3e2</a></p><p>[123]<br>让虚拟DOM和DOM-diff不再成为你的绊脚石: <a href="https://juejin.im/post/5c8e5e4951882545c109ae9c">https://juejin.im/post/5c8e5e4951882545c109ae9c</a></p><p>[124]<br>探索Virtual DOM的前世今生: <a href="https://zhuanlan.zhihu.com/p/35876032">https://zhuanlan.zhihu.com/p/35876032</a></p><p>[125]<br>详解vue的diff算法: <a href="https://juejin.im/post/5affd01551882542c83301da">https://juejin.im/post/5affd01551882542c83301da</a></p><p>[126]<br>Deep In React 之详谈 React 16 Diff 策略(二): <a href="https://juejin.im/post/5d3e3231e51d4510926a7c39">https://juejin.im/post/5d3e3231e51d4510926a7c39</a></p><p>[127]<br>React 源码剖析系列 － 不可思议的 react diff: <a href="https://zhuanlan.zhihu.com/p/20346379">https://zhuanlan.zhihu.com/p/20346379</a></p><p>[128]<br>浅入浅出图解 Dom Diff: <a href="https://juejin.im/post/5ad550f06fb9a028b4118d99">https://juejin.im/post/5ad550f06fb9a028b4118d99</a></p><p>[129]<br>Vue 计算属性 VS 侦听属性源码剖析: <a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html">https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html</a></p><p>[130]<br>Vue.js的computed和watch是如何工作的？: <a href="https://juejin.im/post/5b87f13bf265da436479f3c1">https://juejin.im/post/5b87f13bf265da436479f3c1</a></p><p>[131]<br>React Hooks 原理: <a href="https://github.com/brickspert/blog/issues/26">https://github.com/brickspert/blog/issues/26</a></p><p>[132]<br>React hooks: not magic, just arrays: <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e</a></p><p>[133]<br>Deep dive: How do React hooks really work?: <a href="https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/">https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/</a></p><p>[134]<br>【React深入】从Mixin到HOC再到Hook: <a href="https://juejin.im/post/5cad39b3f265da03502b1c0a">https://juejin.im/post/5cad39b3f265da03502b1c0a</a></p><p>[135]<br>React Hooks 详解 【近 1W 字】+ 项目实战: <a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d">https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d</a></p><p>[136]<br>30分钟精通React今年最劲爆的新特性——React Hooks: <a href="https://segmentfault.com/a/1190000016950339">https://segmentfault.com/a/1190000016950339</a></p><p>[137]<br>React Hooks 详解（一）: <a href="http://huayifeng.top:2368/react-hooks/">http://huayifeng.top:2368/react-hooks/</a></p><p>[138]<br>探索Vue高阶组件: <a href="http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/">http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</a></p><p>[139]<br>React 高阶组件(HOC)入门指南: <a href="https://juejin.im/post/5914fb4a0ce4630069d1f3f6">https://juejin.im/post/5914fb4a0ce4630069d1f3f6</a></p><p>[140]<br>深入理解 React 高阶组件: <a href="https://zhuanlan.zhihu.com/p/24776678">https://zhuanlan.zhihu.com/p/24776678</a></p><p>[141]<br>前端工程师都得掌握的 webpack Loader: <a href="https://github.com/axuebin/articles/issues/38">https://github.com/axuebin/articles/issues/38</a></p><p>[142]<br>手把手教你撸一个简易的 webpack: <a href="https://juejin.im/post/5b192afde51d45069c2efe5a">https://juejin.im/post/5b192afde51d45069c2efe5a</a></p><p>[143]<br>带你走进webpack世界，成为webpack头号玩家。: <a href="https://juejin.im/post/5ac9dc9af265da23884d5543">https://juejin.im/post/5ac9dc9af265da23884d5543</a></p><p>[144]<br>手把手教你撸一个 Webpack Loader: <a href="https://juejin.im/post/5a698a316fb9a01c9f5b9ca0">https://juejin.im/post/5a698a316fb9a01c9f5b9ca0</a></p><p>[145]<br>webpack 如何通过作用域分析消除无用代码: <a href="https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis">https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis</a></p><p>[146]<br>【webpack进阶】你真的掌握了loader么？- loader十问: <a href="https://juejin.im/post/5bc1a73df265da0a8d36b74f">https://juejin.im/post/5bc1a73df265da0a8d36b74f</a></p><p>[147]<br>Webpack小书: <a href="https://www.timsrc.com/article/2/webpack-book">https://www.timsrc.com/article/2/webpack-book</a></p><p>[148]<br>聊一聊webpack-dev-server和其中socket，HMR的实现: <a href="https://github.com/879479119/879479119.github.io/issues/5">https://github.com/879479119/879479119.github.io/issues/5</a></p><p>[149]<br>使用webpack4提升180%编译速度: <a href="http://louiszhai.github.io/2019/01/04/webpack4">http://louiszhai.github.io/2019/01/04/webpack4</a></p><p>[150]<br>Webpack 大法之 Code Splitting: <a href="https://zhuanlan.zhihu.com/p/26710831">https://zhuanlan.zhihu.com/p/26710831</a></p><p>[151]<br>轻松理解webpack热更新原理: <a href="https://juejin.im/post/5de0cfe46fb9a071665d3df0">https://juejin.im/post/5de0cfe46fb9a071665d3df0</a></p><p>[152]<br>揭秘webpack plugin: <a href="https://champyin.com/2020/01/12/%E6%8F%AD%E7%A7%98webpack-plugin/">https://champyin.com/2020/01/12/%E6%8F%AD%E7%A7%98webpack-plugin/</a></p><p>[153]<br>不容错过的 Babel7 知识: <a href="https://juejin.im/post/5ddff3abe51d4502d56bd143">https://juejin.im/post/5ddff3abe51d4502d56bd143</a></p><p>[154]<br>前端工程师需要了解的 Babel 知识: <a href="https://www.zoo.team/article/babel">https://www.zoo.team/article/babel</a></p><p>[155]<br>深入浅出 Babel 上篇：架构和原理 + 实战: <a href="https://juejin.im/post/5d94bfbf5188256db95589be">https://juejin.im/post/5d94bfbf5188256db95589be</a></p><p>[156]<br>深入浅出 Babel 下篇：既生 Plugin 何生 Macros: <a href="https://juejin.im/post/5da12397e51d4578364f6ffa">https://juejin.im/post/5da12397e51d4578364f6ffa</a></p><p>[157]<br>前端工程师的自我修养-关于 Babel 那些事儿: <a href="https://juejin.im/post/5e5b488af265da574112089f">https://juejin.im/post/5e5b488af265da574112089f</a></p><p>[158]<br>前端与编译原理——用JS写一个JS解释器: <a href="https://segmentfault.com/a/1190000017241258">https://segmentfault.com/a/1190000017241258</a></p><p>[159]<br>编写一个简单的JavaScript模板引擎: <a href="https://www.liaoxuefeng.com/article/1006272230979008">https://www.liaoxuefeng.com/article/1006272230979008</a></p><p>[160]<br>JavaScript模板引擎原理，几行代码的事儿: <a href="https://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html">https://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html</a></p><p>[161]<br>Vue 模板编译原理: <a href="https://github.com/berwin/Blog/issues/18">https://github.com/berwin/Blog/issues/18</a></p><p>[162]<br>JavaScript template engine in just 20 lines: <a href="https://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line">https://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line</a></p><p>[163]<br>Understanding JavaScript Micro-Templating: <a href="https://medium.com/wdstack/understanding-javascript-micro-templating-f37a37b3b40e">https://medium.com/wdstack/understanding-javascript-micro-templating-f37a37b3b40e</a></p><p>[164]<br>大公司里怎样开发和部署前端代码？: <a href="https://www.zhihu.com/question/20790576">https://www.zhihu.com/question/20790576</a></p><p>[165]<br>前端高级进阶：前端部署的发展历程: <a href="https://juejin.im/post/5e6836cc51882549052f56f5">https://juejin.im/post/5e6836cc51882549052f56f5</a></p><p>[166]<br>深入了解 Weex: <a href="https://juejin.im/post/5b18a03ce51d45069d2263e3">https://juejin.im/post/5b18a03ce51d45069d2263e3</a></p><p>[167]<br>Weex原理概述: <a href="https://github.com/weexteam/article/issues/32">https://github.com/weexteam/article/issues/32</a></p><p>[168]<br>Weex 是如何在 iOS 客户端上跑起来的: <a href="https://halfrost.com/weex_ios/">https://halfrost.com/weex_ios/</a></p><p>[169]<br>详解 Weex 页面的渲染过程: <a href="https://segmentfault.com/a/1190000010415641">https://segmentfault.com/a/1190000010415641</a></p><p>[170]<br>JSBridge 介绍及实现原理: <a href="http://coolnuanfeng.github.io/jsbridge">http://coolnuanfeng.github.io/jsbridge</a></p><p>[171]<br>5 分钟撸一个前端性能监控工具: <a href="https://juejin.im/post/5b7a50c0e51d4538af60d995">https://juejin.im/post/5b7a50c0e51d4538af60d995</a></p><p>[172]<br>把前端监控做到极致: <a href="https://zhuanlan.zhihu.com/p/32262716">https://zhuanlan.zhihu.com/p/32262716</a></p><p>[173]<br>GMTC 大前端时代前端监控的最佳实践: <a href="https://juejin.im/post/5b35921af265da598f1563cf">https://juejin.im/post/5b35921af265da598f1563cf</a></p><p>[174]<br>前端监控和前端埋点方案设计: <a href="https://juejin.im/post/5b62d68df265da0f9d1a1cd6">https://juejin.im/post/5b62d68df265da0f9d1a1cd6</a></p><p>[175]<br>Webpack优化——将你的构建效率提速翻倍: <a href="https://juejin.im/post/5d614dc96fb9a06ae3726b3e">https://juejin.im/post/5d614dc96fb9a06ae3726b3e</a></p><p>[176]<br>性能优化篇—Webpack构建速度优化: <a href="https://segmentfault.com/a/1190000018493260">https://segmentfault.com/a/1190000018493260</a></p><p>[177]<br>webpack构建速度与结果优化: <a href="https://huangxsu.com/2018/08/12/webpack-optimization/">https://huangxsu.com/2018/08/12/webpack-optimization/</a></p><p>[178]<br>让你的Webpack起飞—考拉会员后台Webpack优化实战: <a href="https://zhuanlan.zhihu.com/p/42465502">https://zhuanlan.zhihu.com/p/42465502</a></p><p>[179]<br>webpack dllPlugin打包体积和速度优化: <a href="https://zhuanlan.zhihu.com/p/39727247">https://zhuanlan.zhihu.com/p/39727247</a></p><p>[180]<br>使用webpack4提升180%编译速度: <a href="http://louiszhai.github.io/2019/01/04/webpack4/">http://louiszhai.github.io/2019/01/04/webpack4/</a></p><p>[181]<br>Webpack 打包优化之速度篇: <a href="https://www.jeffjade.com/2017/08/12/125-webpack-package-optimization-for-speed/">https://www.jeffjade.com/2017/08/12/125-webpack-package-optimization-for-speed/</a></p><p>[182]<br>多进程并行压缩代码: <a href="https://jkfhto.github.io/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81/">https://jkfhto.github.io/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81/</a></p><p>[183]<br>Tree-Shaking性能优化实践 - 原理篇: <a href="https://juejin.im/post/5a4dc842518825698e7279a9">https://juejin.im/post/5a4dc842518825698e7279a9</a></p><p>[184]<br>体积减少80%！释放webpack tree-shaking的真正潜力: <a href="https://juejin.im/post/5b8ce49df265da438151b468">https://juejin.im/post/5b8ce49df265da438151b468</a></p><p>[185]<br>你的Tree-Shaking并没什么卵用: <a href="https://zhuanlan.zhihu.com/p/32831172">https://zhuanlan.zhihu.com/p/32831172</a></p><p>[186]<br>webpack 如何通过作用域分析消除无用代码: <a href="https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis">https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis</a></p><p>[187]<br>加速Webpack-缩小文件搜索范围: <a href="https://imweb.io/topic/5a40551ea192c3b460fce335">https://imweb.io/topic/5a40551ea192c3b460fce335</a></p><p>[188]<br>Brief introduction to scope hoisting in Webpack: <a href="https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f">https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f</a></p><p>[189]<br>通过Scope Hoisting优化Webpack输出: <a href="https://imweb.io/topic/5a43064fa192c3b460fce360">https://imweb.io/topic/5a43064fa192c3b460fce360</a></p><p>[190]<br>webpack 的 scope hoisting 是什么？: <a href="https://ssshooter.com/2019-02-20-webpack-scope-hoisting/">https://ssshooter.com/2019-02-20-webpack-scope-hoisting/</a></p><p>[191]<br>webpack优化之code splitting: <a href="https://segmentfault.com/a/1190000013000463">https://segmentfault.com/a/1190000013000463</a></p><p>[192]<br>webpack 4: Code Splitting和chunks切分优化: <a href="https://juejin.im/post/5d53f49bf265da03dc0766e2">https://juejin.im/post/5d53f49bf265da03dc0766e2</a></p><p>[193]<br>Webpack 大法之 Code Splitting: <a href="https://zhuanlan.zhihu.com/p/26710831">https://zhuanlan.zhihu.com/p/26710831</a></p><p>[194]<br>Better tree shaking with deep scope analysis: <a href="https://medium.com/webpack/better-tree-shaking-with-deep-scope-analysis-a0b788c0ce77">https://medium.com/webpack/better-tree-shaking-with-deep-scope-analysis-a0b788c0ce77</a></p><p>[195]<br>Front-End Performance Checklist 2020: <a href="https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages/#top">https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages/#top</a></p><p>[196]<br>（译）2019年前端性能优化清单 — 上篇: <a href="https://juejin.im/post/5c46cbaee51d453f45612a2c">https://juejin.im/post/5c46cbaee51d453f45612a2c</a></p><p>[197]<br>网站性能优化实战——从12.67s到1.06s的故事: <a href="https://juejin.im/post/5b6fa8c86fb9a0099910ac91">https://juejin.im/post/5b6fa8c86fb9a0099910ac91</a></p><p>[198]<br>浏览器页面资源加载过程与优化: <a href="https://juejin.im/post/5a4ed917f265da3e317df515">https://juejin.im/post/5a4ed917f265da3e317df515</a></p><p>[199]<br>聊聊前端开发中的长列表: <a href="https://zhuanlan.zhihu.com/p/26022258">https://zhuanlan.zhihu.com/p/26022258</a></p><p>[200]<br>再谈前端虚拟列表的实现: <a href="https://zhuanlan.zhihu.com/p/34585166">https://zhuanlan.zhihu.com/p/34585166</a></p><p>[201]<br>浅说虚拟列表的实现原理: <a href="https://github.com/dwqs/blog/issues/70">https://github.com/dwqs/blog/issues/70</a></p><p>[202]<br>浏览器IMG图片原生懒加载loading=”lazy”实践指南: <a href="https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/">https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/</a></p><p>[203]<br>用 preload 预加载页面资源: <a href="https://juejin.im/post/5a7fb09bf265da4e8e785c38">https://juejin.im/post/5a7fb09bf265da4e8e785c38</a></p><p>[204]<br>Preload, Prefetch And Priorities in Chrome: <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf</a></p><p>[205]<br>Front-End Performance Checklist  : <a href="https://github.com/thedaviddias/Front-End-Performance-Checklist">https://github.com/thedaviddias/Front-End-Performance-Checklist</a></p><p>[206]<br>图片与视频懒加载的详细指南: <a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/">https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/</a></p><p>[207]<br>使用 Intersection Observer 来懒加载图片: <a href="http://deanhume.com/lazy-loading-images-using-intersection-observer/">http://deanhume.com/lazy-loading-images-using-intersection-observer/</a></p><p>[208]<br>为什么要在javascript中进行静态类型检查: <a href="https://www.jianshu.com/p/bda750e2d15e">https://www.jianshu.com/p/bda750e2d15e</a></p><p>[209]<br>TypeScript Start: 基础类型: <a href="https://github.com/axuebin/articles/issues/36">https://github.com/axuebin/articles/issues/36</a></p><p>[210]<br>TypeScript 中高级应用与最佳实践: <a href="http://www.alloyteam.com/2019/07/13796/">http://www.alloyteam.com/2019/07/13796/</a></p><p>[211]<br>可能是你需要的 React + TypeScript 50 条规范和经验: <a href="https://juejin.im/post/5ce24f8ae51d45106477bd45">https://juejin.im/post/5ce24f8ae51d45106477bd45</a></p><p>[212]<br>从 JavaScript 到 TypeScript: <a href="https://juejin.im/post/5958fdd7f265da6c40735085">https://juejin.im/post/5958fdd7f265da6c40735085</a></p><p>[213]<br>TypeScript + 大型项目实战: <a href="https://juejin.im/post/5b54886ce51d45198f5c75d7">https://juejin.im/post/5b54886ce51d45198f5c75d7</a></p><p>[214]<br>TypeScript - 一种思维方式: <a href="https://juejin.im/post/5cd6387d518825682348442d">https://juejin.im/post/5cd6387d518825682348442d</a></p><p>[215]<br>如何编写一个d.ts文件: <a href="https://segmentfault.com/a/1190000009247663">https://segmentfault.com/a/1190000009247663</a></p><p>[216]<br>TypeScript 的声明文件的使用与编写: <a href="https://my.oschina.net/fenying/blog/748805">https://my.oschina.net/fenying/blog/748805</a></p><p>[217]<br>TypeScript 进阶：给第三方库编写声明文件: <a href="http://imzc.me/dev/2016/11/30/write-d-ts-files/">http://imzc.me/dev/2016/11/30/write-d-ts-files/</a></p><p>[218]<br>TypeScript泛型: <a href="https://jkchao.github.io/typescript-book-chinese/typings/generices.html">https://jkchao.github.io/typescript-book-chinese/typings/generices.html</a></p><p>[219]<br>TypeScript 重构 Axios 经验分享: <a href="https://juejin.im/post/5bf7f1c0e51d455ed74f625c">https://juejin.im/post/5bf7f1c0e51d455ed74f625c</a></p><p>[220]<br>手把手教写 TypeScript Transformer Plugin: <a href="https://juejin.im/post/5a0a54425188253edc7f6e79">https://juejin.im/post/5a0a54425188253edc7f6e79</a></p><p>[221]<br>听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？: <a href="https://zhuanlan.zhihu.com/p/25028045">https://zhuanlan.zhihu.com/p/25028045</a></p><p>[222]<br>前端基础篇之HTTP协议: <a href="https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2">https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2</a></p><p>[223]<br>都9102年了，还问GET和POST的区别: <a href="https://segmentfault.com/a/1190000018129846">https://segmentfault.com/a/1190000018129846</a></p><p>[224]<br>HTTP 响应代码 | MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p><p>[225]<br>如何理解HTTP响应的状态码？: <a href="https://harttle.land/2015/08/15/http-status-code.html#header-11">https://harttle.land/2015/08/15/http-status-code.html#header-11</a></p><p>[226]<br>你所知道的3xx状态码: <a href="https://aotu.io/notes/2016/01/28/3xx-of-http-status/index.html">https://aotu.io/notes/2016/01/28/3xx-of-http-status/index.html</a></p><p>[227]<br>浏览器缓存: <a href="https://github.com/xiangxingchen/blog/issues/9">https://github.com/xiangxingchen/blog/issues/9</a></p><p>[228]<br>HTTP协议头部与Keep-Alive模式详解: <a href="https://www.byvoid.com/zhs/blog/http-keep-alive-header">https://www.byvoid.com/zhs/blog/http-keep-alive-header</a></p><p>[229]<br>HTTP keep-alive 二三事: <a href="https://lotabout.me/2019/Things-about-keepalive/">https://lotabout.me/2019/Things-about-keepalive/</a></p><p>[230]<br>深入理解HTTPS工作原理: <a href="https://juejin.im/post/5ca6a109e51d4544e27e3048">https://juejin.im/post/5ca6a109e51d4544e27e3048</a></p><p>[231]<br>九个问题从入门到熟悉HTTPS: <a href="https://juejin.im/post/5a2ff29c6fb9a045132aac5a">https://juejin.im/post/5a2ff29c6fb9a045132aac5a</a></p><p>[232]<br>谈谈 HTTPS: <a href="https://juejin.im/post/59e4c02151882578d02f4aca">https://juejin.im/post/59e4c02151882578d02f4aca</a></p><p>[233]<br>看图学HTTPS: <a href="https://juejin.im/post/5b0274ac6fb9a07aaa118f49">https://juejin.im/post/5b0274ac6fb9a07aaa118f49</a></p><p>[234]<br>分分钟让你理解HTTPS: <a href="https://juejin.im/post/5ad6ad575188255c272273c4">https://juejin.im/post/5ad6ad575188255c272273c4</a></p><p>[235]<br>解密HTTP/2与HTTP/3 的新特性: <a href="https://segmentfault.com/a/1190000020714686#articleHeader16">https://segmentfault.com/a/1190000020714686#articleHeader16</a></p><p>[236]<br>浅谈 HTTP/2 Server Push: <a href="https://zhuanlan.zhihu.com/p/26757514">https://zhuanlan.zhihu.com/p/26757514</a></p><p>[237]<br>HTTP2基本概念学习笔记: <a href="https://juejin.im/post/5acccf966fb9a028d043c6ec">https://juejin.im/post/5acccf966fb9a028d043c6ec</a></p><p>[238]<br>写给前端工程师的DNS基础知识: <a href="http://www.sunhao.win/articles/netwrok-dns.html">http://www.sunhao.win/articles/netwrok-dns.html</a></p><p>[239]<br>前端优化: DNS预解析提升页面速度: <a href="https://www.jianshu.com/p/95a0c0636d28">https://www.jianshu.com/p/95a0c0636d28</a></p><p>[240]<br>DNS解析: <a href="https://imweb.io/topic/55e3ba46771670e207a16bc8">https://imweb.io/topic/55e3ba46771670e207a16bc8</a></p><p>[241]<br>通俗大白话来理解TCP协议的三次握手和四次分手: <a href="https://github.com/jawil/blog/issues/14">https://github.com/jawil/blog/issues/14</a></p><p>[242]<br>就是要你懂 TCP: <a href="http://jm.taobao.org/2017/06/08/20170608/">http://jm.taobao.org/2017/06/08/20170608/</a></p><p>[243]<br>TCP协议详解: <a href="https://juejin.im/post/5ba895a06fb9a05ce95c5dac">https://juejin.im/post/5ba895a06fb9a05ce95c5dac</a></p><p>[244]<br>面试时，你被问到过 TCP/IP 协议吗?: <a href="https://juejin.im/post/58e36d35b123db15eb748856">https://juejin.im/post/58e36d35b123db15eb748856</a></p><p>[245]<br>“三次握手，四次挥手”你真的懂吗？: <a href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></p><p>[246]<br>五分钟了解CDN: <a href="https://juejin.im/post/5afa449c51882542ba07e70e">https://juejin.im/post/5afa449c51882542ba07e70e</a></p><p>[247]<br>漫话：如何给女朋友解释什么是CDN？: <a href="https://juejin.im/post/5d478c48e51d453c135c5a5c">https://juejin.im/post/5d478c48e51d453c135c5a5c</a></p><p>[248]<br>关于 cdn、回源等问题一网打尽: <a href="https://juejin.im/post/5af46498f265da0b8d41f6a3">https://juejin.im/post/5af46498f265da0b8d41f6a3</a></p><p>[249]<br>CDN是什么？使用CDN有什么优势？: <a href="https://www.zhihu.com/question/36514327?rf=37353035">https://www.zhihu.com/question/36514327?rf=37353035</a></p><p>[250]<br>从输入URL到页面展示，这中间发生了什么？: <a href="https://time.geekbang.org/column/article/117637">https://time.geekbang.org/column/article/117637</a></p><p>[251]<br>前端经典面试题: 从输入URL到页面加载发生了什么？: <a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></p><p>[252]<br>Javascript常用的设计模式详解: <a href="https://www.cnblogs.com/tugenhua0707/p/5198407.html">https://www.cnblogs.com/tugenhua0707/p/5198407.html</a></p><p>[253]<br>JavaScript设计模式: <a href="https://juejin.im/post/59df4f74f265da430f311909">https://juejin.im/post/59df4f74f265da430f311909</a></p><p>[254]<br>JavaScript 中常见设计模式整理: <a href="https://juejin.im/post/5afe6430518825428630bc4d">https://juejin.im/post/5afe6430518825428630bc4d</a></p><p>[255]<br>JavaScript 常见设计模式解析: <a href="https://juejin.im/post/58f4c702a0bb9f006aa80f25">https://juejin.im/post/58f4c702a0bb9f006aa80f25</a></p><p>[256]<br>深入 JavaScript 设计模式，从此有了优化代码的理论依据: <a href="https://juejin.im/post/5d58ca046fb9a06ad0056cc7">https://juejin.im/post/5d58ca046fb9a06ad0056cc7</a></p><p>[257]<br>设计模式之美-前端: <a href="https://zhuanlan.zhihu.com/p/111553641">https://zhuanlan.zhihu.com/p/111553641</a></p><p>[258]<br>Linked Lists in JavaScript (ES6 code): <a href="https://codeburst.io/linked-lists-in-javascript-es6-code-part-1-6dd349c3dcc3">https://codeburst.io/linked-lists-in-javascript-es6-code-part-1-6dd349c3dcc3</a></p><p>[259]<br>DS with JS — Linked Lists — II: <a href="https://medium.com/dev-blogs/ds-with-js-linked-lists-ii-3b387596e27e">https://medium.com/dev-blogs/ds-with-js-linked-lists-ii-3b387596e27e</a></p><p>[260]<br>LeetCode List: <a href="https://zxi.mytechroad.com/blog/leetcode-list/">https://zxi.mytechroad.com/blog/leetcode-list/</a></p><p>[261]<br>JS中的算法与数据结构——链表(Linked-list): <a href="https://www.jianshu.com/p/f254ec665e57">https://www.jianshu.com/p/f254ec665e57</a></p><p>[262]<br>前端笔试&amp;面试爬坑系列—算法: <a href="https://juejin.im/post/5b72f0caf265da282809f3b5">https://juejin.im/post/5b72f0caf265da282809f3b5</a></p><p>[263]<br>漫画：什么是红黑树？: <a href="https://juejin.im/post/5a27c6946fb9a04509096248">https://juejin.im/post/5a27c6946fb9a04509096248</a></p><p>[264]<br>前端你应该了解的数据结构与算法: <a href="https://juejin.im/post/5b331bc7f265da598451fd88">https://juejin.im/post/5b331bc7f265da598451fd88</a></p><p>[265]<br>数据结构和算法在前端领域的应用（前菜）: <a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9">https://juejin.im/post/5d3dc8466fb9a07efc49d0a9</a></p><p>[266]<br>数据结构与算法在前端领域的应用 - 第二篇: <a href="https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/">https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/</a></p><p>[267]<br>JavaScript 数据结构与算法之美: <a href="https://github.com/biaochenxuying/blog/issues/43">https://github.com/biaochenxuying/blog/issues/43</a></p><p>[268]<br>前端安全系列（一）：如何防止XSS攻击？: <a href="https://tech.meituan.com/2018/09/27/fe-security.html">https://tech.meituan.com/2018/09/27/fe-security.html</a></p><p>[269]<br>前端安全系列（二）：如何防止CSRF攻击？: <a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a></p><p>[270]<br>Security: <a href="https://almanac.httparchive.org/en/2019/security">https://almanac.httparchive.org/en/2019/security</a></p><p>[271]<br>前端也需要了解的 JSONP 安全: <a href="https://juejin.im/post/5b75b497e51d45666276251d">https://juejin.im/post/5b75b497e51d45666276251d</a></p><p>[272]<br>【面试篇】寒冬求职之你必须要懂的Web安全: <a href="https://juejin.im/post/5cd6ad7a51882568d3670a8e">https://juejin.im/post/5cd6ad7a51882568d3670a8e</a></p><p>[273]<br>谈谈对 Web 安全的理解: <a href="https://zhuanlan.zhihu.com/p/25486768?group_id=820705780520079360">https://zhuanlan.zhihu.com/p/25486768?group_id=820705780520079360</a></p><p>[274]<br>程序员必须要了解的web安全: <a href="https://juejin.im/post/5b4e0c936fb9a04fcf59cb79">https://juejin.im/post/5b4e0c936fb9a04fcf59cb79</a></p><p>[275]<br>可信前端之路：代码保护: <a href="https://www.freebuf.com/articles/web/102269.html">https://www.freebuf.com/articles/web/102269.html</a></p><p>[276]<br>前端如何给 JavaScript 加密（不是混淆）？: <a href="https://www.zhihu.com/question/47047191">https://www.zhihu.com/question/47047191</a></p><p>[277]<br>常见 Web 安全攻防总结: <a href="https://zoumiaojiang.com/article/common-web-security/">https://zoumiaojiang.com/article/common-web-security/</a></p><p>[278]<br>一篇文章构建你的 NodeJS 知识体系: <a href="https://juejin.im/post/5c4c0ee8f265da61117aa527">https://juejin.im/post/5c4c0ee8f265da61117aa527</a></p><p>[279]<br>真-Node多线程: <a href="https://juejin.im/post/5c63b5676fb9a049ac79a798">https://juejin.im/post/5c63b5676fb9a049ac79a798</a></p><p>[280]<br>浏览器与Node的事件循环(Event Loop)有何区别?: <a href="https://zhuanlan.zhihu.com/p/54882306">https://zhuanlan.zhihu.com/p/54882306</a></p><p>[281]<br>聊聊 Node.js RPC: <a href="https://www.yuque.com/egg/nodejs/dklip5">https://www.yuque.com/egg/nodejs/dklip5</a></p><p>[282]<br>Understanding Streams in Node.js: <a href="https://nodesource.com/blog/understanding-streams-in-nodejs">https://nodesource.com/blog/understanding-streams-in-nodejs</a></p><p>[283]<br>如何通过饿了么 Node.js 面试: <a href="https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn">https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn</a></p><p>[284]<br>字节跳动面试官：请你实现一个大文件上传和断点续传: <a href="https://juejin.im/post/5dff8a26e51d4558105420ed">https://juejin.im/post/5dff8a26e51d4558105420ed</a></p><p>[285]<br>深入浅出浏览器渲染原理: <a href="https://zhuanlan.zhihu.com/p/53913989">https://zhuanlan.zhihu.com/p/53913989</a></p><p>[286]<br>前端开发如何独立解决跨域问题: <a href="https://segmentfault.com/a/1190000010719058">https://segmentfault.com/a/1190000010719058</a></p><p>[287]<br>探索 Serverless 中的前端开发模式: <a href="https://juejin.im/post/5cdc3dc2e51d453b6c1d9d3a">https://juejin.im/post/5cdc3dc2e51d453b6c1d9d3a</a></p><p>[288]<br>「NGW」前端新技术赛场：Serverless SSR 技术内幕: <a href="https://juejin.im/post/5dce7140f265da0bf80b5246?utm_source=gold_browser_extension">https://juejin.im/post/5dce7140f265da0bf80b5246?utm_source=gold_browser_extension</a></p><p>[289]<br>JavaScript与Unicode: <a href="https://cjting.me/web2.0/js-and-unicode/">https://cjting.me/web2.0/js-and-unicode/</a></p><p>[290]<br>九种跨域方式实现原理（完整版）: <a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">https://juejin.im/post/5c23993de51d457b8c1f4ee1</a></p><p>[291]<br>7分钟理解JS的节流、防抖及使用场景: <a href="https://juejin.im/post/5b8de829f265da43623c4261">https://juejin.im/post/5b8de829f265da43623c4261</a></p><p>[292]<br>浏览器的工作原理：新式网络浏览器幕后揭秘: <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></p><p>[293]<br>Different Types Of Observers Supported By Modern Browsers: <a href="https://www.zeolearn.com/magazine/different-types-of-observers-supported-by-modern-browsers">https://www.zeolearn.com/magazine/different-types-of-observers-supported-by-modern-browsers</a></p><p>[294]<br>浏览器同源策略与ajax跨域方法汇总: <a href="https://www.jianshu.com/p/438183ddcea8">https://www.jianshu.com/p/438183ddcea8</a></p><p>[295]<br>一年半经验如何准备阿里巴巴 P6 前端面试: <a href="https://juejin.im/post/5e5522b36fb9a07ce152c51c">https://juejin.im/post/5e5522b36fb9a07ce152c51c</a></p><p>[296]<br>面试分享：两年工作经验成功面试阿里P6总结: <a href="https://juejin.im/post/5d690c726fb9a06b155dd40d">https://juejin.im/post/5d690c726fb9a06b155dd40d</a></p><p>[297]<br>总结了17年初到18年初百场前端面试的面试经验(含答案): <a href="https://juejin.im/post/5b44a485e51d4519945fb6b7">https://juejin.im/post/5b44a485e51d4519945fb6b7</a></p><p>[298]<br>2018春招前端面试: 闯关记(精排精校) | 掘金技术征文: <a href="https://juejin.im/post/5a998991f265da237f1dbdf9">https://juejin.im/post/5a998991f265da237f1dbdf9</a></p><p>[299]<br>20道JS原理题助你面试一臂之力！: <a href="https://juejin.im/post/5d2ee123e51d4577614761f8">https://juejin.im/post/5d2ee123e51d4577614761f8</a></p><p>[300]<br>一年半经验，百度、有赞、阿里前端面试总结: <a href="https://juejin.im/post/5befeb5051882511a8527dbe">https://juejin.im/post/5befeb5051882511a8527dbe</a></p><p>[301]<br>22 道高频 JavaScript 手写面试题及答案: <a href="https://juejin.im/post/5d51e16d6fb9a06ae17d6bbc">https://juejin.im/post/5d51e16d6fb9a06ae17d6bbc</a></p><p>[302]<br>面试分享：专科半年经验面试阿里前端P6+总结(附面试真题及答案): <a href="https://juejin.im/post/5a92c23b5188257a6b06110b">https://juejin.im/post/5a92c23b5188257a6b06110b</a></p><p>[303]<br>写给 女朋友的中级前端面试秘籍: <a href="https://juejin.im/post/5e7af0685188255dcf4a497e">https://juejin.im/post/5e7af0685188255dcf4a497e</a></p><p>[304]<br>阿里前端攻城狮们写了一份前端面试题答案，请查收: <a href="https://juejin.im/post/5e7426d15188254967069c00">https://juejin.im/post/5e7426d15188254967069c00</a></p><p>[305]<br>字节跳动今日头条前端面经（4轮技术面+hr面）: <a href="https://juejin.im/post/5e6a14b1f265da572978a1d3">https://juejin.im/post/5e6a14b1f265da572978a1d3</a></p><p>[306]<br>「面试题」20+Vue面试题整理(持续更新): <a href="https://juejin.im/post/5e649e3e5188252c06113021">https://juejin.im/post/5e649e3e5188252c06113021</a></p><p>[307]<br>「吐血整理」再来一打Webpack面试题(持续更新): <a href="https://juejin.im/post/5e6f4b4e6fb9a07cd443d4a5">https://juejin.im/post/5e6f4b4e6fb9a07cd443d4a5</a></p><p>[308]<br>高级前端开发者必会的34道Vue面试题系列: <a href="https://juejin.im/post/5e7410ed51882549087dc365">https://juejin.im/post/5e7410ed51882549087dc365</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2020 年前端面试复习必读文章【超三百篇】&lt;br&gt;前端开发 2020-11-03&lt;br&gt;以下文章来源于前端试炼 ，作者axuebin&lt;/p&gt;
&lt;p&gt;来自公众号：前端试炼&lt;br&gt;前言&lt;br&gt;十分全面的前端面试复习导图，覆盖三百篇精选文章，希望能够「授人以鱼，不如授之以渔」，已经有同学照这份导图进行复习，收获满意的offer。&lt;/p&gt;
&lt;p&gt;给大家整理了一下每个 case 一些还算不错的文章吧（还包括一些躺在我收藏夹里的好文章），大家可以自己看文章总结一下答案，这样也会理解更深刻。&lt;/p&gt;
&lt;p&gt;希望是一个抛砖引玉的作用，希望大家也可以锻炼一下找有效资料的能力 ~&lt;/p&gt;
&lt;p&gt;( 文章排序不分前后，随机排序 ~&lt;/p&gt;
&lt;p&gt;由于微信无法打开外链，所有的链接都在文章最底下啦，可以在电脑上打开、收藏这篇文章 ~&lt;/p&gt;
&lt;p&gt;或点击阅读原文打开发在掘金上的这篇文章。&lt;/p&gt;
&lt;p&gt;带👉的文章是微信里可以直接打开的。&lt;/p&gt;
&lt;p&gt;完整面试复习导图在公众号后台回复：面试。&lt;/p&gt;</summary>
    
    
    
    <category term="Hello" scheme="https://qyjs.github.io/categories/Hello/"/>
    
    
    <category term="Hello" scheme="https://qyjs.github.io/tags/Hello/"/>
    
  </entry>
  
  <entry>
    <title>CSS 面试知识点总结</title>
    <link href="https://qyjs.github.io/2021/01/20/CSS-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
    <id>https://qyjs.github.io/2021/01/20/CSS-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</id>
    <published>2021-01-20T07:28:18.000Z</published>
    <updated>2023-06-02T07:42:45.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-面试知识点总结"><a href="#CSS-面试知识点总结" class="headerlink" title="CSS 面试知识点总结"></a>CSS 面试知识点总结</h2><p>本部分主要是笔者在复习 CSS 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#css-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93">CSS 面试知识点总结</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#1%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%A0%87%E5%87%86%E7%9A%84-css-%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%BD%8E%E7%89%88%E6%9C%AC-ie-%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84">1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</a></li><li><a href="#2css-%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B">2.CSS 选择符有哪些？</a></li><li><a href="#3before-%E5%92%8Cafter-%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99-2-%E4%B8%AA%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%9C%E7%94%A8">3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</a></li><li><a href="#4%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB">4.伪类与伪元素的区别</a></li><li><a href="#5css-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF">5.CSS 中哪些属性可以继承？</a></li><li><a href="#6css-%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97">6.CSS 优先级算法如何计算？</a></li><li><a href="#7%E5%85%B3%E4%BA%8E%E4%BC%AA%E7%B1%BB-lvha-%E7%9A%84%E8%A7%A3%E9%87%8A">7.关于伪类 LVHA 的解释?</a></li><li><a href="#8css3-%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%E6%9C%89%E9%82%A3%E4%BA%9B">8.CSS3 新增伪类有那些？</a></li><li><a href="#9%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD-div">9.如何居中 div？</a></li><li><a href="#10display-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%80%BC%E8%AF%B4%E6%98%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8">10.display 有哪些值？说明他们的作用</a></li><li><a href="#11position-%E7%9A%84%E5%80%BC-relative-%E5%92%8C-absolute-%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%82%B9%E6%98%AF">11.position 的值 relative 和 absolute 定位原点是？</a></li><li><a href="#12css3-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E6%A0%B9%E6%8D%AE%E9%A1%B9%E7%9B%AE%E5%9B%9E%E7%AD%94">12.CSS3 有哪些新特性？（根据项目回答）</a></li><li><a href="#13%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-css3-%E7%9A%84-flex-box%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</a></li><li><a href="#14%E7%94%A8%E7%BA%AF-css-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">14.用纯 CSS 创建一个三角形的原理是什么？</a></li><li><a href="#15%E4%B8%80%E4%B8%AA%E6%BB%A1%E5%B1%8F%E5%93%81%E5%AD%97%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1">15.一个满屏品字布局如何设计?</a></li><li><a href="#16css-%E5%A4%9A%E5%88%97%E7%AD%89%E9%AB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">16.CSS 多列等高如何实现？</a></li><li><a href="#17%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%E5%B8%B8%E7%94%A8-hack-%E7%9A%84%E6%8A%80%E5%B7%A7">17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</a></li><li><a href="#18li-%E4%B8%8E-li-%E4%B9%8B%E9%97%B4%E6%9C%89%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E7%A9%BA%E7%99%BD%E9%97%B4%E9%9A%94%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</a></li><li><a href="#19%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96-css-%E6%A0%B7%E5%BC%8F">19.为什么要初始化 CSS 样式？</a></li><li><a href="#20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%E5%90%AB%E5%9D%97%E5%AF%B9%E4%BA%8E%E5%8C%85%E5%90%AB%E5%9D%97%E7%9A%84%E7%90%86%E8%A7%A3">20.什么是包含块，对于包含块的理解?</a></li><li><a href="#21css-%E9%87%8C%E7%9A%84-visibility-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%B8%AA-collapse-%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AF%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E4%BB%A5%E5%90%8E%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</a></li><li><a href="#22widthauto-%E5%92%8C-width100%E7%9A%84%E5%8C%BA%E5%88%AB">22.width:auto 和 width:100%的区别</a></li><li><a href="#23%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E4%B8%8E%E9%9D%9E%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB">23.绝对定位元素与非绝对定位元素的百分比计算的区别</a></li><li><a href="#24%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87-base64-%E7%BC%96%E7%A0%81%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">24.简单介绍使用图片 base64 编码的优点和缺点</a></li><li><a href="#25displayposition%E5%92%8Cfloat%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB">25.’display’、’position’和’float’的相互关系？</a></li><li><a href="#26margin-%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%E7%9A%84%E7%90%86%E8%A7%A3">26.margin 重叠问题的理解</a></li><li><a href="#27%E5%AF%B9-bfc-%E8%A7%84%E8%8C%83%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87block-formatting-context%E7%9A%84%E7%90%86%E8%A7%A3">27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</a></li><li><a href="#28ifc-%E6%98%AF%E4%BB%80%E4%B9%88">28.IFC 是什么？</a></li><li><a href="#29%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F">29.请解释一下为什么需要清除浮动？清除浮动的方式</a></li><li><a href="#30%E4%BD%BF%E7%94%A8-clear-%E5%B1%9E%E6%80%A7%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%8E%9F%E7%90%86">30.使用 clear 属性清除浮动的原理？</a></li><li><a href="#31zoom1-%E7%9A%84%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%8E%9F%E7%90%86">31.zoom:1 的清除浮动原理?</a></li><li><a href="#32%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%B8%83%E5%B1%80%E7%94%A8%E8%BF%87%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%90%97">32.移动端的布局用过媒体查询吗？</a></li><li><a href="#33%E4%BD%BF%E7%94%A8-css-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%90%97%E5%96%9C%E6%AC%A2%E5%93%AA%E4%B8%AA">33.使用 CSS 预处理器吗？喜欢哪个？</a></li><li><a href="#34css-%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">34.CSS 优化、提高性能的方法有哪些？</a></li><li><a href="#35%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E6%9E%90-css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84">35.浏览器是怎样解析 CSS 选择器的？</a></li><li><a href="#36%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E5%81%B6%E6%95%B0%E7%9A%84%E5%AD%97%E4%BD%93%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2">36.在网页中应该使用奇数还是偶数的字体？为什么呢？</a></li><li><a href="#37margin-%E5%92%8C-padding-%E5%88%86%E5%88%AB%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8">37.margin 和 padding 分别适合什么场景使用？</a></li><li><a href="#38%E6%8A%BD%E7%A6%BB%E6%A0%B7%E5%BC%8F%E6%A8%A1%E5%9D%97%E6%80%8E%E4%B9%88%E5%86%99%E8%AF%B4%E5%87%BA%E6%80%9D%E8%B7%AF%E6%9C%89%E6%97%A0%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%E9%98%BF%E9%87%8C%E8%88%AA%E6%97%85%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</a></li><li><a href="#39%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B-css3-%E7%9A%84-all-%E5%B1%9E%E6%80%A7">39.简单说一下 css3 的 all 属性</a></li><li><a href="#40%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%BB%9F%E9%85%8D%E7%AC%A6%E5%88%9D%E5%A7%8B%E5%8C%96-css-%E6%A0%B7%E5%BC%8F">40.为什么不建议使用统配符初始化 css 样式</a></li><li><a href="#41absolute-%E7%9A%84-containingblock%E5%8C%85%E5%90%AB%E5%9D%97%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E8%B7%9F%E6%AD%A3%E5%B8%B8%E6%B5%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</a></li><li><a href="#42%E5%AF%B9%E4%BA%8E-haslayout-%E7%9A%84%E7%90%86%E8%A7%A3">42.对于 hasLayout 的理解？</a></li><li><a href="#43%E5%85%83%E7%B4%A0%E7%AB%96%E5%90%91%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%BE%E5%AE%9A%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E9%AB%98%E5%BA%A6%E5%90%97">43.元素竖向的百分比设定是相对于容器的高度吗？</a></li><li><a href="#44%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E7%94%A8%E5%88%B0%E4%BA%86-css-%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%BE%85%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5">44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</a></li><li><a href="#45%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84-ie%E5%BE%85%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3">45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</a></li><li><a href="#46%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95%E7%BB%99%E6%AF%8F%E9%A1%B5%E5%81%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E5%90%91%E4%B8%8B%E6%BB%91%E5%8A%A8%E8%A6%81%E5%86%8D%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%92%8C%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E5%81%9A">46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</a></li><li><a href="#47%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-chrome-%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%90%8E%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95%E7%9A%84%E9%BB%84%E8%89%B2%E8%83%8C%E6%99%AF">47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</a></li><li><a href="#48%E6%80%8E%E4%B9%88%E8%AE%A9-chrome-%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E-12px-%E7%9A%84%E6%96%87%E5%AD%97">48.怎么让 Chrome 支持小于 12px 的文字？</a></li><li><a href="#49%E8%AE%A9%E9%A1%B5%E9%9D%A2%E9%87%8C%E7%9A%84%E5%AD%97%E4%BD%93%E5%8F%98%E6%B8%85%E6%99%B0%E5%8F%98%E7%BB%86%E7%94%A8-css-%E6%80%8E%E4%B9%88%E5%81%9A">49.让页面里的字体变清晰，变细用 CSS 怎么做？</a></li><li><a href="#50font-style-%E5%B1%9E%E6%80%A7%E4%B8%AD-italic-%E5%92%8C-oblique-%E7%9A%84%E5%8C%BA%E5%88%AB">50.font-style 属性中 italic 和 oblique 的区别？</a></li><li><a href="#51%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0css-%E5%83%8F%E7%B4%A0%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E5%83%8F%E7%B4%A0dprppi-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</a></li><li><a href="#52layout-viewportvisual-viewport-%E5%92%8C-ideal-viewport-%E7%9A%84%E5%8C%BA%E5%88%AB">52.layout viewport、visual viewport 和 ideal viewport 的区别？</a></li><li><a href="#53positionfixed%E5%9C%A8-android-%E4%B8%8B%E6%97%A0%E6%95%88%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">53.position:fixed;在 android 下无效怎么处理？</a></li><li><a href="#54%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%86%99%E5%8A%A8%E7%94%BB%E4%BD%A0%E8%AE%A4%E4%B8%BA%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C">54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</a></li><li><a href="#55%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8E%BB%E9%99%A4-inline-block-%E5%85%83%E7%B4%A0%E9%97%B4%E9%97%B4%E8%B7%9D">55.如何让去除 inline-block 元素间间距？</a></li><li><a href="#56overflowscroll-%E6%97%B6%E4%B8%8D%E8%83%BD%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">56.overflow:scroll 时不能平滑滚动的问题怎么处理？</a></li><li><a href="#57%E6%9C%89%E4%B8%80%E4%B8%AA%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84-div%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%A4%E4%B8%AA-div%E4%B8%80%E4%B8%AA%E9%AB%98%E5%BA%A6-100px%E5%B8%8C%E6%9C%9B%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A1%AB%E6%BB%A1%E5%89%A9%E4%B8%8B%E7%9A%84%E9%AB%98%E5%BA%A6">57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度</a></li><li><a href="#58pngjpggif-%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87-webp">58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</a></li><li><a href="#59%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-webp-%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87">59.浏览器如何判断是否支持 webp 格式图片</a></li><li><a href="#60%E4%BB%80%E4%B9%88%E6%98%AF-cookie-%E9%9A%94%E7%A6%BB%E6%88%96%E8%80%85%E8%AF%B4%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%AE%83%E5%B8%A6-cookie-%E6%80%8E%E4%B9%88%E5%81%9A">60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</a></li><li><a href="#61style-%E6%A0%87%E7%AD%BE%E5%86%99%E5%9C%A8-body-%E5%90%8E%E4%B8%8E-body-%E5%89%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">61.style 标签写在 body 后与 body 前有什么区别？</a></li><li><a href="#62%E4%BB%80%E4%B9%88%E6%98%AF-css-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8">62.什么是 CSS 预处理器/后处理器？</a></li><li><a href="#63%E9%98%90%E8%BF%B0%E4%B8%80%E4%B8%8B-csssprites">63.阐述一下 CSSSprites</a></li><li><a href="#64%E4%BD%BF%E7%94%A8-rem-%E5%B8%83%E5%B1%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">64.使用 rem 布局的优缺点？</a></li><li><a href="#65%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84-css-%E5%B8%83%E5%B1%80">65.几种常见的 CSS 布局</a></li><li><a href="#66%E7%94%BB%E4%B8%80%E6%9D%A1-05px-%E7%9A%84%E7%BA%BF">66.画一条 0.5px 的线</a></li><li><a href="#67transition-%E5%92%8C-animation-%E7%9A%84%E5%8C%BA%E5%88%AB">67.transition 和 animation 的区别</a></li><li><a href="#68%E4%BB%80%E4%B9%88%E6%98%AF%E9%A6%96%E9%80%89%E6%9C%80%E5%B0%8F%E5%AE%BD%E5%BA%A6">68.什么是首选最小宽度？</a></li><li><a href="#69%E4%B8%BA%E4%BB%80%E4%B9%88-height100%E4%BC%9A%E6%97%A0%E6%95%88">69.为什么 height:100%会无效？</a></li><li><a href="#70min-widthmax-width-%E5%92%8C-min-heightmax-height-%E5%B1%9E%E6%80%A7%E9%97%B4%E7%9A%84%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99">70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</a></li><li><a href="#71%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">71.内联盒模型基本概念</a></li><li><a href="#72%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BD%E7%81%B5%E7%A9%BA%E7%99%BD%E8%8A%82%E7%82%B9">72.什么是幽灵空白节点？</a></li><li><a href="#73%E4%BB%80%E4%B9%88%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0">73.什么是替换元素？</a></li><li><a href="#74%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99">74.替换元素的计算规则？</a></li><li><a href="#75content-%E4%B8%8E%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B3%E7%B3%BB">75.content 与替换元素的关系？</a></li><li><a href="#76marginauto-%E7%9A%84%E5%A1%AB%E5%85%85%E8%A7%84%E5%88%99">76.margin:auto 的填充规则？</a></li><li><a href="#77margin-%E6%97%A0%E6%95%88%E7%9A%84%E6%83%85%E5%BD%A2">77.margin 无效的情形</a></li><li><a href="#78border-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">78.border 的特殊性？</a></li><li><a href="#79%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E7%BA%BF%E5%92%8C-x-height">79.什么是基线和 x-height？</a></li><li><a href="#80line-height-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">80.line-height 的特殊性？</a></li><li><a href="#81vertical-align-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">81.vertical-align 的特殊性？</a></li><li><a href="#82overflow-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">82.overflow 的特殊性？</a></li><li><a href="#83%E6%97%A0%E4%BE%9D%E8%B5%96%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%98%AF%E4%BB%80%E4%B9%88">83.无依赖绝对定位是什么？</a></li><li><a href="#84absolute-%E4%B8%8E-overflow-%E7%9A%84%E5%85%B3%E7%B3%BB">84.absolute 与 overflow 的关系？</a></li><li><a href="#85clip-%E8%A3%81%E5%89%AA%E6%98%AF%E4%BB%80%E4%B9%88">85.clip 裁剪是什么？</a></li><li><a href="#86relative-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">86.relative 的特殊性？</a></li><li><a href="#87%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87">87.什么是层叠上下文？</a></li><li><a href="#88%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%82%E5%8F%A0%E6%B0%B4%E5%B9%B3">88.什么是层叠水平？</a></li><li><a href="#89%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F">89.元素的层叠顺序？</a></li><li><a href="#90%E5%B1%82%E5%8F%A0%E5%87%86%E5%88%99">90.层叠准则？</a></li><li><a href="#91font-weight-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">91.font-weight 的特殊性？</a></li><li><a href="#92text-indent-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">92.text-indent 的特殊性？</a></li><li><a href="#93letter-spacing-%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%97%B4%E8%B7%9D">93.letter-spacing 与字符间距？</a></li><li><a href="#94word-spacing-%E4%B8%8E%E5%8D%95%E8%AF%8D%E9%97%B4%E8%B7%9D">94.word-spacing 与单词间距？</a></li><li><a href="#95white-space-%E4%B8%8E%E6%8D%A2%E8%A1%8C%E5%92%8C%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%8E%A7%E5%88%B6">95.white-space 与换行和空格的控制？</a></li><li><a href="#96%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84-background-image-%E5%88%B0%E5%BA%95%E5%8A%A0%E4%B8%8D%E5%8A%A0%E8%BD%BD">96.隐藏元素的 background-image 到底加不加载？</a></li><li><a href="#97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5">97.如何实现单行／多行文本溢出的省略（…）？</a></li><li><a href="#98%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F">98.常见的元素隐藏方式？</a></li><li><a href="#99css-%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80">99.css 实现上下固定中间自适应布局？</a></li><li><a href="#100css-%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0">100.css 两栏布局的实现？</a></li><li><a href="#101css-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0">101.css 三栏布局的实现？</a></li><li><a href="#102%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2">102.实现一个宽高自适应的正方形</a></li><li><a href="#103%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2">103.实现一个三角形</a></li><li><a href="#104%E4%B8%80%E4%B8%AA%E8%87%AA%E9%80%82%E5%BA%94%E7%9F%A9%E5%BD%A2%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E4%B8%94%E5%AE%BD%E9%AB%98%E6%AF%94%E4%B8%BA-21">104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</a></li><li><a href="#105%E4%BD%A0%E7%9F%A5%E9%81%93-css-%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%99%BE%E5%88%86%E6%AF%94%E6%97%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%87%86">105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</a></li></ul></li></ul></li></ul><h4 id="1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）有两种盒子模型：<span class="variable constant_">IE</span>盒模型（border-box）、<span class="variable constant_">W3C</span>标准盒模型（content-box）</span><br><span class="line">（<span class="number">2</span>）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">IE</span>盒模型和<span class="variable constant_">W3C</span>标准盒模型的区别：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）<span class="variable constant_">W3C</span>标准盒模型：属性width，height只包含内容content，不包含border和padding</span><br><span class="line">（<span class="number">2</span>）<span class="variable constant_">IE</span>盒模型：属性width，height包含content、border和padding，指的是content</span><br><span class="line">+padding+border。</span><br><span class="line"></span><br><span class="line">在ie8+浏览器中使用哪个盒模型可以由box-sizing（<span class="variable constant_">CSS</span>新增的属性）控制，默认值为content-box，即标准盒模型；</span><br><span class="line">如果将box-sizing设为border-box则用的是<span class="variable constant_">IE</span>盒模型。如果在ie6，<span class="number">7</span>，<span class="number">8</span>中<span class="variable constant_">DOCTYPE</span>缺失会将盒子模型解释为<span class="variable constant_">IE</span></span><br><span class="line">盒子模型。若在页面中声明了<span class="variable constant_">DOCTYPE</span>类型，所有的浏览器都会把盒模型解释为<span class="variable constant_">W3C</span>盒模型。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">盒模型都是由四个部分组成的，分别是margin、border、padding和content。</span><br><span class="line"></span><br><span class="line">标准盒模型和<span class="variable constant_">IE</span>盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的</span><br><span class="line">范围只包含了content，而<span class="variable constant_">IE</span>盒模型的width和height属性的范围包含了border、padding和content。</span><br><span class="line"></span><br><span class="line">一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</span><br></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://juejin.im/post/59ef72f5f265da4320026f76">《CSS 盒模型详解》</a></p><h4 id="2-CSS-选择符有哪些？"><a href="#2-CSS-选择符有哪些？" class="headerlink" title="2.CSS 选择符有哪些？"></a>2.CSS 选择符有哪些？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）id选择器（#myid）</span><br><span class="line">（<span class="number">2</span>）类选择器（.<span class="property">myclassname</span>）</span><br><span class="line">（<span class="number">3</span>）标签选择器（div,h1,p）</span><br><span class="line">（<span class="number">4</span>）后代选择器（h1 p）</span><br><span class="line">（<span class="number">5</span>）相邻后代选择器（子）选择器（ul&gt;li）</span><br><span class="line">（<span class="number">6</span>）兄弟选择器（li~a）</span><br><span class="line">（<span class="number">7</span>）相邻兄弟选择器（li+a）</span><br><span class="line">（<span class="number">8</span>）属性选择器（a[rel=<span class="string">&quot;external&quot;</span>]）</span><br><span class="line">（<span class="number">9</span>）伪类选择器（<span class="attr">a</span>:hover,<span class="attr">li</span>:nth-child）</span><br><span class="line">（<span class="number">10</span>）伪元素选择器（::before、::after）</span><br><span class="line">（<span class="number">11</span>）通配符选择器（*）</span><br></pre></td></tr></table></figure><h4 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单冒号（:）用于<span class="title class_">CSS3</span>伪类，双冒号（::）用于<span class="title class_">CSS3</span>伪元素。（伪元素由双冒号和伪元素名称组成）</span><br><span class="line">双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，</span><br><span class="line">比如:first-line、:first-letter、:before、:after等，</span><br><span class="line">而新的在<span class="title class_">CSS3</span>中引入的伪元素则不允许再支持旧的单冒号的写法。</span><br><span class="line"></span><br><span class="line">想让插入的内容出现在其它内容前，使用::before，否者，使用::after；</span><br><span class="line">在代码顺序上，::after生成的内容也比::before生成的内容靠后。</span><br><span class="line">如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号</span><br><span class="line">来表示伪元素。</span><br><span class="line"></span><br><span class="line">伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</span><br></pre></td></tr></table></figure><h4 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4.伪类与伪元素的区别"></a>4.伪类与伪元素的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句</span><br><span class="line">话中的第一个字母，或者是列表中的第一个元素。</span><br><span class="line"></span><br><span class="line">伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的</span><br><span class="line">元素时，我们可以通过:hover来描述这个元素的状态。</span><br><span class="line"></span><br><span class="line">伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be</span><br><span class="line">fore来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</span><br><span class="line"></span><br><span class="line">有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是<span class="title class_">CSS3</span>的一部分，并尝试区分伪类和伪元素。大多数浏览</span><br><span class="line">器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的<span class="variable constant_">W3C</span>规范并未对此进行</span><br><span class="line">特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/">《总结伪类与伪元素》</a></p><h4 id="5-CSS-中哪些属性可以继承？"><a href="#5-CSS-中哪些属性可以继承？" class="headerlink" title="5.CSS 中哪些属性可以继承？"></a>5.CSS 中哪些属性可以继承？</h4><p>相关资料：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算</span><br><span class="line">值。</span><br><span class="line"></span><br><span class="line">当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应</span><br><span class="line">该是在该属性本身的定义中的默认值）。</span><br><span class="line"></span><br><span class="line">当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial v</span><br><span class="line">alue（该值在该属性的概述里被指定）。</span><br><span class="line"></span><br><span class="line">有继承性的属性：</span><br><span class="line"></span><br><span class="line">（1）字体系列属性</span><br><span class="line">font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</span><br><span class="line"></span><br><span class="line">（2）文本系列属性</span><br><span class="line">text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、</span><br><span class="line">text-transform、direction、color</span><br><span class="line"></span><br><span class="line">（3）表格布局属性</span><br><span class="line">caption-side border-collapse empty-cells</span><br><span class="line"></span><br><span class="line">（4）列表属性</span><br><span class="line">list-style-type、list-style-image、list-style-position、list-style</span><br><span class="line"></span><br><span class="line">（5）光标属性</span><br><span class="line">cursor</span><br><span class="line"></span><br><span class="line">（6）元素可见性</span><br><span class="line">visibility</span><br><span class="line"></span><br><span class="line">（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地</span><br><span class="line">指定继承性，可用于任何继承性/非继承性属性。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值</span><br><span class="line">来作为自己的值。</span><br><span class="line"></span><br><span class="line">一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。</span><br><span class="line">表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。</span><br><span class="line"></span><br><span class="line">当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</span><br></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance">《继承属性》</a><br><a href="https://www.jianshu.com/p/34044e3c9317">《CSS 有哪些属性可以继承？》</a></p><h4 id="6-CSS-优先级算法如何计算？"><a href="#6-CSS-优先级算法如何计算？" class="headerlink" title="6.CSS 优先级算法如何计算？"></a>6.CSS 优先级算法如何计算？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CSS的优先级是根据样式声明的特殊性值来判断的。</span><br><span class="line"></span><br><span class="line">选择器的特殊性值分为四个等级，如下：</span><br><span class="line"></span><br><span class="line">（1）标签内选择符x,0,0,0</span><br><span class="line">（2）ID选择符0,x,0,0</span><br><span class="line">（3）class选择符/属性选择符/伪类选择符 0,0,x,0</span><br><span class="line">（4）元素和伪元素选择符0,0,0,x</span><br><span class="line"></span><br><span class="line">计算方法：</span><br><span class="line"></span><br><span class="line">（1）每个等级的初始值为0</span><br><span class="line">（2）每个等级的叠加为选择器出现的次数相加</span><br><span class="line">（3）不可进位，比如0,99,99,99</span><br><span class="line">（4）依次表示为：0,0,0,0</span><br><span class="line">（5）每个等级计数之间没关联</span><br><span class="line">（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值</span><br><span class="line">（7）如果两个优先级相同，则最后出现的优先级高，!important也适用</span><br><span class="line">（8）通配符选择器的特殊性值为：0,0,0,0</span><br><span class="line">（9）继承样式优先级最低，通配符样式优先级高于继承样式</span><br><span class="line">（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</span><br><span class="line"></span><br><span class="line">计算实例：</span><br><span class="line"></span><br><span class="line">（1）#demo a&#123;color: orange;&#125;/*特殊性值：0,1,0,1*/</span><br><span class="line">（2）div#demo a&#123;color: red;&#125;/*特殊性值：0,1,0,2*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</span><br><span class="line"></span><br><span class="line">（2）特殊性值越大的声明优先级越高。</span><br><span class="line"></span><br><span class="line">（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</span><br><span class="line"></span><br><span class="line"> (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，</span><br><span class="line">那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</span><br><span class="line"></span><br><span class="line">一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，</span><br><span class="line">第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，</span><br><span class="line">第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等</span><br><span class="line">级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。</span><br><span class="line">比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引</span><br><span class="line">入的顺序，后出现的规则的优先级最高。</span><br></pre></td></tr></table></figure><p>对于组合声明的特殊性值计算可以参考：<br><a href="https://www.jianshu.com/p/1c4e639ff7d5">《CSS 优先级计算及应用》</a><br><a href="http://www.cnblogs.com/wangmeijian/p/4207433.html">《CSS 优先级计算规则》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/">《有趣：256 个 class 选择器可以干掉 1 个 id 选择器》</a></p><h4 id="7-关于伪类-LVHA-的解释"><a href="#7-关于伪类-LVHA-的解释" class="headerlink" title="7.关于伪类 LVHA 的解释?"></a>7.关于伪类 LVHA 的解释?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</span><br><span class="line"></span><br><span class="line">当链接未访问过时：</span><br><span class="line"></span><br><span class="line">（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪</span><br><span class="line">类后面声明；</span><br><span class="line">（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），</span><br><span class="line">必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</span><br><span class="line"></span><br><span class="line">当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</span><br><span class="line"></span><br><span class="line">这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，</span><br><span class="line">也就不存在覆盖的问题。</span><br></pre></td></tr></table></figure><h4 id="8-CSS3-新增伪类有那些？"><a href="#8-CSS3-新增伪类有那些？" class="headerlink" title="8.CSS3 新增伪类有那些？"></a>8.CSS3 新增伪类有那些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数</span><br><span class="line">值，也可以接受函数。</span><br><span class="line"></span><br><span class="line">（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。</span><br><span class="line"></span><br><span class="line">（3）elem:last-child选中最后一个子元素。</span><br><span class="line"></span><br><span class="line">（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。</span><br><span class="line"></span><br><span class="line">（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</span><br><span class="line"></span><br><span class="line">（6）elem:first-of-type选中父元素下第一个elem类型元素。</span><br><span class="line"></span><br><span class="line">（7）elem:last-of-type选中父元素下最后一个elem类型元素。</span><br><span class="line"></span><br><span class="line">（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。</span><br><span class="line"></span><br><span class="line">（9）elem:empty选中不包含子元素和内容的elem类型元素。</span><br><span class="line"></span><br><span class="line">（10）elem:target选择当前活动的elem元素。</span><br><span class="line"></span><br><span class="line">（11）:not(elem)选择非elem元素的每个元素。</span><br><span class="line"></span><br><span class="line">（12）:enabled 控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">（13）:disabled 控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">(14):checked单选框或复选框被选中。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://www.cnblogs.com/SKLthegoodman/p/css3.html">《CSS3 新特性总结(伪类)》</a><br><a href="https://blog.csdn.net/zhouziyu2011/article/details/58605705">《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》</a></p><h4 id="9-如何居中-div？"><a href="#9-如何居中-div？" class="headerlink" title="9.如何居中 div？"></a>9.如何居中 div？</h4><p>-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-水平居中，利用 text-align:center 实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-让绝对定位的 div 居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-水平垂直居中一</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;<span class="comment">/*绝对定位*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">150px</span>00-<span class="number">250px</span>;<span class="comment">/*外边距为自身宽高的一半*/</span></span><br><span class="line"><span class="attribute">background-color</span>: pink<span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-水平垂直居中二</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*未知容器的宽高，利用`transform`属性*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*相对定位或绝对定位均可*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-水平垂直居中三</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*利用flex布局实际使用时应考虑兼容性*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/*垂直居中*/</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/*水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.containerdiv</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-水平垂直居中四</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*利用text-align:center和vertical-align:middle属性*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">white-space</span>: normal;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一般常见的几种居中的方法有：</span><br><span class="line"></span><br><span class="line">对于宽高固定的元素</span><br><span class="line"></span><br><span class="line">（1）我们可以利用margin:0 auto来实现元素的水平居中。</span><br><span class="line"></span><br><span class="line">（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水</span><br><span class="line">平和垂直方向上的居中。</span><br><span class="line"></span><br><span class="line">（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素</span><br><span class="line">的中心点到页面的中心。</span><br><span class="line"></span><br><span class="line">（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素</span><br><span class="line">的中心点到页面的中心。</span><br><span class="line"></span><br><span class="line">（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对</span><br><span class="line">齐，然后它的子元素也可以实现垂直和水平的居中。</span><br><span class="line"></span><br><span class="line">对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</span><br></pre></td></tr></table></figure><h4 id="10-display-有哪些值？说明他们的作用"><a href="#10-display-有哪些值？说明他们的作用" class="headerlink" title="10.display 有哪些值？说明他们的作用"></a>10.display 有哪些值？说明他们的作用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</span><br><span class="line">none 元素不显示，并从文档流中移除。</span><br><span class="line">inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</span><br><span class="line">inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</span><br><span class="line">list-item 像块类型元素一样显示，并添加样式列表标记。</span><br><span class="line">table 此元素会作为块级表格来显示。</span><br><span class="line">inherit 规定应该从父元素继承display属性的值。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/css/pr_class_display.asp">《CSS display 属性》</a></p><h4 id="11-position-的值-relative-和-absolute-定位原点是？"><a href="#11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="11.position 的值 relative 和 absolute 定位原点是？"></a>11.position 的值 relative 和 absolute 定位原点是？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">absolute</span><br><span class="line">生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的</span><br><span class="line">一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。</span><br><span class="line"></span><br><span class="line">fixed（老IE不支持）</span><br><span class="line">生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line"></span><br><span class="line">relative</span><br><span class="line">生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</span><br><span class="line"></span><br><span class="line">static</span><br><span class="line">默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</span><br><span class="line"></span><br><span class="line">inherit</span><br><span class="line">规定从父元素继承position属性的值。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">relative定位的元素，是相对于元素本身的正常位置来进行定位的。</span><br><span class="line"></span><br><span class="line">absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话</span><br><span class="line">我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元</span><br><span class="line">素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</span><br></pre></td></tr></table></figure><h4 id="12-CSS3-有哪些新特性？（根据项目回答）"><a href="#12-CSS3-有哪些新特性？（根据项目回答）" class="headerlink" title="12.CSS3 有哪些新特性？（根据项目回答）"></a>12.CSS3 有哪些新特性？（根据项目回答）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新增各种CSS选择器 （:not(.input)：所有class不是“input”的节点）</span><br><span class="line">圆角  （border-radius:8px）</span><br><span class="line">多列布局 （multi-column layout）</span><br><span class="line">阴影和反射 （Shadow\Reflect）</span><br><span class="line">文字特效  （text-shadow）</span><br><span class="line">文字渲染  （Text-decoration）</span><br><span class="line">线性渐变  （gradient）</span><br><span class="line">旋转   （transform）</span><br><span class="line">缩放，定位，倾斜，动画，多背景</span><br><span class="line">例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</span><br></pre></td></tr></table></figure><h4 id="13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</span><br><span class="line"></span><br><span class="line">任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、cl</span><br><span class="line">ear和vertical-align属性将失效。</span><br><span class="line"></span><br><span class="line">采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex</span><br><span class="line">项目（flex item），简称&quot;项目&quot;。</span><br><span class="line"></span><br><span class="line">容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下6个属性设置在容器上。</span><br><span class="line"></span><br><span class="line">flex-direction属性决定主轴的方向（即项目的排列方向）。</span><br><span class="line"></span><br><span class="line">flex-wrap属性定义，如果一条轴线排不下，如何换行。</span><br><span class="line"></span><br><span class="line">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span><br><span class="line"></span><br><span class="line">justify-content属性定义了项目在主轴上的对齐方式。</span><br><span class="line"></span><br><span class="line">align-items属性定义项目在交叉轴上如何对齐。</span><br><span class="line"></span><br><span class="line">align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下6个属性设置在项目上。</span><br><span class="line"></span><br><span class="line">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span><br><span class="line"></span><br><span class="line">flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line"></span><br><span class="line">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line"></span><br><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认</span><br><span class="line">值为auto，即项目的本来大小。</span><br><span class="line"></span><br><span class="line">flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</span><br><span class="line"></span><br><span class="line">align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父</span><br><span class="line">元素的align-items属性，如果没有父元素，则等同于stretch。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex</span><br><span class="line">容器，它的所有子元素都会成为它的项目。</span><br><span class="line"></span><br><span class="line">一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。</span><br><span class="line">我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还</span><br><span class="line">可以使用flex-wrap来规定当一行排列不下时的换行方式。</span><br><span class="line"></span><br><span class="line">对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，</span><br><span class="line">项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">《Flex 布局教程：语法篇》</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">《Flex 布局教程：实例篇》</a></p><h4 id="14-用纯-CSS-创建一个三角形的原理是什么？"><a href="#14-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="14.用纯 CSS 创建一个三角形的原理是什么？"></a>14.用纯 CSS 创建一个三角形的原理是什么？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">采用的是相邻边框连接处的均分原理。</span><br><span class="line">  将元素的宽高设为<span class="number">0</span>，只设置</span><br><span class="line">  <span class="attribute">border</span></span><br><span class="line">  ，把任意三条边隐藏掉（颜色设为</span><br><span class="line">  transparent），剩下的就是一个三角形。</span><br><span class="line">  <span class="selector-id">#demo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-一个满屏品字布局如何设计"><a href="#15-一个满屏品字布局如何设计" class="headerlink" title="15.一个满屏品字布局如何设计?"></a>15.一个满屏品字布局如何设计?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简单的方式：</span><br><span class="line"> 上面的div宽100%，</span><br><span class="line"> 下面的两个div分别宽50%，</span><br><span class="line"> 然后用float或者inline使其不换行即可</span><br></pre></td></tr></table></figure><h4 id="16-CSS-多列等高如何实现？"><a href="#16-CSS-多列等高如何实现？" class="headerlink" title="16.CSS 多列等高如何实现？"></a>16.CSS 多列等高如何实现？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:</span><br><span class="line">hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则</span><br><span class="line">父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</span><br><span class="line"></span><br><span class="line">（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</span><br><span class="line"></span><br><span class="line">（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度</span><br><span class="line">的特性，来实现多列等高。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0fb34151882515662238fd">《前端应该掌握的 CSS 实现多列等高布局》</a><br><a href="https://codepen.io/yangbo5207/post/equh">《CSS：多列等高布局》</a></p><h4 id="17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">（1）png24位的图片在iE6浏览器上出现背景</span><br><span class="line">解决方案：做成PNG8，也可以引用一段脚本处理。</span><br><span class="line"></span><br><span class="line">（2）浏览器默认的margin和padding不同</span><br><span class="line">解决方案：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。</span><br><span class="line"></span><br><span class="line">（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或</span><br><span class="line">margin-right，margin值会加倍。</span><br><span class="line"></span><br><span class="line">#box&#123;float:left;width:10px;margin:0 0 0 10px;&#125;</span><br><span class="line"></span><br><span class="line">这种情况之下IE会产生20px的距离</span><br><span class="line">解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</span><br><span class="line"></span><br><span class="line">（4）渐进识别的方式，从总体中逐渐排除局部。</span><br><span class="line">首先，巧妙的使用&quot;\9&quot;这一标记，将IE游览器从所有情况中分离出来。</span><br><span class="line">接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</span><br><span class="line">.bb&#123;</span><br><span class="line">background-color:#f1ee18;/*所有识别*/</span><br><span class="line">.background-color:#00deff\9;/*IE6、7、8识别*/</span><br><span class="line">+background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">_background-color:#1e0bd1;/*IE6识别*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义</span><br><span class="line">属性；Firefox下，只能使用getAttribute()获取自定义属性</span><br><span class="line">解决方法：统一通过getAttribute()获取自定义属性。</span><br><span class="line"></span><br><span class="line">（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有</span><br><span class="line">pageX、pageY属性，但是没有x、y属性。</span><br><span class="line">解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</span><br><span class="line"></span><br><span class="line">（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示</span><br><span class="line">解决方法：</span><br><span class="line"></span><br><span class="line">1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome</span><br><span class="line">更新到27版本之后就不可以用了。</span><br><span class="line"></span><br><span class="line">2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);</span><br><span class="line">收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；</span><br><span class="line"></span><br><span class="line">（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了</span><br><span class="line">解决方法：改变CSS属性的排列顺序L-V-H-A</span><br><span class="line"></span><br><span class="line">（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模</span><br><span class="line">式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</span><br></pre></td></tr></table></figure><h4 id="18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，</span><br><span class="line">这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</span><br><span class="line"></span><br><span class="line">（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。</span><br><span class="line"></span><br><span class="line">（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他</span><br><span class="line">字符尺寸，且在Safari浏览器依然会出现空白间隔。</span><br><span class="line"></span><br><span class="line">（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符</span><br><span class="line">间隔设为默认letter-spacing:normal。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/sjinsa/article/details/70919546">《li 与 li 之间有看不见的空白间隔是什么原因引起的？》</a></p><h4 id="19-为什么要初始化-CSS-样式？"><a href="#19-为什么要初始化-CSS-样式？" class="headerlink" title="19.为什么要初始化 CSS 样式？"></a>19.为什么要初始化 CSS 样式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</span><br><span class="line"></span><br><span class="line">-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</span><br><span class="line"></span><br><span class="line">最简单的初始化方法：*&#123;padding:0;margin:0;&#125;（强烈不建议）</span><br><span class="line"></span><br><span class="line">淘宝的样式初始化代码：</span><br><span class="line">body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend</span><br><span class="line">,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;</span><br><span class="line">body,button,input,select,textarea&#123;font:12px/1.5tahoma,arial,\5b8b\4f53;&#125;</span><br><span class="line">h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;</span><br><span class="line">address,cite,dfn,em,var&#123;font-style:normal;&#125;</span><br><span class="line">code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;</span><br><span class="line">small&#123;font-size:12px;&#125;</span><br><span class="line">ul,ol&#123;list-style:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br><span class="line">a:hover&#123;text-decoration:underline;&#125;</span><br><span class="line">sup&#123;vertical-align:text-top;&#125;</span><br><span class="line">sub&#123;vertical-align:text-bottom;&#125;</span><br><span class="line">legend&#123;color:#000;&#125;</span><br><span class="line">fieldset,img&#123;border:0;&#125;</span><br><span class="line">button,input,select,textarea&#123;font-size:100%;&#125;</span><br><span class="line">table&#123;border-collapse:collapse;border-spacing:0;&#125;</span><br></pre></td></tr></table></figure><h4 id="20-什么是包含块，对于包含块的理解"><a href="#20-什么是包含块，对于包含块的理解" class="headerlink" title="20.什么是包含块，对于包含块的理解?"></a>20.什么是包含块，对于包含块的理解?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">包含块（containing block）就是元素用来计算和定位的一个框。</span><br><span class="line"></span><br><span class="line">（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</span><br><span class="line"></span><br><span class="line">（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box</span><br><span class="line">边界形成。</span><br><span class="line"></span><br><span class="line">（3）如果元素position:fixed，则“包含块”是“初始包含块”。</span><br><span class="line"></span><br><span class="line">（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</span><br><span class="line"></span><br><span class="line">如果该祖先元素是纯inline元素，则规则略复杂：</span><br><span class="line">•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包</span><br><span class="line">围盒就是内联元素的“包含块”；</span><br><span class="line">•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥</span><br><span class="line">否则，“包含块”由该祖先的padding box边界形成。</span><br><span class="line"></span><br><span class="line">如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</span><br></pre></td></tr></table></figure><h4 id="21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</span><br><span class="line"></span><br><span class="line">（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的</span><br><span class="line">表现却跟display:none一样，也就是说，它们占用的空间也会释放。</span><br><span class="line"></span><br><span class="line">在不同浏览器下的区别：</span><br><span class="line"></span><br><span class="line">在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</span><br><span class="line"></span><br><span class="line">在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位</span><br><span class="line">置。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.webhek.com/post/visibility-collapse.html">《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》</a></p><h4 id="22-width-auto-和-width-100-的区别"><a href="#22-width-auto-和-width-100-的区别" class="headerlink" title="22.width:auto 和 width:100%的区别"></a>22.width:auto 和 width:100%的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般而言</span><br><span class="line"></span><br><span class="line">width:100%会使元素box的宽度等于父元素的content box的宽度。</span><br><span class="line"></span><br><span class="line">width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</span><br></pre></td></tr></table></figure><h4 id="23-绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#23-绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="23.绝对定位元素与非绝对定位元素的百分比计算的区别"></a>23.绝对定位元素与非绝对定位元素的百分比计算的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。</span><br><span class="line"></span><br><span class="line">非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</span><br></pre></td></tr></table></figure><h4 id="24-简单介绍使用图片-base64-编码的优点和缺点"><a href="#24-简单介绍使用图片-base64-编码的优点和缺点" class="headerlink" title="24.简单介绍使用图片 base64 编码的优点和缺点"></a>24.简单介绍使用图片 base64 编码的优点和缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的</span><br><span class="line">url属性。</span><br><span class="line"></span><br><span class="line">使用base64的优点是：</span><br><span class="line"></span><br><span class="line">（1）减少一个图片的HTTP请求</span><br><span class="line"></span><br><span class="line">使用base64的缺点是：</span><br><span class="line"></span><br><span class="line">（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体</span><br><span class="line">积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</span><br><span class="line"></span><br><span class="line">（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要</span><br><span class="line">差很多。</span><br><span class="line"></span><br><span class="line">（3）兼容性的问题，ie8以前的浏览器不支持。</span><br><span class="line"></span><br><span class="line">一般一些网站的小图标可以使用base64图片来引入。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/coco1s/p/4375774.html">《玩转图片 base64 编码》</a><br><a href="https://www.zhihu.com/question/31155574">《前端开发中，使用 base64 图片的弊端是什么？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">《小 tip:base64:URL 背景图片与 web 页面性能优化》</a></p><h4 id="25-’display’、’position’和’float’的相互关系？"><a href="#25-’display’、’position’和’float’的相互关系？" class="headerlink" title="25.’display’、’position’和’float’的相互关系？"></a>25.’display’、’position’和’float’的相互关系？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</span><br><span class="line"></span><br><span class="line">（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被</span><br><span class="line">设置为table或者block，具体转换需要看初始转换值。</span><br><span class="line"></span><br><span class="line">（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display</span><br><span class="line">的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对</span><br><span class="line">于浮动后的最终位置定位。</span><br><span class="line"></span><br><span class="line">（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，</span><br><span class="line">则保持指定的display属性值不变。</span><br><span class="line"></span><br><span class="line">总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在</span><br><span class="line">的时候，浮动不起作用，&#x27;display&#x27;的值也需要调整；其次，元素的&#x27;float&#x27;特性的值不是&quot;none&quot;的时候或者它是根元素</span><br><span class="line">的时候，调整&#x27;display&#x27;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#x27;display&#x27;特性值同设置值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/jackyWHJ/p/3756087.html">《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》</a></p><h4 id="26-margin-重叠问题的理解"><a href="#26-margin-重叠问题的理解" class="headerlink" title="26.margin 重叠问题的理解"></a>26.margin 重叠问题的理解</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合</span><br><span class="line">并”。</span><br><span class="line"></span><br><span class="line">产生折叠的必备条件：margin必须是邻接的!</span><br><span class="line"></span><br><span class="line">而根据w3c规范，两个margin是邻接的必须满足以下条件：</span><br><span class="line"></span><br><span class="line">•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。</span><br><span class="line">•没有线盒，没有空隙，没有padding和border将他们分隔开</span><br><span class="line">•都属于垂直方向上相邻的外边距，可以是下面任意一种情况</span><br><span class="line">•元素的margin-top与其第一个常规文档流的子元素的margin-top</span><br><span class="line">•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</span><br><span class="line">•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</span><br><span class="line">•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top</span><br><span class="line">和margin-bottom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">margin合并的3种场景：</span><br><span class="line"></span><br><span class="line">（1）相邻兄弟元素margin合并。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line">•设置块状格式化上下文元素（BFC）</span><br><span class="line"></span><br><span class="line">（2）父级和第一个/最后一个子元素的margin合并。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">对于margin-top合并，可以进行如下操作（满足一个条件即可）：</span><br><span class="line">•父元素设置为块状格式化上下文元素；</span><br><span class="line">•父元素设置border-top值；</span><br><span class="line">•父元素设置padding-top值；</span><br><span class="line">•父元素和第一个子元素之间添加内联元素进行分隔。</span><br><span class="line"></span><br><span class="line">对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：</span><br><span class="line">•父元素设置为块状格式化上下文元素；</span><br><span class="line">•父元素设置border-bottom值；</span><br><span class="line">•父元素设置padding-bottom值；</span><br><span class="line">•父元素和最后一个子元素之间添加内联元素进行分隔；</span><br><span class="line">•父元素设置height、min-height或max-height。</span><br><span class="line"></span><br><span class="line">（3）空块级元素的margin合并。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line">•设置垂直方向的border；</span><br><span class="line">•设置垂直方向的padding；</span><br><span class="line">•里面添加内联元素（直接Space键空格是没用的）；</span><br><span class="line">•设置height或者min-height。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</span><br><span class="line"></span><br><span class="line">一般来说可以分为四种情形：</span><br><span class="line"></span><br><span class="line">第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC</span><br><span class="line">来解决。</span><br><span class="line"></span><br><span class="line">第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这</span><br><span class="line">一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC</span><br><span class="line">来解决。</span><br><span class="line"></span><br><span class="line">第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相</span><br><span class="line">邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为</span><br><span class="line">父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</span><br><span class="line"></span><br><span class="line">第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、pa</span><br><span class="line">dding或者高度来解决这个问题。</span><br></pre></td></tr></table></figure><h4 id="27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？"><a href="#27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？" class="headerlink" title="27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？"></a>27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒</span><br><span class="line">子的区域，也是浮动元素与其他元素的交互限定区域。</span><br><span class="line"></span><br><span class="line">通俗来讲</span><br><span class="line"></span><br><span class="line">•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</span><br><span class="line">•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</span><br><span class="line"></span><br><span class="line">创建BFC</span><br><span class="line"></span><br><span class="line">（1）根元素或包含根元素的元素</span><br><span class="line">（2）浮动元素float＝left|right或inherit（≠none）</span><br><span class="line">（3）绝对定位元素position＝absolute或fixed</span><br><span class="line">（4）display＝inline-block|flex|inline-flex|table-cell或table-caption</span><br><span class="line">（5）overflow＝hidden|auto或scroll(≠visible)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也</span><br><span class="line">不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</span><br><span class="line"></span><br><span class="line">一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些</span><br><span class="line">属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">《深入理解 BFC 和 MarginCollapse》</a><br><a href="https://segmentfault.com/a/1190000013647777">《前端面试题-BFC（块格式化上下文）》</a></p><h4 id="28-IFC-是什么？"><a href="#28-IFC-是什么？" class="headerlink" title="28.IFC 是什么？"></a>28.IFC 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IFC指的是行级格式化上下文，它有这样的一些布局规则：</span><br><span class="line"></span><br><span class="line">（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</span><br><span class="line">（2）当一行不够的时候会自动切换到下一行。</span><br><span class="line">（3）行级上下文的高度由内部最高的内联盒子的高度决定。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/paintandraw/article/details/80401741">《BFC 和 IFC 的理解（布局）》</a></p><h4 id="29-请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#29-请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="29.请解释一下为什么需要清除浮动？清除浮动的方式"></a>29.请解释一下为什么需要清除浮动？清除浮动的方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，</span><br><span class="line">不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框</span><br><span class="line">的高度小于浮动框的时候，此时就会出现“高度塌陷”。</span><br><span class="line"></span><br><span class="line">清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</span><br><span class="line"></span><br><span class="line">清除浮动的方式</span><br><span class="line"></span><br><span class="line">（1）使用clear属性清除浮动。参考28。</span><br><span class="line"></span><br><span class="line">（2）使用BFC块级格式化上下文来清除浮动。参考26。</span><br><span class="line"></span><br><span class="line">因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元</span><br><span class="line">素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。</span><br></pre></td></tr></table></figure><h4 id="30-使用-clear-属性清除浮动的原理？"><a href="#30-使用-clear-属性清除浮动的原理？" class="headerlink" title="30.使用 clear 属性清除浮动的原理？"></a>30.使用 clear 属性清除浮动的原理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">使用clear属性清除浮动，其语法如下：</span><br><span class="line"></span><br><span class="line">clear:none|left|right|both</span><br><span class="line"></span><br><span class="line">如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问</span><br><span class="line">题的，因为浮动一直还在，并没有清除。</span><br><span class="line"></span><br><span class="line">官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素</span><br><span class="line">对该元素的影响，而不是清除掉浮动。</span><br><span class="line"></span><br><span class="line">还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属</span><br><span class="line">性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear</span><br><span class="line">属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left</span><br><span class="line">等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和cle</span><br><span class="line">ar:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</span><br><span class="line"></span><br><span class="line">一般使用伪元素的方式清除浮动</span><br><span class="line"></span><br><span class="line">.clear::after&#123;</span><br><span class="line">content:&#x27;&#x27;;</span><br><span class="line">display:table;//也可以是&#x27;block&#x27;，或者是&#x27;list-item&#x27;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置disp</span><br><span class="line">lay属性值的原因。</span><br></pre></td></tr></table></figure><h4 id="31-zoom-1-的清除浮动原理"><a href="#31-zoom-1-的清除浮动原理" class="headerlink" title="31.zoom:1 的清除浮动原理?"></a>31.zoom:1 的清除浮动原理?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">清除浮动，触发hasLayout；</span><br><span class="line">zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）</span><br><span class="line">的重叠，浮动清除，触发ie的haslayout属性等。</span><br><span class="line"></span><br><span class="line">来龙去脉大概如下：</span><br><span class="line">当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发</span><br><span class="line">生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</span><br><span class="line"></span><br><span class="line">zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标</span><br><span class="line">准化，出现在CSS3.0规范草案中。</span><br><span class="line"></span><br><span class="line">目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。</span><br></pre></td></tr></table></figure><h4 id="32-移动端的布局用过媒体查询吗？"><a href="#32-移动端的布局用过媒体查询吗？" class="headerlink" title="32.移动端的布局用过媒体查询吗？"></a>32.移动端的布局用过媒体查询吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些</span><br><span class="line">媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</span><br><span class="line"></span><br><span class="line">当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被</span><br><span class="line">下载（只不过不会被应用）。</span><br><span class="line"></span><br><span class="line">包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改</span><br><span class="line">内容便可以使样式应用于某些特定的设备范围。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html">《CSS3@media 查询》</a><br><a href="http://caibaojian.com/356.html">《响应式布局和自适应布局详解》</a></p><h4 id="33-使用-CSS-预处理器吗？喜欢哪个？"><a href="#33-使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="33.使用 CSS 预处理器吗？喜欢哪个？"></a>33.使用 CSS 预处理器吗？喜欢哪个？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS）</span><br></pre></td></tr></table></figure><h4 id="34-CSS-优化、提高性能的方法有哪些？"><a href="#34-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="34.CSS 优化、提高性能的方法有哪些？"></a>34.CSS 优化、提高性能的方法有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">加载性能：</span><br><span class="line"></span><br><span class="line">（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。</span><br><span class="line">（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bot</span><br><span class="line">tom;margin-left:left;执行的效率更高。</span><br><span class="line">（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</span><br><span class="line"></span><br><span class="line">选择器性能：</span><br><span class="line"></span><br><span class="line">（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到</span><br><span class="line">左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</span><br><span class="line"></span><br><span class="line">（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹</span><br><span class="line">配它们了）。</span><br><span class="line"></span><br><span class="line">（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。</span><br><span class="line"></span><br><span class="line">（4）尽量少的去对标签进行选择，而是用class。</span><br><span class="line"></span><br><span class="line">（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过</span><br><span class="line">三层，更多的使用类来关联每一个标签元素。</span><br><span class="line"></span><br><span class="line">（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</span><br><span class="line"></span><br><span class="line">渲染性能：</span><br><span class="line"></span><br><span class="line">（1）慎重使用高性能属性：浮动、定位。</span><br><span class="line"></span><br><span class="line">（2）尽量减少页面重排、重绘。</span><br><span class="line"></span><br><span class="line">（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</span><br><span class="line"></span><br><span class="line">（4）属性值为0时，不加单位。</span><br><span class="line"></span><br><span class="line">（5）属性值为浮动小数0.**，可以省略小数点之前的0。</span><br><span class="line"></span><br><span class="line">（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</span><br><span class="line"></span><br><span class="line">（7）不使用@import前缀，它会影响css的加载速度。</span><br><span class="line"></span><br><span class="line">（8）选择器优化嵌套，尽量避免层级过深。</span><br><span class="line"></span><br><span class="line">（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清</span><br><span class="line">楚，再使用。</span><br><span class="line"></span><br><span class="line">（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</span><br><span class="line"></span><br><span class="line">（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏</span><br><span class="line">览器在下载web fonts时会阻塞页面渲染损伤性能。</span><br><span class="line"></span><br><span class="line">可维护性、健壮性：</span><br><span class="line"></span><br><span class="line">（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</span><br><span class="line">（2）样式与内容分离：将css代码定义到外部css中。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19886806">《CSS 优化、提高性能的方法有哪些？》</a><br><a href="https://www.jianshu.com/p/4e673bf24a3b">《CSS 优化，提高性能的方法》</a></p><h4 id="35-浏览器是怎样解析-CSS-选择器的？"><a href="#35-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="35.浏览器是怎样解析 CSS 选择器的？"></a>35.浏览器是怎样解析 CSS 选择器的？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直</span><br><span class="line">到和规则匹配，或者是因为不匹配而放弃该规则。</span><br><span class="line"></span><br><span class="line">试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，</span><br><span class="line">最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5a123c55f265da432240cc90">《探究 CSS 解析原理》</a></p><h4 id="36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="36.在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>36.在网页中应该使用奇数还是偶数的字体？为什么呢？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14</span><br><span class="line">×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。</span><br><span class="line">（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。</span><br><span class="line">（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jian_xi/article/details/79346477">《谈谈网页中使用奇数字体和偶数字体》</a><br><a href="https://www.zhihu.com/question/20440679">《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》</a></p><h4 id="37-margin-和-padding-分别适合什么场景使用？"><a href="#37-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="37.margin 和 padding 分别适合什么场景使用？"></a>37.margin 和 padding 分别适合什么场景使用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。</span><br><span class="line">margin用于布局分开元素使元素与元素互不相干。</span><br><span class="line">padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</span><br><span class="line"></span><br><span class="line">何时应当使用margin：</span><br><span class="line">•需要在border外侧添加空白时。</span><br><span class="line">•空白处不需要背景（色）时。</span><br><span class="line">•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</span><br><span class="line"></span><br><span class="line">何时应当时用padding：</span><br><span class="line">•需要在border内测添加空白时。</span><br><span class="line">•空白处需要背景（色）时。</span><br><span class="line">•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</span><br></pre></td></tr></table></figure><h4 id="38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题"><a href="#38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题" class="headerlink" title="38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]"></a>38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放</span><br><span class="line">进业务相关的库里面做成对应功能的模块儿。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://nec.netease.com/standard/css-sort.html">《CSS 规范-分类方法》</a></p><h4 id="39-简单说一下-css3-的-all-属性"><a href="#39-简单说一下-css3-的-all-属性" class="headerlink" title="39.简单说一下 css3 的 all 属性"></a>39.简单说一下 css3 的 all 属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction</span><br><span class="line">这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</span><br><span class="line"></span><br><span class="line">initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始</span><br><span class="line">值。</span><br><span class="line"></span><br><span class="line">inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</span><br><span class="line"></span><br><span class="line">unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则</span><br><span class="line">使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/">《简单了解 CSS3 的 all 属性》</a></p><h4 id="40-为什么不建议使用统配符初始化-css-样式"><a href="#40-为什么不建议使用统配符初始化-css-样式" class="headerlink" title="40.为什么不建议使用统配符初始化 css 样式"></a>40.为什么不建议使用统配符初始化 css 样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">采用*&#123;padding:0;margin:0;&#125;这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，</span><br><span class="line">样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一</span><br><span class="line">套初始化样式。</span><br><span class="line"></span><br><span class="line">出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即</span><br><span class="line">可，并不需使用通配符*来初始化。</span><br></pre></td></tr></table></figure><h4 id="41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）内联元素也可以作为“包含块”所在的元素；</span><br><span class="line"></span><br><span class="line">（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</span><br><span class="line"></span><br><span class="line">（3）边界是padding box而不是content box。</span><br></pre></td></tr></table></figure><h4 id="42-对于-hasLayout-的理解？"><a href="#42-对于-hasLayout-的理解？" class="headerlink" title="42.对于 hasLayout 的理解？"></a>42.对于 hasLayout 的理解？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进</span><br><span class="line">行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可</span><br><span class="line">能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完</span><br><span class="line">成这些工作。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000010883974">《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》</a><br><a href="https://segmentfault.com/a/1190000004632071">《CSS 魔法堂：hasLayout 原来是这样的！》</a></p><h4 id="43-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#43-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="43.元素竖向的百分比设定是相对于容器的高度吗？"></a>43.元素竖向的百分比设定是相对于容器的高度吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果是height的话，是相对于包含块的高度。</span><br><span class="line"></span><br><span class="line">如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</span><br></pre></td></tr></table></figure><h4 id="44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）"><a href="#44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）" class="headerlink" title="44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）"></a>44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容</span><br><span class="line">器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全</span><br><span class="line">屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。</span><br><span class="line"></span><br><span class="line">overflow：hidden；transition：all 1000 ms ease；</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/liona_koukou/article/details/52680409">《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》</a><br><a href="https://juejin.im/post/5aeef41cf265da0ba0630de0">《用 ES6 写全屏滚动插件》</a></p><h4 id="45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）"><a href="#45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）" class="headerlink" title="45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）"></a>45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏</span><br><span class="line">幕尺寸做处理。页面头部必须有meta声明的viewport。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/dreamerframework/article/details/8994741">《响应式布局原理》</a><br><a href="http://www.mahaixiang.cn/wzsj/278.html">《响应式布局的实现方法和原理》</a></p><h4 id="46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"><a href="#46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）" class="headerlink" title="46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"></a>46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20990029">《如何实现视差滚动效果的网页？》</a></p><h4 id="47-如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#47-如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="47.如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的in</span><br><span class="line">put表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">background-color:rgb(250,255,189)!important;</span><br><span class="line">background-image:none!important;</span><br><span class="line">color:rgb(0,0,0)!important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是</span><br><span class="line">其他属性可使用。</span><br><span class="line"></span><br><span class="line">使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</span><br><span class="line"></span><br><span class="line">input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;</span><br><span class="line">-webkit-box-shadow:000px 1000px white inset;</span><br><span class="line">border:1px solid #CCC !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/zsl_955200/article/details/78276209">《去掉 chrome 记住密码后的默认填充样式》</a><br><a href="https://blog.csdn.net/M_agician/article/details/73381706">《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》</a></p><h4 id="48-怎么让-Chrome-支持小于-12px-的文字？"><a href="#48-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="48.怎么让 Chrome 支持小于 12px 的文字？"></a>48.怎么让 Chrome 支持小于 12px 的文字？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size</span><br><span class="line">-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器</span><br><span class="line">已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</span><br><span class="line"></span><br><span class="line">（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.</span><br><span class="line">75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/</span><br><span class="line">inline-block/...；</span><br><span class="line"></span><br><span class="line">（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://570109268.iteye.com/blog/2406562">《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》</a></p><h4 id="49-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#49-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="49.让页面里的字体变清晰，变细用 CSS 怎么做？"></a>49.让页面里的字体变清晰，变细用 CSS 怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</span><br><span class="line"></span><br><span class="line">在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</span><br><span class="line">置后无效。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/huo_bao/article/details/50251585">《让字体变的更清晰 CSS 中-webkit-font-smoothing》</a></p><h4 id="50-font-style-属性中-italic-和-oblique-的区别？"><a href="#50-font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="50.font-style 属性中 italic 和 oblique 的区别？"></a>50.font-style 属性中 italic 和 oblique 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">italic和oblique这两个关键字都表示“斜体”的意思。</span><br><span class="line"></span><br><span class="line">它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，</span><br><span class="line">则退而求其次，解析为oblique，也就是单纯形状倾斜。</span><br></pre></td></tr></table></figure><h4 id="51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</span><br><span class="line"></span><br><span class="line">css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相</span><br><span class="line">对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</span><br><span class="line"></span><br><span class="line">dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr</span><br><span class="line">为2。屏幕的缩放会改变dpr的值。</span><br><span class="line"></span><br><span class="line">ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/libin-1/p/7148377.html">《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》</a><br><a href="https://www.jianshu.com/p/af6dad66e49a">《前端工程师需要明白的「像素」》</a><br><a href="https://github.com/jawil/blog/issues/21">《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》</a><br><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15">《前端开发中像素的概念》</a></p><h4 id="52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="52.layout viewport、visual viewport 和 ideal viewport 的区别？"></a>52.layout viewport、visual viewport 和 ideal viewport 的区别？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定</span><br><span class="line">默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。</span><br><span class="line">ppk把这个浏览器默认的viewport叫做layout viewport。</span><br><span class="line"></span><br><span class="line">layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把</span><br><span class="line">这个viewport叫做visual viewport。</span><br><span class="line"></span><br><span class="line">ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元</span><br><span class="line">素的宽度设为ideal viewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。i</span><br><span class="line">deal viewport的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也</span><br><span class="line">不需要出现横向滚动条，都可以完美的呈现给用户。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">移动端一共需要理解三个viewport的概念的理解。</span><br><span class="line"></span><br><span class="line">第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整</span><br><span class="line">个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展</span><br><span class="line">示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</span><br><span class="line"></span><br><span class="line">第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu</span><br><span class="line">al viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口</span><br><span class="line">中的网页内容。</span><br><span class="line"></span><br><span class="line">第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才</span><br><span class="line">能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在</span><br><span class="line">不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个</span><br><span class="line">宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/2050/p/3877280.html">《移动前端开发之 viewport 的深入理解》</a><br><a href="https://www.html.cn/archives/5975">《说说移动前端中 viewport（视口）》</a><br><a href="https://juejin.im/post/5b6d21daf265da0f9d1a2ed7#heading-14">《移动端适配知识你到底知多少》</a></p><h4 id="53-position-fixed-在-android-下无效怎么处理？"><a href="#53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="53.position:fixed;在 android 下无效怎么处理？"></a>53.position:fixed;在 android 下无效怎么处理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕</span><br><span class="line">的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的</span><br><span class="line">，所以会出现感觉fixed无效的情况。</span><br><span class="line"></span><br><span class="line">如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</span><br><span class="line"></span><br><span class="line">&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-sca</span><br><span class="line">le=1.0,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</span><br></pre></td></tr></table></figure><h4 id="55-如何让去除-inline-block-元素间间距？"><a href="#55-如何让去除-inline-block-元素间间距？" class="headerlink" title="55.如何让去除 inline-block 元素间间距？"></a>55.如何让去除 inline-block 元素间间距？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">《去除 inline-block 元素间间距的 N 种方法》</a></p><h4 id="56-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#56-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="56.overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>56.overflow:scroll 时不能平滑滚动的问题怎么处理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流</span><br><span class="line">畅。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/1f4693d0ad2d">《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》</a></p><h4 id="57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度"><a href="#57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度" class="headerlink" title="57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度"></a>57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;</span><br><span class="line">left:0;right:0;</span><br><span class="line"></span><br><span class="line">（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/xutongbao/article/details/79408522">《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》</a></p><h4 id="58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常</span><br><span class="line">具有较大的文件大小。</span><br><span class="line"></span><br><span class="line">（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具</span><br><span class="line">有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积</span><br><span class="line">较小的场景。</span><br><span class="line"></span><br><span class="line">（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来</span><br><span class="line">存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，</span><br><span class="line">又会导致图片文件较GIF更大。</span><br><span class="line"></span><br><span class="line">（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的</span><br><span class="line">情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8</span><br><span class="line">还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。</span><br><span class="line"></span><br><span class="line">（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格</span><br><span class="line">式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</span><br><span class="line"></span><br><span class="line">（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图</span><br><span class="line">片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企</span><br><span class="line">业Logo、Icon等。</span><br><span class="line"></span><br><span class="line">（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是</span><br><span class="line">为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，</span><br><span class="line">如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</span><br><span class="line"></span><br><span class="line">•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</span><br><span class="line">•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</span><br><span class="line">•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</span><br><span class="line"></span><br><span class="line">但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">我了解到的一共有七种常见的图片的格式。</span><br><span class="line"></span><br><span class="line">（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比</span><br><span class="line">较大。</span><br><span class="line"></span><br><span class="line">（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还</span><br><span class="line">支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</span><br><span class="line"></span><br><span class="line">（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但</span><br><span class="line">由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</span><br><span class="line"></span><br><span class="line">（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并</span><br><span class="line">且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</span><br><span class="line"></span><br><span class="line">（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP</span><br><span class="line">格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</span><br><span class="line"></span><br><span class="line">（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般</span><br><span class="line">适合于用来制作一些网站logo或者图标之类的图片。</span><br><span class="line"></span><br><span class="line">（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相</span><br><span class="line">同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，</span><br><span class="line">这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/xinzhao/p/5130410.html">《图片格式那么多，哪种更适合你？》</a></p><h4 id="59-浏览器如何判断是否支持-webp-格式图片"><a href="#59-浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="59.浏览器如何判断是否支持 webp 格式图片"></a>59.浏览器如何判断是否支持 webp 格式图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如</span><br><span class="line">果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格</span><br><span class="line">式的图片。</span><br><span class="line"></span><br><span class="line">（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断</span><br><span class="line">返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jesslu/article/details/82495061">《判断浏览器是否支持 WebP 图片》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">《toDataURL()》</a></p><h4 id="60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</span><br><span class="line"></span><br><span class="line">如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开</span><br><span class="line">，静态资源放CDN。</span><br><span class="line"></span><br><span class="line">因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请</span><br><span class="line">求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</span><br><span class="line"></span><br><span class="line">同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的</span><br><span class="line">http请求的解析速度。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h4 id="61-style-标签写在-body-后与-body-前有什么区别？"><a href="#61-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="61.style 标签写在 body 后与 body 前有什么区别？"></a>61.style 标签写在 body 后与 body 前有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式</span><br><span class="line">表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可</span><br><span class="line">能会出现FOUC现象（即样式失效导致的页面闪烁问题）</span><br></pre></td></tr></table></figure><h4 id="62-什么是-CSS-预处理器-后处理器？"><a href="#62-什么是-CSS-预处理器-后处理器？" class="headerlink" title="62.什么是 CSS 预处理器/后处理器？"></a>62.什么是 CSS 预处理器/后处理器？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成</span><br><span class="line">文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然</span><br><span class="line">后再编译成正常的CSS文件。</span><br><span class="line"></span><br><span class="line">预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、</span><br><span class="line">变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</span><br><span class="line"></span><br><span class="line">CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后</span><br><span class="line">处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，</span><br><span class="line">以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</span><br><span class="line"></span><br><span class="line">后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏</span><br><span class="line">览器私有前缀，实现跨浏览器兼容性的问题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/yushuangyushuang/article/details/79209752">《CSS 预处理器和后处理器》</a></p><h4 id="63-阐述一下-CSSSprites"><a href="#63-阐述一下-CSSSprites" class="headerlink" title="63.阐述一下 CSSSprites"></a>63.阐述一下 CSSSprites</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background</span><br><span class="line">-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites</span><br><span class="line">能减少图片的字节。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">减少HTTP请求数，极大地提高页面加载速度</span><br><span class="line">增加图片信息重复度，提高压缩比，减少图片大小</span><br><span class="line">更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">图片合并麻烦</span><br><span class="line">维护麻烦，修改一个图片可能需要重新布局整个图片，样式</span><br></pre></td></tr></table></figure><h4 id="64-使用-rem-布局的优缺点？"><a href="#64-使用-rem-布局的优缺点？" class="headerlink" title="64.使用 rem 布局的优缺点？"></a>64.使用 rem 布局的优缺点？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。</span><br><span class="line">而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。</span><br><span class="line">（2）使用iframe引用也会出现问题。</span><br><span class="line">（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问</span><br><span class="line">题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21504656">《css3 的字体大小单位 rem 到底好在哪？》</a><br><a href="https://www.jianshu.com/p/e8ae1c3861dc">《VW:是时候放弃 REM 布局了》</a><br><a href="https://blog.csdn.net/Honeymao/article/details/76795089">《为什么设计稿是 750px》</a><br><a href="https://github.com/amfe/article/issues/17">《使用 Flexible 实现手淘 H5 页面的终端适配》</a></p><h4 id="65-几种常见的-CSS-布局"><a href="#65-几种常见的-CSS-布局" class="headerlink" title="65.几种常见的 CSS 布局"></a>65.几种常见的 CSS 布局</h4><p>详细的资料可以参考：<br><a href="https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12">《几种常见的 CSS 布局》</a></p><h4 id="66-画一条-0-5px-的线"><a href="#66-画一条-0-5px-的线" class="headerlink" title="66.画一条 0.5px 的线"></a>66.画一条 0.5px 的线</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用meta viewport的方式</span><br><span class="line"></span><br><span class="line">采用border-image的方式</span><br><span class="line"></span><br><span class="line">采用transform:scale()的方式</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab65f40f265da2384408a95">《怎么画一条 0.5px 的边（更新）》</a></p><h4 id="67-transition-和-animation-的区别"><a href="#67-transition-和-animation-的区别" class="headerlink" title="67.transition 和 animation 的区别"></a>67.transition 和 animation 的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</span><br><span class="line"></span><br><span class="line">animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19749045">《CSSanimation 与 CSStransition 有何区别？》</a><br><a href="https://blog.csdn.net/cddcj/article/details/53582334">《CSS3Transition 和 Animation 区别及比较》</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">《CSS 动画简介》</a><br><a href="https://juejin.im/post/5b137e6e51882513ac201dfb">《CSS 动画：animation、transition、transform、translate》</a></p><h4 id="68-什么是首选最小宽度？"><a href="#68-什么是首选最小宽度？" class="headerlink" title="68.什么是首选最小宽度？"></a>68.什么是首选最小宽度？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“首选最小宽度”，指的是元素最适合的最小宽度。</span><br><span class="line"></span><br><span class="line">东亚文字（如中文）最小宽度为每个汉字的宽度。</span><br><span class="line"></span><br><span class="line">西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短</span><br><span class="line">横线、问号以及其他非英文字符等。</span><br><span class="line"></span><br><span class="line">如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</span><br></pre></td></tr></table></figure><h4 id="69-为什么-height-100-会无效？"><a href="#69-为什么-height-100-会无效？" class="headerlink" title="69.为什么 height:100%会无效？"></a>69.为什么 height:100%会无效？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</span><br><span class="line"></span><br><span class="line">原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，</span><br><span class="line">所以无法参与计算。</span><br><span class="line"></span><br><span class="line">使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</span><br></pre></td></tr></table></figure><h4 id="70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</span><br><span class="line"></span><br><span class="line">（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</span><br></pre></td></tr></table></figure><h4 id="71-内联盒模型基本概念"><a href="#71-内联盒模型基本概念" class="headerlink" title="71.内联盒模型基本概念"></a>71.内联盒模型基本概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子</span><br><span class="line">（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些</span><br><span class="line">元素，内容区域可以看成元素自身。</span><br><span class="line"></span><br><span class="line">（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒</span><br><span class="line">子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</span><br><span class="line"></span><br><span class="line">（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</span><br><span class="line"></span><br><span class="line">（4）包含块（containing box），由一行一行的“行框盒子”组成。</span><br></pre></td></tr></table></figure><h4 id="72-什么是幽灵空白节点？"><a href="#72-什么是幽灵空白节点？" class="headerlink" title="72.什么是幽灵空白节点？"></a>72.什么是幽灵空白节点？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同</span><br><span class="line">每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵</span><br><span class="line">一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</span><br></pre></td></tr></table></figure><h4 id="73-什么是替换元素？"><a href="#73-什么是替换元素？" class="headerlink" title="73.什么是替换元素？"></a>73.什么是替换元素？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表</span><br><span class="line">单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。</span><br><span class="line"></span><br><span class="line">替换元素除了内容可替换这一特性以外，还有以下一些特性。</span><br><span class="line"></span><br><span class="line">（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要</span><br><span class="line">类似appearance属性，或者浏览器自身暴露的一些样式接口，</span><br><span class="line"></span><br><span class="line">（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像</span><br><span class="line">素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素</span><br><span class="line">的尺寸则和浏览器有关，没有明显的规律。</span><br><span class="line"></span><br><span class="line">（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve</span><br><span class="line">rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，</span><br><span class="line">被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</span><br><span class="line"></span><br><span class="line">（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认</span><br><span class="line">的display值却是不一样的，有的是inline，有的是inline-block。</span><br></pre></td></tr></table></figure><h4 id="74-替换元素的计算规则？"><a href="#74-替换元素的计算规则？" class="headerlink" title="74.替换元素的计算规则？"></a>74.替换元素的计算规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</span><br><span class="line"></span><br><span class="line">（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</span><br><span class="line"></span><br><span class="line">（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的s</span><br><span class="line">ize属性、&lt;textarea&gt;的cols和rows属性等。</span><br><span class="line"></span><br><span class="line">（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的</span><br><span class="line">尺寸，对应盒尺寸中的content box。</span><br><span class="line"></span><br><span class="line">这3层结构的计算规则具体如下</span><br><span class="line"></span><br><span class="line">（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</span><br><span class="line"></span><br><span class="line">（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</span><br><span class="line"></span><br><span class="line">（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</span><br><span class="line"></span><br><span class="line">（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</span><br><span class="line"></span><br><span class="line">（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</span><br><span class="line"></span><br><span class="line">（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</span><br></pre></td></tr></table></figure><h4 id="75-content-与替换元素的关系？"><a href="#75-content-与替换元素的关系？" class="headerlink" title="75.content 与替换元素的关系？"></a>75.content 与替换元素的关系？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">content属性生成的对象称为“匿名替换元素”。</span><br><span class="line"></span><br><span class="line">（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本</span><br><span class="line">却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是</span><br><span class="line">地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</span><br><span class="line"></span><br><span class="line">（2）content生成的内容不能左右:empty伪类。</span><br><span class="line"></span><br><span class="line">（3）content动态生成值无法获取。</span><br></pre></td></tr></table></figure><h4 id="76-margin-auto-的填充规则？"><a href="#76-margin-auto-的填充规则？" class="headerlink" title="76.margin:auto 的填充规则？"></a>76.margin:auto 的填充规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">margin的&#x27;auto&#x27;可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar</span><br><span class="line">gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</span><br><span class="line"></span><br><span class="line">（1）如果一侧定值，一侧auto，则auto为剩余空间大小。</span><br><span class="line">（2）如果两侧均是auto，则平分剩余空间。</span><br></pre></td></tr></table></figure><h4 id="77-margin-无效的情形"><a href="#77-margin-无效的情形" class="headerlink" title="77.margin 无效的情形"></a>77.margin 无效的情形</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma</span><br><span class="line">rgin合并的问题。</span><br><span class="line"></span><br><span class="line">（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</span><br><span class="line"></span><br><span class="line">（3）绝对定位元素非定位方位的margin值“无效”。</span><br><span class="line"></span><br><span class="line">（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</span><br></pre></td></tr></table></figure><h4 id="78-border-的特殊性？"><a href="#78-border-的特殊性？" class="headerlink" title="78.border 的特殊性？"></a>78.border 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）border-width却不支持百分比。</span><br><span class="line"></span><br><span class="line">（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col</span><br><span class="line">or没有边框显示的原因。</span><br><span class="line"></span><br><span class="line">（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</span><br><span class="line"></span><br><span class="line">（4）border-color默认颜色就是color色值。</span><br><span class="line"></span><br><span class="line">（5）默认background背景图片是相对于padding box定位的。</span><br></pre></td></tr></table></figure><h4 id="79-什么是基线和-x-height？"><a href="#79-什么是基线和-x-height？" class="headerlink" title="79.什么是基线和 x-height？"></a>79.什么是基线和 x-height？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字母x的下边缘（线）就是我们的基线。</span><br><span class="line"></span><br><span class="line">x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C</span><br><span class="line">SS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。</span><br><span class="line"></span><br><span class="line">ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影</span><br><span class="line">响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</span><br></pre></td></tr></table></figure><h4 id="80-line-height-的特殊性？"><a href="#80-line-height-的特殊性？" class="headerlink" title="80.line-height 的特殊性？"></a>80.line-height 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高</span><br><span class="line">度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</span><br><span class="line"></span><br><span class="line">（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作</span><br><span class="line">用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是</span><br><span class="line">有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</span><br><span class="line"></span><br><span class="line">（3）行距=line-height-font-size。</span><br><span class="line"></span><br><span class="line">（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下</span><br><span class="line">边距，则向上取整。</span><br><span class="line"></span><br><span class="line">（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</span><br><span class="line"></span><br><span class="line">（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是</span><br><span class="line">通过改变块级元素里面内联级别元素占据的高度实现的。</span><br><span class="line"></span><br><span class="line">（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si</span><br><span class="line">ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</span><br><span class="line"></span><br><span class="line">（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为</span><br><span class="line">属性值，那么所有的子元素继承的是最终的计算值。</span><br><span class="line"></span><br><span class="line">（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</span><br><span class="line"></span><br><span class="line">（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个</span><br><span class="line">“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</span><br></pre></td></tr></table></figure><h4 id="81-vertical-align-的特殊性？"><a href="#81-vertical-align-的特殊性？" class="headerlink" title="81.vertical-align 的特殊性？"></a>81.vertical-align 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字</span><br><span class="line">母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面</span><br><span class="line">没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行</span><br><span class="line">内联元素的基线。</span><br><span class="line"></span><br><span class="line">（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display</span><br><span class="line">计算值是table-cell的元素，我们不妨脑补成&lt;td&gt;元素，则和&lt;tr&gt;元素上边缘对齐。</span><br><span class="line"></span><br><span class="line">（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对</span><br><span class="line">于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</span><br><span class="line"></span><br><span class="line">（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上</span><br><span class="line">偏移。</span><br><span class="line"></span><br><span class="line">（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</span><br><span class="line"></span><br><span class="line">（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元</span><br><span class="line">素。</span><br><span class="line"></span><br><span class="line">（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</span><br></pre></td></tr></table></figure><h4 id="82-overflow-的特殊性？"><a href="#82-overflow-的特殊性？" class="headerlink" title="82.overflow 的特殊性？"></a>82.overflow 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度</span><br><span class="line">高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</span><br><span class="line"></span><br><span class="line">（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素&lt;html&gt;，另一个是文本域&lt;textarea&gt;。</span><br><span class="line"></span><br><span class="line">（3）滚动条会占用容器的可用宽度或高度。</span><br><span class="line"></span><br><span class="line">（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</span><br></pre></td></tr></table></figure><h4 id="83-无依赖绝对定位是什么？"><a href="#83-无依赖绝对定位是什么？" class="headerlink" title="83.无依赖绝对定位是什么？"></a>83.无依赖绝对定位是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。</span><br><span class="line"></span><br><span class="line">无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</span><br></pre></td></tr></table></figure><h4 id="84-absolute-与-overflow-的关系？"><a href="#84-absolute-与-overflow-的关系？" class="headerlink" title="84.absolute 与 overflow 的关系？"></a>84.absolute 与 overflow 的关系？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute</span><br><span class="line">元素进行剪裁。</span><br><span class="line"></span><br><span class="line">（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也</span><br><span class="line">都不会出现滚动条。</span><br><span class="line"></span><br><span class="line">（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</span><br></pre></td></tr></table></figure><h4 id="85-clip-裁剪是什么？"><a href="#85-clip-裁剪是什么？" class="headerlink" title="85.clip 裁剪是什么？"></a>85.clip 裁剪是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</span><br><span class="line"></span><br><span class="line">clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</span><br></pre></td></tr></table></figure><h4 id="86-relative-的特殊性？"><a href="#86-relative-的特殊性？" class="headerlink" title="86.relative 的特殊性？"></a>86.relative 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</span><br><span class="line"></span><br><span class="line">（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</span><br><span class="line"></span><br><span class="line">（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</span><br></pre></td></tr></table></figure><h4 id="87-什么是层叠上下文？"><a href="#87-什么是层叠上下文？" class="headerlink" title="87.什么是层叠上下文？"></a>87.什么是层叠上下文？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元</span><br><span class="line">素在z轴上就“高人一等”。</span><br><span class="line"></span><br><span class="line">层叠上下文元素有如下特性：</span><br><span class="line"></span><br><span class="line">（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。</span><br><span class="line">（2）层叠上下文可以阻断元素的混合模式。</span><br><span class="line">（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</span><br><span class="line">（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</span><br><span class="line">（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">层叠上下文的创建：</span><br><span class="line"></span><br><span class="line">（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</span><br><span class="line"></span><br><span class="line">（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。</span><br><span class="line"></span><br><span class="line">（3）其他一些CSS3属性，比如元素的opacity值不是1。</span><br></pre></td></tr></table></figure><h4 id="88-什么是层叠水平？"><a href="#88-什么是层叠水平？" class="headerlink" title="88.什么是层叠水平？"></a>88.什么是层叠水平？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。</span><br><span class="line"></span><br><span class="line">显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上</span><br><span class="line">下文元素中。</span><br></pre></td></tr></table></figure><h4 id="89-元素的层叠顺序？"><a href="#89-元素的层叠顺序？" class="headerlink" title="89.元素的层叠顺序？"></a>89.元素的层叠顺序？</h4><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png" alt="层叠顺序"></p><h4 id="90-层叠准则？"><a href="#90-层叠准则？" class="headerlink" title="90.层叠准则？"></a>90.层叠准则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</span><br><span class="line"></span><br><span class="line">（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</span><br></pre></td></tr></table></figure><h4 id="91-font-weight-的特殊性？"><a href="#91-font-weight-的特殊性？" class="headerlink" title="91.font-weight 的特殊性？"></a>91.font-weight 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。</span><br></pre></td></tr></table></figure><h4 id="92-text-indent-的特殊性？"><a href="#92-text-indent-的特殊性？" class="headerlink" title="92.text-indent 的特殊性？"></a>92.text-indent 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）text-indent仅对第一行内联盒子内容有效。</span><br><span class="line"></span><br><span class="line">（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inli</span><br><span class="line">ne-table则会生效。</span><br><span class="line"></span><br><span class="line">（3）&lt;input&gt;标签按钮text-indent值无效。</span><br><span class="line"></span><br><span class="line">（4）&lt;button&gt;标签按钮text-indent值有效。</span><br><span class="line"></span><br><span class="line">（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</span><br></pre></td></tr></table></figure><h4 id="93-letter-spacing-与字符间距？"><a href="#93-letter-spacing-与字符间距？" class="headerlink" title="93.letter-spacing 与字符间距？"></a>93.letter-spacing 与字符间距？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</span><br><span class="line"></span><br><span class="line">letter-spacing具有以下一些特性。</span><br><span class="line"></span><br><span class="line">（1）继承性。</span><br><span class="line">（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。</span><br><span class="line">（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。</span><br><span class="line">（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。</span><br><span class="line">（5）支持小数值，即使0.1px也是支持的。</span><br><span class="line">（6）暂不支持百分比值。</span><br></pre></td></tr></table></figure><h4 id="94-word-spacing-与单词间距？"><a href="#94-word-spacing-与单词间距？" class="headerlink" title="94.word-spacing 与单词间距？"></a>94.word-spacing 与单词间距？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙</span><br><span class="line">宽度。</span><br></pre></td></tr></table></figure><h4 id="95-white-space-与换行和空格的控制？"><a href="#95-white-space-与换行和空格的控制？" class="headerlink" title="95.white-space 与换行和空格的控制？"></a>95.white-space 与换行和空格的控制？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）</span><br><span class="line">键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否</span><br><span class="line">生效）等。</span><br><span class="line"></span><br><span class="line">其属性值包括下面这些。</span><br><span class="line">•normal：合并空白字符和换行符。</span><br><span class="line">•pre：空白字符不合并，并且内容只在有换行符的地方换行。</span><br><span class="line">•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。</span><br><span class="line">•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。</span><br><span class="line">•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</span><br></pre></td></tr></table></figure><h4 id="96-隐藏元素的-background-image-到底加不加载？"><a href="#96-隐藏元素的-background-image-到底加不加载？" class="headerlink" title="96.隐藏元素的 background-image 到底加不加载？"></a>96.隐藏元素的 background-image 到底加不加载？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Fire</span><br><span class="line">fox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片</span><br><span class="line">依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使</span><br><span class="line">用的。</span><br><span class="line"></span><br><span class="line">如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。</span><br><span class="line"></span><br><span class="line">还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触</span><br><span class="line">发时加载。</span><br></pre></td></tr></table></figure><p>回答：</p><p>-（1）元素的背景图片</p><p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>-:hover 样式下，触发时请求</p><p>-（2）img 标签图片任何情况下都会请求图片</p><p>详细资料可以参考：<br><a href="https://www.jb51.net/css/469033.html">《CSS 控制前端图片 HTTP 请求的各种情况示例》</a></p><h4 id="97-如何实现单行／多行文本溢出的省略（…）？"><a href="#97-如何实现单行／多行文本溢出的省略（…）？" class="headerlink" title="97.如何实现单行／多行文本溢出的省略（…）？"></a>97.如何实现单行／多行文本溢出的省略（…）？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/30707916">《【CSS/JS】如何实现单行／多行文本溢出的省略》</a><br><a href="https://juejin.im/entry/587f453e1b69e60058555a5f">《CSS 多行文本溢出省略显示》</a></p><h4 id="98-常见的元素隐藏方式？"><a href="#98-常见的元素隐藏方式？" class="headerlink" title="98.常见的元素隐藏方式？"></a>98.常见的元素隐藏方式？</h4><p>-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p><p>-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p><p>-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p><p>-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p><p>-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</p><p>-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p><p>-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/584b645a128fe10058a0d625#heading-2">《CSS 隐藏元素的八种方法》</a></p><h4 id="99-css-实现上下固定中间自适应布局？"><a href="#99-css-实现上下固定中间自适应布局？" class="headerlink" title="99.css 实现上下固定中间自适应布局？"></a>99.css 实现上下固定中间自适应布局？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">利用绝对定位实现<span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用<span class="attribute">flex</span>布局实现<span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/30bc9751e3e8">《css 实现上下固定中间自适应布局》</a></p><h4 id="100-css-两栏布局的实现？"><a href="#100-css-两栏布局的实现？" class="headerlink" title="100.css 两栏布局的实现？"></a>100.css 两栏布局的实现？</h4><p>相关资料：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/</span></span><br><span class="line"><span class="comment">/*以左边宽度固定为200px为例*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="comment">/*11auto*/</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span></span><br><span class="line"><span class="comment">200px。将右边元素的margin-left的值设置为200px。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html">《两栏布局 demo 展示》</a></p><p>回答：</p><p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为 200px 为例</p><p>-（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</p><p>-（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。</p><p>-（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</p><p>-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p><h4 id="101-css-三栏布局的实现？"><a href="#101-css-三栏布局的实现？" class="headerlink" title="101.css 三栏布局的实现？"></a>101.css 三栏布局的实现？</h4><p>相关资料：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span></span><br><span class="line"><span class="comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">《三栏布局 demo 展示》</a></p><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span><br><span class="line"></span><br><span class="line">这里以左边宽度固定为100px，右边宽度固定为200px为例。</span><br><span class="line"></span><br><span class="line">（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</span><br><span class="line"></span><br><span class="line">（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</span><br><span class="line"></span><br><span class="line">（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</span><br><span class="line"></span><br><span class="line">（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。双飞翼布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</span><br><span class="line"></span><br><span class="line">（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</span><br></pre></td></tr></table></figure><h4 id="102-实现一个宽高自适应的正方形"><a href="#102-实现一个宽高自适应的正方形" class="headerlink" title="102.实现一个宽高自适应的正方形"></a>102.实现一个宽高自适应的正方形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.第一种方式是利用vw来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.第三种方式是利用子元素的margin-top的值来实现的*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html">《自适应正方形 demo 展示》</a></p><h4 id="103-实现一个三角形"><a href="#103-实现一个三角形" class="headerlink" title="103.实现一个三角形"></a>103.实现一个三角形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/</span></span><br><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: tomatotransparenttransparenttransparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/Triangle/index.html">《三角形 demo 展示》</a></p><h4 id="104-一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#104-一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="104.一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现原理参考自适应正方形和水平居中方式*/</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？"><a href="#105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？" class="headerlink" title="105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？"></a>105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">公式：当前元素某CSS属性值 = 基准 * 对应的百分比</span><br><span class="line">元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width</span><br><span class="line">元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width</span><br><span class="line">元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width</span><br><span class="line">元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）</span><br><span class="line">元素的 border-width，不支持百分比</span><br><span class="line">元素的 text-indent，基准为包含块的 width</span><br><span class="line"></span><br><span class="line">元素的 border-radius，基准为分别为自身的height、width</span><br><span class="line">元素的 background-size，基准为分别为自身的height、width</span><br><span class="line">元素的 translateX、translateY，基准为分别为自身的height、width</span><br><span class="line">元素的 line-height，基准为自身的 font-size</span><br><span class="line"></span><br><span class="line">元素的 font-size，基准为父元素字体</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;CSS-面试知识点总结&quot;&gt;&lt;a href=&quot;#CSS-面试知识点总结&quot; class=&quot;headerlink&quot; title=&quot;CSS 面试知识点总结&quot;&gt;&lt;/a&gt;CSS 面试知识点总结&lt;/h2&gt;&lt;p&gt;本部分主要是笔者在复习 CSS 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;</summary>
    
    
    
    <category term="CSS" scheme="https://qyjs.github.io/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://qyjs.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES2020 和 Typescript</title>
    <link href="https://qyjs.github.io/2020/12/21/ES2020-ts/"/>
    <id>https://qyjs.github.io/2020/12/21/ES2020-ts/</id>
    <published>2020-12-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES2020-和-Typescript"><a href="#ES2020-和-Typescript" class="headerlink" title="ES2020 和 Typescript"></a>ES2020 和 Typescript</h2><ul><li>?. 不是一个运算符，而是一个特殊的语法结构</li></ul><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><!-- - [常用工具知识总结](#常用工具知识总结)  - [目录](#目录)  - [GIT](#git)    - [1. git 与 svn 的区别在哪里？](#1-git-与-svn-的区别在哪里)    - [2. 经常使用的 git 命令？](#2-经常使用的-git-命令)    - [3. git pull 和 git fetch 的区别](#3-git-pull-和-git-fetch-的区别)    - [4. git rebase 和 git merge 的区别](#4-git-rebase-和-git-merge-的区别) --><h3 id="1-可选链-“-”"><a href="#1-可选链-“-”" class="headerlink" title="1. 可选链 “?.”"></a>1. 可选链 “?.”</h3><ul><li><p>可选链 ?. 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p></li><li><p>我们大多数用户的地址都存储在 user.address 中，街道地址存储在 user.address.street 中，但有些用户没有提供这些信息。</p></li><li><p>在这种情况下，当我们尝试获取 user.address.street，而该用户恰好没提供地址信息，我们则会收到一个错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">address</span>.<span class="property">street</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li><li><p>这是预期的结果。JavaScript 的工作原理就是这样的。因为 user.address 为 undefined，尝试读取 user.address.street 会失败，并收到一个错误。但是在很多实际场景中，我们更希望得到的是 undefined（表示没有 street 属性）而不是一个错误。</p></li><li><p>……还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 document.querySelector(‘.elem’)）以对象的形式获取一个网页元素，如果没有这种对象，则返回 null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则这里不存在这个元素</span></span><br><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.elem&quot;</span>).<span class="property">innerHTML</span>; <span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span></span><br></pre></td></tr></table></figure></li><li><p>最先想到的方案</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">address</span> ? user.<span class="property">address</span>.<span class="property">street</span> : <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"><span class="title function_">alert</span>(</span><br><span class="line">  user.<span class="property">address</span> ? (user.<span class="property">address</span>.<span class="property">street</span> ? user.<span class="property">address</span>.<span class="property">street</span>.<span class="property">name</span> : <span class="literal">null</span>) : <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">address</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span>.<span class="property">name</span>); <span class="comment">// undefined（不报错）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"><span class="title function_">alert</span>(user?.<span class="property">address</span>?.<span class="property">street</span>); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure><ul><li>即使 对象 user 不存在，使用 user?.address 来读取地址也没问题：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">alert</span>(user?.<span class="property">address</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">alert</span>(user?.<span class="property">address</span>.<span class="property">street</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>可选链 ?. 语法有三种形式：<ul><li>obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。</li><li>obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。</li><li>obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ES2020-和-Typescript&quot;&gt;&lt;a href=&quot;#ES2020-和-Typescript&quot; class=&quot;headerlink&quot; title=&quot;ES2020 和 Typescript&quot;&gt;&lt;/a&gt;ES2020 和 Typescript&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;?. 不是一个运算符，而是一个特殊的语法结构&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ES2020 和 Typescript" scheme="https://qyjs.github.io/categories/ES2020-%E5%92%8C-Typescript/"/>
    
    
    <category term="ES2020 和 Typescript" scheme="https://qyjs.github.io/tags/ES2020-%E5%92%8C-Typescript/"/>
    
  </entry>
  
  <entry>
    <title>前端小知识</title>
    <link href="https://qyjs.github.io/2020/11/20/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://qyjs.github.io/2020/11/20/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-20T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端小知识"><a href="#前端小知识" class="headerlink" title="前端小知识"></a>前端小知识</h2><ul><li>前端小知识</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="1-css-一行文本超出"><a href="#1-css-一行文本超出" class="headerlink" title="1.css 一行文本超出"></a>1.css 一行文本超出</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;</span><br></pre></td></tr></table></figure><h4 id="2-多行文本超出显示"><a href="#2-多行文本超出显示" class="headerlink" title="2.多行文本超出显示"></a>2.多行文本超出显示</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure><h4 id="3-IOS-手机容器滚动条滑动不流畅"><a href="#3-IOS-手机容器滚动条滑动不流畅" class="headerlink" title="3.IOS 手机容器滚动条滑动不流畅"></a>3.IOS 手机容器滚动条滑动不流畅</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: auto;</span><br><span class="line">-webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="4-修改滚动条样式"><a href="#4-修改滚动条样式" class="headerlink" title="4.修改滚动条样式"></a>4.修改滚动条样式</h4><ul><li>隐藏 div 元素的滚动条</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>div::-webkit-scrollbar 滚动条整体部分</li><li>div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条</li><li>div::-webkit-scrollbar-track 滚动条的轨道（里面装有 Thumb</li><li>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置</li><li>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去</li><li>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</li><li>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。</li></ul><h4 id="5-使用-css-写出一个三角形角标"><a href="#5-使用-css-写出一个三角形角标" class="headerlink" title="5.使用 css 写出一个三角形角标"></a>5.使用 css 写出一个三角形角标</h4><ul><li>元素宽高设置为 0，通过 border 属性来设置，让其它三个方向的 border 颜色为透明或者和背景色保持一致，剩余一条 border 的颜色设置为需要的颜色。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid #transparent;</span><br><span class="line">  <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-解决-ios-audio-无法自动播放、循环播放的问题"><a href="#6-解决-ios-audio-无法自动播放、循环播放的问题" class="headerlink" title="6.解决 ios audio 无法自动播放、循环播放的问题"></a>6.解决 ios audio 无法自动播放、循环播放的问题</h4><ul><li>ios 手机在使用 audio 或者 video 播放的时候，个别机型无法实现自动播放，可使用下面的代码 hack。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决ios audio无法自动播放、循环播放的问题</span></span><br><span class="line"><span class="keyword">var</span> music = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;touchstart&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">      music.<span class="title function_">play</span>();</span><br><span class="line">      state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;WeixinJSBridgeReady&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    music.<span class="title function_">play</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环播放</span></span><br><span class="line">music.<span class="property">onended</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  music.<span class="title function_">load</span>();</span><br><span class="line">  music.<span class="title function_">play</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-水平垂直居中"><a href="#7-水平垂直居中" class="headerlink" title="7.水平垂直居中"></a>7.水平垂直居中</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定位 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* flex */</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-隐藏页面元素"><a href="#8-隐藏页面元素" class="headerlink" title="8.隐藏页面元素"></a>8.隐藏页面元素</h4><ul><li>display-none: 元素不存在，从 dom 中删除</li><li>opacity-0: 元素透明度将为 0，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</li><li>visibility-hidden：元素隐藏，但元素仍旧存在，页面中无法触发该元素的事</li></ul><h4 id="9-前端工程化"><a href="#9-前端工程化" class="headerlink" title="9.前端工程化"></a>9.前端工程化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一提到前端工程化很多人想到的都是 webpack，这是不对的，webpack 仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。</span><br><span class="line"></span><br><span class="line">前端工程化是通过工具提升效率，降低成本的一种手段。</span><br><span class="line"></span><br><span class="line">近些年被广泛的关注和探讨，究其原因主要是因为现代化前端应用功能要求不断提高，业务逻辑日益复杂，作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半壁江山。从传统的网站，到现在的 <span class="variable constant_">H5</span>,移动 <span class="title class_">App</span>,桌面应用，以及小程序。前端技术几乎是无所不能的全面覆盖。</span><br><span class="line"></span><br><span class="line">在这些表象的背后呢，实际上是行业对开发人员的要求发生了天翻地覆的变化，以往前端写 demo，套模板，调页面这种刀耕火种的方式已经完全不符合当下对开发效率的要求，前端工程化就是在这样一个背景下被提上台面，成为前端工程师必备的手段之一。</span><br><span class="line"></span><br><span class="line">一般来说前端工程包含，项目初始化，项目开发，集成，构建，打包，测试，部署等流程。工程化就是以工程的角度来解决这些问题。比如项目初始化我们一般使用npm init, 创建页面模板使用 plop，我们喜欢使用 <span class="title class_">ES6</span>+开发，但是需要通过 babel 编码成 <span class="title class_">ES5</span>，持续集成的时候我们使用 git，但是为了保持开发规范我们引入了 <span class="title class_">ESLint</span>，部署一般使用 ci/cd 或者 jenkins 等等。</span><br></pre></td></tr></table></figure><h4 id="10-contenteditable"><a href="#10-contenteditable" class="headerlink" title="10.contenteditable"></a>10.contenteditable</h4><ul><li>html 中大部分标签都是不可以编辑的，但是添加了 contenteditable 属性之后，标签会变成可编辑状态。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="11-calc"><a href="#11-calc" class="headerlink" title="11.calc"></a>11.calc</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">25%</span> - <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-Proxy-和-Object-defineProperty-区别"><a href="#12-Proxy-和-Object-defineProperty-区别" class="headerlink" title="12.Proxy 和 Object.defineProperty 区别"></a>12.Proxy 和 Object.defineProperty 区别</h4><ul><li>Proxy 的意思是代理，我一般教他拦截器，可以拦截对象上的一个操作。用法如下，通过 new 的方式创建对象，第一个参数是被拦截的对象，第二个参数是对象操作的描述。实例化后返回一个新的对象，当我们对这个新的对象进行操作时就会调用我们描述中对应的方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Proxy 区别于 Object.definedProperty:<ul><li>Object.defineProperty 只能监听到属性的读写，而 Proxy 除读写外还可以监听属性的删除，方法的调用等。</li><li>通常情况下我们想要监视数组的变化，基本要依靠重写数组方法的方式实现，这也是 Vue 的实现方式，而 Proxy 可以直接监视数组的变化。</li><li>Proxy 是以非入侵的方式监管了对象的读写，而 defineProperty 需要按特定的方式定义对象的属性。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> listproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(list, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">    target[property] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 标识设置成功</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">push</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13.Reflect"></a>13.Reflect</h4><ul><li><p>他是 ES2015 新增的对象，纯静态对象也就是不能被实例画，只能通过静态方法的方式调用，和 Math 对象类似，只能类似 Math.random 的方式调用。</p></li><li><p>Reflect 内部封装了一系列对对象的底层操作，一共 14 个，其中 1 个被废弃，还剩下 13 个。</p></li><li><p>Reflect 的静态方法和 Proxy 描述中的方法完全一致。也就是说 Reflect 成员方法就是 Proxy 处理对象的默认实现。</p></li><li><p>Proxy 对象默认的方法就是调用了 Reflect 内部的处理逻辑，也就是如果我们调用 get 方法，那么在内部，proxy 就是将 get 原封不动的交给了 Reflect，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Reflect 和 Proxy 没有绝对的关系，我们一般将他们两个放在一起讲是为了方便对二者的理解。</p></li><li><p>那为什么会有 Reflect 对象呢，其实他最大的用处就是提供了一套统一操作 Object 的 API。判断对象是否存在某一个属性，可以使用 in 操作符，但是不够优雅，还可以使用 Reflect.has(obj, name); 删除一个属性可以使用 delete，也可以使用 Reflect.deleteProperty(obj, name); 获取所有属性名可以使用 Object.keys, 也可以使用 Reflect.ownKeys(obj); 我们更推荐使用 Reflect 的 API 来操作对象，因为他才是未来。</p></li></ul><h4 id="14-解析-get-参数"><a href="#14-解析-get-参数" class="headerlink" title="14.解析 get 参数"></a>14.解析 get 参数</h4><ul><li>通过 replace 方法获取 url 中的参数键值对，可以快速解析 get 参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> q = &#123;&#125;;</span><br><span class="line">location.<span class="property">search</span>.<span class="title function_">replace</span>(<span class="regexp">/([^?&amp;=]+)=([^&amp;]+)/g</span>, <span class="function">(<span class="params">_, k, v</span>) =&gt;</span> (q[k] = v));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(q);</span><br></pre></td></tr></table></figure><h4 id="15-解析连接-url"><a href="#15-解析连接-url" class="headerlink" title="15.解析连接 url"></a>15.解析连接 url</h4><ul><li>可以通过创建 a 标签，给 a 标签赋值 href 属性的方式，获取到协议，pathname，origin 等 location 对象上的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建a标签</span></span><br><span class="line"><span class="keyword">const</span> aEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// 给a标签赋值href路径</span></span><br><span class="line">aEle.<span class="property">href</span> = <span class="string">&quot;/test.html&quot;</span>;</span><br><span class="line"><span class="comment">// 访问aEle中的属性</span></span><br><span class="line">aEle.<span class="property">protocol</span>; <span class="comment">// 获取协议</span></span><br><span class="line">aEle.<span class="property">pathname</span>; <span class="comment">// 获取path</span></span><br><span class="line">aEle.<span class="property">origin</span>;</span><br><span class="line">aEle.<span class="property">host</span>;</span><br><span class="line">aEle.<span class="property">search</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前端小知识&quot;&gt;&lt;a href=&quot;#前端小知识&quot; class=&quot;headerlink&quot; title=&quot;前端小知识&quot;&gt;&lt;/a&gt;前端小知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前端小知识&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;h4 id=&quot;1-css-一行文本超出&quot;&gt;&lt;a href=&quot;#1-css-一行文本超出&quot; class=&quot;headerlink&quot; title=&quot;1.css 一行文本超出&quot;&gt;&lt;/a&gt;1.css 一行文本超出&lt;/h4&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: hidden;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;text-overflow&lt;/span&gt;: ellipsis;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;white-space&lt;/span&gt;: nowrap;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-多行文本超出显示&quot;&gt;&lt;a href=&quot;#2-多行文本超出显示&quot; class=&quot;headerlink&quot; title=&quot;2.多行文本超出显示&quot;&gt;&lt;/a&gt;2.多行文本超出显示&lt;/h4&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: -webkit-box;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-webkit-box-orient: vertical;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-webkit-line-clamp: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: hidden;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;3-IOS-手机容器滚动条滑动不流畅&quot;&gt;&lt;a href=&quot;#3-IOS-手机容器滚动条滑动不流畅&quot; class=&quot;headerlink&quot; title=&quot;3.IOS 手机容器滚动条滑动不流畅&quot;&gt;&lt;/a&gt;3.IOS 手机容器滚动条滑动不流畅&lt;/h4&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: auto;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-webkit-&lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;-scrolling: touch;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端小知识" scheme="https://qyjs.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端小知识" scheme="https://qyjs.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>常用工具知识总结</title>
    <link href="https://qyjs.github.io/2020/09/21/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9F%A5%E8%AF%86/"/>
    <id>https://qyjs.github.io/2020/09/21/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9F%A5%E8%AF%86/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用工具知识总结"><a href="#常用工具知识总结" class="headerlink" title="常用工具知识总结"></a>常用工具知识总结</h2><p>本部分主要是笔者关于常用工具所做的笔记，如果出现错误，希望大家指出！</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93">常用工具知识总结</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#git">GIT</a><ul><li><a href="#1-git-%E4%B8%8E-svn-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C">1. git 与 svn 的区别在哪里？</a></li><li><a href="#2-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84-git-%E5%91%BD%E4%BB%A4">2. 经常使用的 git 命令？</a></li><li><a href="#3-git-pull-%E5%92%8C-git-fetch-%E7%9A%84%E5%8C%BA%E5%88%AB">3. git pull 和 git fetch 的区别</a></li><li><a href="#4-git-rebase-%E5%92%8C-git-merge-%E7%9A%84%E5%8C%BA%E5%88%AB">4. git rebase 和 git merge 的区别</a></li></ul></li></ul></li></ul><h3 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h3><h4 id="1-git-与-svn-的区别在哪里？"><a href="#1-git-与-svn-的区别在哪里？" class="headerlink" title="1. git 与 svn 的区别在哪里？"></a>1. git 与 svn 的区别在哪里？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器</span><br><span class="line">出现问题，我们就没有办法使用 svn 来提交我们的代码。</span><br><span class="line"></span><br><span class="line">svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小</span><br><span class="line">并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</span><br><span class="line"></span><br><span class="line">svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83">《常见工作流比较》</a><br>   <a href="https://juejin.im/post/5bd95bf4f265da392c5307eb">《对比 Git 与 SVN，这篇讲的很易懂》</a><br>   <a href="https://blog.csdn.net/github_33304260/article/details/80171456">《GIT 与 SVN 世纪大战》</a><br>   <a href="https://www.jianshu.com/p/e8ad60710017">《Git 学习小记之分支原理》</a></p><span id="more"></span><h4 id="2-经常使用的-git-命令？"><a href="#2-经常使用的-git-命令？" class="headerlink" title="2. 经常使用的 git 命令？"></a>2. 经常使用的 git 命令？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init                     // 新建 git 代码库</span><br><span class="line">git add                      // 添加指定文件到暂存区</span><br><span class="line">git rm                       // 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git commit -m [message]      // 提交暂存区到仓库区</span><br><span class="line">git branch                   // 列出所有分支</span><br><span class="line">git checkout -b [branch]     // 新建一个分支，并切换到该分支</span><br><span class="line">git status                   // 显示有变更的文件</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">《常用 Git 命令清单》</a></p><h4 id="3-git-pull-和-git-fetch-的区别"><a href="#3-git-pull-和-git-fetch-的区别" class="headerlink" title="3. git pull 和 git fetch 的区别"></a>3. git pull 和 git fetch 的区别</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</span><br><span class="line"></span><br><span class="line">git pull 会将远程仓库的变化下载下来，并和当前分支合并。</span><br></pre></td></tr></table></figure><p>   <a href="https://blog.csdn.net/weixin_41975655/article/details/82887273">《详解 git pull 和 git fetch 的区别》</a></p><h4 id="4-git-rebase-和-git-merge-的区别"><a href="#4-git-rebase-和-git-merge-的区别" class="headerlink" title="4. git rebase 和 git merge 的区别"></a>4. git rebase 和 git merge 的区别</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。</span><br><span class="line"></span><br><span class="line">git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会</span><br><span class="line">保留之前每个分支的 commit 历史。</span><br><span class="line"></span><br><span class="line">git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后</span><br><span class="line">将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记</span><br><span class="line">录了。</span><br></pre></td></tr></table></figure><p>   <a href="https://www.jianshu.com/p/f23f72251abc">《git rebase 和 git merge 的区别》</a><br>   <a href="https://blog.csdn.net/liuxiaoheng1992/article/details/79108233">《git merge 与 git rebase 的区别》</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;常用工具知识总结&quot;&gt;&lt;a href=&quot;#常用工具知识总结&quot; class=&quot;headerlink&quot; title=&quot;常用工具知识总结&quot;&gt;&lt;/a&gt;常用工具知识总结&lt;/h2&gt;&lt;p&gt;本部分主要是笔者关于常用工具所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93&quot;&gt;常用工具知识总结&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%9B%AE%E5%BD%95&quot;&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git&quot;&gt;GIT&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-git-%E4%B8%8E-svn-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C&quot;&gt;1. git 与 svn 的区别在哪里？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84-git-%E5%91%BD%E4%BB%A4&quot;&gt;2. 经常使用的 git 命令？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-git-pull-%E5%92%8C-git-fetch-%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;3. git pull 和 git fetch 的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-git-rebase-%E5%92%8C-git-merge-%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;4. git rebase 和 git merge 的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GIT&quot;&gt;&lt;a href=&quot;#GIT&quot; class=&quot;headerlink&quot; title=&quot;GIT&quot;&gt;&lt;/a&gt;GIT&lt;/h3&gt;&lt;h4 id=&quot;1-git-与-svn-的区别在哪里？&quot;&gt;&lt;a href=&quot;#1-git-与-svn-的区别在哪里？&quot; class=&quot;headerlink&quot; title=&quot;1. git 与 svn 的区别在哪里？&quot;&gt;&lt;/a&gt;1. git 与 svn 的区别在哪里？&lt;/h4&gt;   &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;出现问题，我们就没有办法使用 svn 来提交我们的代码。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;   详细资料可以参考：&lt;br&gt;   &lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83&quot;&gt;《常见工作流比较》&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://juejin.im/post/5bd95bf4f265da392c5307eb&quot;&gt;《对比 Git 与 SVN，这篇讲的很易懂》&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://blog.csdn.net/github_33304260/article/details/80171456&quot;&gt;《GIT 与 SVN 世纪大战》&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://www.jianshu.com/p/e8ad60710017&quot;&gt;《Git 学习小记之分支原理》&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://qyjs.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://qyjs.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JS：深入理解JavaScript-this</title>
    <link href="https://qyjs.github.io/2020/09/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript-this/"/>
    <id>https://qyjs.github.io/2020/09/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript-this/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.385Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章【<a href="https://limeii.github.io/2019/05/js-execution-context/">JS：深入理解JavaScript-执行上下文</a>】中介绍了执行上下文是如何工作的。在这篇文章里会介绍执行上下文中的ThisBinding，也就是JavaScript中的this。</p><p>有四种可执行代码可以创建执行上下文，分别是<code>global code</code> <code>function code</code> <code>module</code>和<code>eval code</code>。接下来分别介绍这<code>global code</code> <code>function code</code>可执行代码中的this（ThisBinding）到底指的是什么。</p><h2 id="global-code的this"><a href="#global-code的this" class="headerlink" title="global code的this"></a>global code的this</h2><p>在JS引擎运行global code之前，会创建一个全局执行上下文压入执行栈的栈底，这个全局执行上文的ThisBinding绑定的是全局对象，在浏览器里指的就是window。</p><span id="more"></span><h2 id="function-code的this"><a href="#function-code的this" class="headerlink" title="function code的this"></a>function code的this</h2><p>在文章【<a href="https://limeii.github.io/2019/05/js-lexical-environment/">JS：深入理解JavaScript-词法环境</a>】提到过JavaScript是静态作用域，词法环境是由代码结构决定的，开发把代码写成什么样，词法环境就是怎么样，跟方法在哪里调用没有关系。但是对于函数的this刚好反过来，跟代码在哪里定义没有关系，而跟代码在哪里调用有关系。一般我们调用函数有以下四种方式：</p><ul><li>普通函数调用，比如foo()或者(functon(){})()</li><li>作为对象方法调用，比如obj.foo()</li><li>构造函数调用，比如new foo()</li><li>使用call、apply、bind等方法调用</li></ul><p>在介绍着几种函数调用之前，我们先来看下ECMAScript对this的规范：</p><blockquote><p>ECMAScript规范： 严格模式时，函数内的this绑定严格指向传入的thisArgument。非严格模式时，若传入的thisArgument不为undefined或null时，函数内的this绑定指向传入的thisArgument；为undefined或null时，函数内的this绑定指向全局的this。</p></blockquote><h3 id="普通函数调用"><a href="#普通函数调用" class="headerlink" title="普通函数调用"></a>普通函数调用</h3><p>普通函数的调用，包括函数调用foo()和立即调用函数表达式(functon(){})()，传到函数里的thisArgument是undefined。根据ECMAScript规范，如果在非严格模式下，普通函数里的this就是全局对象，而在严格模式下就为undefined。</p><p>比如有以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>如果把foo方法改为严格模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>执行上面这段代码，会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM162:4 Uncaught TypeError: Cannot read property &#x27;a&#x27; of undefined</span><br><span class="line">    at foo (&lt;anonymous&gt;:4:22)</span><br></pre></td></tr></table></figure><h3 id="对象方法调用"><a href="#对象方法调用" class="headerlink" title="对象方法调用"></a>对象方法调用</h3><p>作为对象方法调用，传到函数里的thisArgument是该对象。比如有如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>需要注意的是，只有离函数最近的这个对象，才是该函数的this，比如有代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">42</span>,</span><br><span class="line"> <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">obj2</span>: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">obj2</span>.<span class="title function_">foo</span>(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure><p>还有一种比较看起来像对象方法调用，实际上是普通函数调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>; </span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;global variable&quot;</span>;</span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// global variable</span></span><br></pre></td></tr></table></figure><h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p>new functionname()构造函数调用，this指的是构造出来的新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title function_">foo</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bar.<span class="property">a</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="使用call、apply、bind等方法调用"><a href="#使用call、apply、bind等方法调用" class="headerlink" title="使用call、apply、bind等方法调用"></a>使用call、apply、bind等方法调用</h3><p>call、apply、bind调用，可以显示传递对象给函数的thisArg，默认这几个函数的第一个形参是thisArg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">apply</span>( thisArg, argArray )</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>( thisArg , arg1, [ arg2, ... ] )</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">bind</span>( thisArg , [ arg1, [ arg2, ... ] ] )</span><br></pre></td></tr></table></figure><p>需要注意的是当thisArg为null或者undefined，在非严格模式下，this是全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print.<span class="title function_">call</span>(<span class="literal">null</span>);<span class="comment">//window</span></span><br><span class="line">print.<span class="title function_">call</span>(<span class="literal">undefined</span>);<span class="comment">//window</span></span><br><span class="line">print.<span class="title function_">call</span>(obj);<span class="comment">//obj</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>箭头函数在调用的时候不会绑定this，它会去词法环境链上寻找this，所以箭头函数的this取决于它定义的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">20</span>&#125;) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line">bar.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">20</span>&#125;) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="回调函数的this"><a href="#回调函数的this" class="headerlink" title="回调函数的this"></a>回调函数的this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>, <span class="number">0</span>) <span class="comment">//10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码运行结果是10，作为回调函数的时候，传递的是函数体，并不是函数名。在执行栈里，obj.foo已经执行完成被弹出执行栈，此时执行栈里只有全局执行上下文，setTimeout回调函数体执行的时候this为全局对象。</p><p>要想避免这种情况，有两种方法，第一种方法是使用bind返回的指定好this绑定的函数作为回调函数传入：</p><ul><li>使用bind指定this</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>.<span class="title function_">bind</span>(&#123;<span class="attr">a</span>: <span class="number">20</span>&#125;), <span class="number">0</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><ul><li>使用箭头函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arrowFn = foo.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="title function_">arrowFn</span>() <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">setTimeout</span>(arrowFn, <span class="number">0</span>) <span class="comment">//20</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>箭头函数中没有this绑定，this的值取决于其创建时所在词法环境链中最近的this绑定</p></li><li><p>非严格模式下，函数普通调用，this指向全局对象</p></li><li><p>严格模式下，函数普通调用，this为undefined</p></li><li><p>函数作为对象方法调用，this指向该对象</p></li><li><p>函数作为构造函数配合new调用，this指向构造出的新对象</p></li><li><p>非严格模式下，函数通过call、apply、bind等间接调用，this指向传入的第一个参数, 传入的第一个参数若为undefined或null，this指向全局对象</p></li><li><p>格模式下函数通过call、apply、bind等间接调用，this严格指向传入的第一个参数</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章【&lt;a href=&quot;https://limeii.github.io/2019/05/js-execution-context/&quot;&gt;JS：深入理解JavaScript-执行上下文&lt;/a&gt;】中介绍了执行上下文是如何工作的。在这篇文章里会介绍执行上下文中的ThisBinding，也就是JavaScript中的this。&lt;/p&gt;
&lt;p&gt;有四种可执行代码可以创建执行上下文，分别是&lt;code&gt;global code&lt;/code&gt; &lt;code&gt;function code&lt;/code&gt; &lt;code&gt;module&lt;/code&gt;和&lt;code&gt;eval code&lt;/code&gt;。接下来分别介绍这&lt;code&gt;global code&lt;/code&gt; &lt;code&gt;function code&lt;/code&gt;可执行代码中的this（ThisBinding）到底指的是什么。&lt;/p&gt;
&lt;h2 id=&quot;global-code的this&quot;&gt;&lt;a href=&quot;#global-code的this&quot; class=&quot;headerlink&quot; title=&quot;global code的this&quot;&gt;&lt;/a&gt;global code的this&lt;/h2&gt;&lt;p&gt;在JS引擎运行global code之前，会创建一个全局执行上下文压入执行栈的栈底，这个全局执行上文的ThisBinding绑定的是全局对象，在浏览器里指的就是window。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>offer 思路</title>
    <link href="https://qyjs.github.io/2020/09/21/%E5%89%91%E6%8C%87offer%E6%80%9D%E8%B7%AF/"/>
    <id>https://qyjs.github.io/2020/09/21/%E5%89%91%E6%8C%87offer%E6%80%9D%E8%B7%AF/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><ul><li>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>二维数组中的查找</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p>思路：</p><p>（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。</p><p>（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动<br>，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</p><ol start="2"><li>替换空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20</span><br><span class="line">Are%20Happy</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”</span><br><span class="line"></span><br><span class="line">str.replace(/\s/g,&quot;%20&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>从尾到头打印链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line">输入一个链表，从尾到头打印链表每个节点的值。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的</span><br><span class="line">实现可以利用 Array 的 push 和 pop 方法来模拟。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>重建二叉树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输</span><br><span class="line">入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左</span><br><span class="line">边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的</span><br><span class="line">时间复杂度为 O(n)，空间复杂度为 O(logn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>用两个栈实现队列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈 1 和栈 2。当执行队列的 push 操作时，直接</span><br><span class="line">将元素 push 进栈 1 中。当队列执行 pop 操作时，首先判断栈 2 是否为空，如果不为空则直接 pop 元素。如果栈 2 为空，则将栈 1 中</span><br><span class="line">的所有元素 pop 然后 push 到栈 2 中，然后再执行栈 2 的 pop 操作。</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line"></span><br><span class="line">当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>旋转数组的最小数字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的</span><br><span class="line">最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大</span><br><span class="line">小为 0，请返回 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相</span><br><span class="line">邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。</span><br><span class="line"></span><br><span class="line">（2）二分法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相关资料可以参考：<br><a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p><ol start="7"><li>斐波那契数列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">斐波那契数列的规律是，第一项为 0，第二项为 1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠</span><br><span class="line">加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li>跳台阶</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">跳台阶的问题是一个动态规划的问题，由于一次只能够跳 1 级或者 2 级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一</span><br><span class="line">种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。</span><br><span class="line"></span><br><span class="line">和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>变态跳台阶</li></ol><p>题目：</p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>思路：</p><p>变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。</p><p>f(1) = 1<br>f(2) = f(2-1) + f(2-2) //f(2-2) 表示 2 阶一次跳 2 阶的次数。<br>f(3) = f(3-1) + f(3-2) + f(3-3)<br>…<br>f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n)</p><p>再次总结可得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        | 1 ,(n=0 )</span><br><span class="line">f(n) =  | 1 ,(n=1 )</span><br><span class="line">        | 2\*f(n-1),(n&gt;=2)</span><br></pre></td></tr></table></figure><ol start="10"><li>矩形覆盖</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共</span><br><span class="line">有多少种方法？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">依旧是斐波那契数列的应用</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="11"><li>二进制中 1 的个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后</span><br><span class="line">面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判</span><br><span class="line">断这个数可以经历多少次这样的过程。</span><br><span class="line"></span><br><span class="line">如：1100&amp;1011=1000</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="12"><li>数值的整数次方</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="13"><li>调整数组顺序使奇数位于偶数前面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半</span><br><span class="line">部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到</span><br><span class="line">奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间</span><br><span class="line">复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="14"><li>链表中倒数第 k 个节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，输出该链表中倒数第 k 个结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后</span><br><span class="line">移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="15"><li>反转链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，反转链表后，输出链表的所有元素。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当</span><br><span class="line">前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne</span><br><span class="line">xt 节点，实现下一次循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="16"><li>合并两个排序的链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的方式，依次将两个链表的元素递归进行对比。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="17"><li>树的子结构</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两棵二叉树 A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的思想来解决</span><br><span class="line"></span><br><span class="line">第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。</span><br><span class="line">第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="18"><li>二叉树的镜像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="19"><li>顺时针打印矩阵</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下矩阵： 1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">9 10 11 12</span><br><span class="line">13 14 15 16</span><br><span class="line">则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一</span><br><span class="line">次需要打印的数据范围。</span><br><span class="line"></span><br><span class="line">（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="20"><li>定义一个栈，实现 min 函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小</span><br><span class="line">的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="21"><li>栈的压入弹出</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如</span><br><span class="line">序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序</span><br><span class="line">列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出</span><br><span class="line">栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中</span><br><span class="line">的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="22"><li>从上往下打印二叉树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子</span><br><span class="line">节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="23"><li>二叉搜索树的后序遍历</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两</span><br><span class="line">个数字都互不相同。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，</span><br><span class="line">所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我</span><br><span class="line">们可以利用这些特点来递归判断。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="24"><li>二叉树中和为某一值路径</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经</span><br><span class="line">过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="25"><li>复杂链表的复制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为</span><br><span class="line">复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra</span><br><span class="line">ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复</span><br><span class="line">制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此</span><br><span class="line">不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。</span><br><span class="line"></span><br><span class="line">（3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行</span><br><span class="line">random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点</span><br><span class="line">。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="26"><li>二叉搜索树与双向链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序</span><br><span class="line">序列。</span><br><span class="line"></span><br><span class="line">基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并</span><br><span class="line">将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点</span><br><span class="line">的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="27"><li>字符串的排列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有</span><br><span class="line">字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过 9（可能有字符重复），字符只包括大小写字母。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可</span><br><span class="line">以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一</span><br><span class="line">个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html">《字符串的排列》</a></p><ol start="28"><li>数组中出现次数超过一半的数字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为 9 的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数</span><br><span class="line">字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为</span><br><span class="line">O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中</span><br><span class="line">位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随</span><br><span class="line">机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字</span><br><span class="line">便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index 的左边，在左边继续寻找即可，反之</span><br><span class="line">在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数</span><br><span class="line">字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加 1，如果不同，则次数减 1，如果</span><br><span class="line">次数为 0，则需要保存下一个数字，并把次数设定为 1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，</span><br><span class="line">则要找的数字肯定是最后一次把次数设为 1 时对应的数字。该方法的时间复杂度为 O(n)，空间复杂度为 O(1)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/ns_code/article/details/26957383">《出现次数超过一半的数字》</a></p><ol start="29"><li>最小的 K 个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4 。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂</span><br><span class="line">度，最好的情况下为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part</span><br><span class="line">ition 函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢</span><br><span class="line">纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢</span><br><span class="line">纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划</span><br><span class="line">分。当该枢纽值的位置比 k-1 大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平</span><br><span class="line">均时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这</span><br><span class="line">就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最</span><br><span class="line">大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一</span><br><span class="line">种方法的平均时间复杂度为 O(nlogk)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579">《寻找最小的 k 个数》</a></p><ol start="30"><li>连续子数组的最大和</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计</span><br><span class="line">算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的</span><br><span class="line">正数会弥补它呢？例如：&#123;6,-3,-2,7,-15,1,2,2&#125;，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。你会不会被他忽悠</span><br><span class="line">住？（子向量的长度至少是 1）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首</span><br><span class="line">往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。</span><br><span class="line">因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为 0，因为后面的数加上负</span><br><span class="line">数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。</span><br><span class="line">使用这一种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html">《连续子数组的最大和》</a></p><ol start="31"><li>整数中 1 出现的次数（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求出 1~13 的整数中 1 出现的次数，并算出 100~1300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、</span><br><span class="line">12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整</span><br><span class="line">数区间中 1 出现的次数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是求出 1 出现在每位上的次数，然后进行叠加。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/yi_Afly/article/details/52012593">《从 1 到 n 整数中 1 出现的次数：O(logn)算法》</a></p><ol start="32"><li>把数组排成最小的数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321</span><br><span class="line">&#125;，则打印出这三个数字能排成的最小数字为 321323。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）求出数组的全排列，然后对每个排列结果进行比较。</span><br><span class="line"></span><br><span class="line">（2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的</span><br><span class="line">结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html">《把数组排成最小的数》</a></p><ol start="33"><li>丑数（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把只包含质因子 2、3 和 5 的数称作丑数。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。 习惯上我们把 1 当做是第一个丑数。求</span><br><span class="line">按从小到大的顺序的第 N 个丑数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）判断一个数是否为丑数，可以判断该数不断除以 2，最后余数是否为 1。判断该数不断除以 3，最后余数是否为 1。判断不断除以</span><br><span class="line">5，最后余数是否为 1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。</span><br><span class="line"></span><br><span class="line">（2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="34"><li>第一个只出现一次的字符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这</span><br><span class="line">一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时</span><br><span class="line">，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="35"><li>数组中的逆序对</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对</span><br><span class="line">的总数 P。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果</span><br><span class="line">后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比</span><br><span class="line">较，因此这个算法的时间复杂度是 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂</span><br><span class="line">度为 O(nlogn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html">《数组中的逆序对》</a></p><ol start="36"><li>两个链表的第一个公共结点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二</span><br><span class="line">个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一</span><br><span class="line">个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈</span><br><span class="line">，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这</span><br><span class="line">一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个</span><br><span class="line">指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，</span><br><span class="line">判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html">《两个链表的第一个公共结点》</a></p><ol start="37"><li>数字在排序数组中出现的次数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出</span><br><span class="line">现了 4 次，因此输出 4 。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要</span><br><span class="line">去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束</span><br><span class="line">位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如</span><br><span class="line">果 k 值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值</span><br><span class="line">是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们</span><br><span class="line">下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结</span><br><span class="line">束位置。这一种方法的平均时间复杂度为 O(logn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="38"><li>二叉树的深度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深</span><br><span class="line">度。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="39"><li>平衡二叉树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它</span><br><span class="line">就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。</span><br><span class="line"></span><br><span class="line">（2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深</span><br><span class="line">度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="40"><li>数组中只出现一次的数字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于 0，一个数和 0 异或还是它本身。由于数组中</span><br><span class="line">的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下</span><br><span class="line">的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的 1 表示的是 A 和</span><br><span class="line">B 不同的位。我们取异或结果的第一个 1 所在的位数，假如是第 3 位，接着通过比较第三位来将数组分为两组，相同数字一定会</span><br><span class="line">被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="41"><li>和为 S 的连续正数序列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">小明很喜欢数学，有一天他在做数学作业时，要求计算出 9~16 的和，他马上就写出了正确答案是 100。但是他并不满足于此，他在想究</span><br><span class="line">竟有多少种连续的正数序列的和为 100（至少包括两个数）。没多久，他就得到另一组连续正数和为 100 的序列：18,19,20,21,22。</span><br><span class="line">现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为 S 的连续正数序列。序</span><br><span class="line">列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">维护一个正数序列数组，数组中初始只含有值 1 和 2，然后从 3 依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后</span><br><span class="line">判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续</span><br><span class="line">往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连</span><br><span class="line">续序列，直到数组遍历完成终止。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html">《和为 s 的连续正数序列》</a></p><ol start="42"><li>和为 S 的两个数字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数</span><br><span class="line">的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和</span><br><span class="line">为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素</span><br><span class="line">。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和</span><br><span class="line">比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html">《和为 S 的字符串》</a></p><ol start="43"><li>左旋转字符串</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的</span><br><span class="line">字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移 3 位后的结果，即 “X</span><br><span class="line">YZdefabc”。是不是很简单？OK，搞定它！</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">字符串裁剪后拼接</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="44"><li>翻转单词顺序列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有</span><br><span class="line">一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了</span><br><span class="line">，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="45"><li>扑克牌的顺子</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王（一副牌原本是 54 张^\_^）...他随机从中抽出</span><br><span class="line">了 5 张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃 3，小王，大王</span><br><span class="line">，方片 5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作 1，J 为 11，</span><br><span class="line">Q 为 12，K 为 13。上面的 5 张牌就可以变成“1,2,3,4,5”（大小王分别看作 2 和 4），“So Lucky!”。LL 决定去买体育彩票啦。</span><br><span class="line">现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先判断 5 个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数</span><br><span class="line">组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空</span><br><span class="line">缺，这个数组实际上还是连续的。</span><br><span class="line"></span><br><span class="line">于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如</span><br><span class="line">果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0</span><br><span class="line">数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html">《扑克牌的顺子》</a></p><ol start="46"><li>圆圈中最后剩下的数字（约瑟夫环问题）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数</span><br><span class="line">字。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）使用环形链表进行模拟。</span><br><span class="line"></span><br><span class="line">（2）根据规律得出（待深入理解）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html">《圆圈中最后剩下的数字》</a></p><ol start="47"><li>1+2+3+…+n</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特</span><br><span class="line">性来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="48"><li>不用加减乘除做加法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过位运算，递归来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="49"><li>把字符串转换成整数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为 0 或者字符串不是一个合法的数值则返回 0。输入描</span><br><span class="line">述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先需要进行符号判断，其次我们根据字符串的每位通过减 0 运算转换为整数和，依次根据位数叠加。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="50"><li>数组中重复的数字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知</span><br><span class="line">道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O</span><br><span class="line">(n)，空间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值</span><br><span class="line">交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要</span><br><span class="line">额外的内存空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="51"><li>构建乘积数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]_A[1]_...*A[i-1]*A</span><br><span class="line">[i+1]*...*A[n-1]。不能使用除法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1]</span><br><span class="line">      D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1]</span><br><span class="line">      B[i]=C[i]×D[i]</span><br><span class="line">       将乘积分为前后两个部分，分别循环求出后，再进行相乘。</span><br><span class="line"></span><br><span class="line">（2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34804711">《构建乘积数组》</a></p><ol start="52"><li>正则表达式的匹配</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;_&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;_&#x27;表示它前面的字符可以出现任</span><br><span class="line">意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，</span><br><span class="line">但是与&quot;aa.a&quot;和&quot;ab\*a&quot;均不匹配。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）状态机思路（待深入理解）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html">《正则表达式匹配》</a></p><ol start="53"><li>表示数值的字符串</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-</span><br><span class="line">16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。、</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用正则表达式实现</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="54"><li>字符流中第一个不重复的字符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次</span><br><span class="line">的字符是 &quot;g&quot; 。当从该字符流中读出前六个字符 &quot;google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。 输出描述：如果当前字符流</span><br><span class="line">没有存在出现一次的字符，返回#字符。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">同第 34 题</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="55"><li>链表中环的入口结点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个链表中包含环，如何找出环的入口结点？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我</span><br><span class="line">们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此</span><br><span class="line">通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。</span><br><span class="line"></span><br><span class="line">然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇</span><br><span class="line">点就是环的入口节点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html">《链表中环的入口结点》</a><br><a href="https://blog.csdn.net/shansusu/article/details/50285735">《《剑指 offer》——链表中环的入口结点》</a></p><ol start="56"><li>删除链表中重复的结点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表 1-&gt;2-&gt;3-</span><br><span class="line"></span><br><span class="line">&gt; 3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头</span><br><span class="line">结点也可能被删除，所以在链表头额外添加一个结点。</span><br><span class="line"></span><br><span class="line">接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除</span><br><span class="line">之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev</span><br><span class="line">要始终与下一个没有重复的结点连接在一起。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="57"><li>二叉树的下一个结点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，</span><br><span class="line">还有一个指向父节点的指针。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">这个问题我们可以分为三种情况来讨论。</span><br><span class="line"></span><br><span class="line">第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点</span><br><span class="line">出发，一直沿着左子节点的指针，就能找到下一个节点。</span><br><span class="line"></span><br><span class="line">第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节</span><br><span class="line">点。</span><br><span class="line"></span><br><span class="line">第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到</span><br><span class="line">一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</span><br></pre></td></tr></table></figure><ol start="58"><li>对称二叉树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式</span><br><span class="line">，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉</span><br><span class="line">树。</span><br></pre></td></tr></table></figure><ol start="59"><li>按之字形顺序打印二叉树（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照</span><br><span class="line">从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层</span><br><span class="line">，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每</span><br><span class="line">一个栈遍历完成后进入下一层循环。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/wuguanglin/p/Print.html">《按之字形顺序打印二叉树》</a></p><ol start="60"><li>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还</span><br><span class="line">没有打印的结点数，另一个变量表示下一次结点的数目。</span><br></pre></td></tr></table></figure><ol start="61"><li>序列化二叉树（带深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">数组模拟</span><br></pre></td></tr></table></figure><ol start="62"><li>二叉搜索树的第 K 个节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一颗二叉搜索树，请找出其中的第 k 小的结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</span><br></pre></td></tr></table></figure><ol start="63"><li>数据流中的中位数（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据</span><br><span class="line">流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br></pre></td></tr></table></figure><ol start="64"><li>滑动窗口中的最大值（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的</span><br><span class="line">大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下</span><br><span class="line">6 个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2</span><br><span class="line">,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用队列的方式模拟</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="65"><li>矩阵中的路径（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每</span><br><span class="line">一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子</span><br><span class="line">。例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的</span><br><span class="line">第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure><ol start="66"><li>机器人的运动范围（待深入理解）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">地上有一个 m 行和 n 列的方格。一个机器人从坐标 0,0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能</span><br><span class="line">进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是</span><br><span class="line">，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure><p>剑指 offer 相关资料可以参考：</p><ul><li><a href="https://blog.csdn.net/zzl819954692/article/details/79648054">《剑指 offer 题目练习及思路分析》</a></li><li><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html">《JS 版剑指 offer》</a></li><li><a href="https://wiki.jikexueyuan.com/project/for-offer/">《剑指 Offer 学习心得》</a></li></ul><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><ol><li><p>明星问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个</span><br><span class="line">函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。</span><br><span class="line">    这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明</span><br><span class="line">    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移</span><br><span class="line">    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩</span><br><span class="line">    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f">《一个明星和 n-1 个群众》</a></p></li><li><p>正负数组求和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和</span><br><span class="line">最接近零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分</span><br><span class="line">    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动</span><br><span class="line">    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;剑指-offer-思路总结&quot;&gt;&lt;a href=&quot;#剑指-offer-思路总结&quot; class=&quot;headerlink&quot; title=&quot;剑指 offer 思路总结&quot;&gt;&lt;/a&gt;剑指 offer 思路总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二维数组中的查找&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;题目：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Offer" scheme="https://qyjs.github.io/categories/Offer/"/>
    
    
    <category term="Offer" scheme="https://qyjs.github.io/tags/Offer/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面试知识点</title>
    <link href="https://qyjs.github.io/2020/09/21/JavaScript%20%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://qyjs.github.io/2020/09/21/JavaScript%20%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-面试知识点总结"><a href="#JavaScript-面试知识点总结" class="headerlink" title="JavaScript 面试知识点总结"></a>JavaScript 面试知识点总结</h2><p>本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#javascript-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93">JavaScript 面试知识点总结</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#1-%E4%BB%8B%E7%BB%8D-js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 介绍 js 的基本数据类型</a></li><li><a href="#2-javascript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BD%A0%E8%83%BD%E7%94%BB%E4%B8%80%E4%B8%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E5%90%97">2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</a></li><li><a href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">3. 什么是堆？什么是栈？它们之间有什么区别和联系？</a></li><li>[4. 内部属性 [[Class]] 是什么？](#4-内部属性-class-是什么)</li><li><a href="#5-%E4%BB%8B%E7%BB%8D-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">5. 介绍 js 有哪些内置对象？</a></li><li><a href="#6-undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB">6. undefined 与 undeclared 的区别？</a></li><li><a href="#7-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB">7. null 和 undefined 的区别？</a></li><li><a href="#8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC">8. 如何获取安全的 undefined 值？</a></li><li><a href="#9-%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-javascript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83">9. 说几条写 JavaScript 的基本规范？</a></li><li><a href="#10-javascript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">10. JavaScript 原型，原型链？ 有什么特点？</a></li><li><a href="#11-js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">11. js 获取原型的方法？</a></li><li><a href="#12-%E5%9C%A8-js-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">12. 在 js 中不同进制数字的表示方式</a></li><li><a href="#13-js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91">13. js 中整数的安全范围是多少？</a></li><li><a href="#14-typeof-nan-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">14. typeof NaN 的结果是什么？</a></li><li><a href="#15-isnan-%E5%92%8C-numberisnan-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">15. isNaN 和 Number.isNaN 函数的区别？</a></li><li><a href="#16-array-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%80%BC%E6%97%B6%E7%9A%84%E8%A1%A8%E7%8E%B0">16. Array 构造函数只有一个参数值时的表现？</a></li><li><a href="#17-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">17. 其他值到字符串的转换规则？</a></li><li><a href="#18-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">18. 其他值到数字值的转换规则？</a></li><li><a href="#19-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">19. 其他值到布尔类型的值的转换规则？</a></li><li><a href="#20--%E5%92%8C--%E7%9A%84-valueof-%E5%92%8C-tostring-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</a></li><li><a href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E5%80%BC%E5%AF%B9%E8%B1%A1">21. 什么是假值对象？</a></li><li><a href="#22--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8">22. ~ 操作符的作用？</a></li><li><a href="#23-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</a></li><li><a href="#24--%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5">24. <code>+</code> 操作符什么时候用于字符串的拼接？</a></li><li><a href="#25-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">25. 什么情况下会发生布尔值的隐式强制类型转换？</a></li><li><a href="#26--%E5%92%8C--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">26. || 和 &amp;&amp; 操作符的返回值？</a></li><li><a href="#27-symbol-%E5%80%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">27. Symbol 值的强制类型转换？</a></li><li><a href="#28--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">28. == 操作符的强制类型转换规则？</a></li><li><a href="#29-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BE%8B%E5%A6%82-123b">29. 如何将字符串转化为数字，例如 ‘12.3b’?</a></li><li><a href="#30-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%E5%A6%82-1200000011-%E8%BD%AC%E5%8C%96%E4%B8%BA1200000011">30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</a></li><li><a href="#31-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">31. 常用正则表达式</a></li><li><a href="#32-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95">32. 生成随机数的各种方法？</a></li><li><a href="#33-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">33. 如何实现数组的随机排序？</a></li><li><a href="#34-javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">34. javascript 创建对象的几种方式？</a></li><li><a href="#35-javascript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">35. JavaScript 继承的几种实现方式？</a></li><li><a href="#36-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0">36. 寄生式组合继承的实现？</a></li><li><a href="#37-javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">37. Javascript 的作用域链？</a></li><li><a href="#38-%E8%B0%88%E8%B0%88-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">38. 谈谈 This 对象的理解</a></li><li><a href="#39-eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84">39. eval 是做什么的？</a></li><li><a href="#40-%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom">40. 什么是 DOM 和 BOM？</a></li><li><a href="#41-%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0">41. 写一个通用的事件侦听器函数</a></li><li><a href="#42-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88ie-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1">42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</a></li><li><a href="#43-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88">43. 三种事件模型是什么？</a></li><li><a href="#44-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88">44. 事件委托是什么？</a></li><li><a href="#45-1-2-3mapparseint-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91">45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</a></li><li><a href="#46-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83">46. 什么是闭包，为什么要用它？</a></li><li><a href="#47-javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84-use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D--%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</a></li><li><a href="#48-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB">48. 如何判断一个对象是否属于某个类？</a></li><li><a href="#49-instanceof-%E7%9A%84%E4%BD%9C%E7%94%A8">49. instanceof 的作用？</a></li><li><a href="#50-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">50. new 操作符具体干了什么呢？如何实现？</a></li><li><a href="#51-javascript-%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE%E6%97%B6%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF">51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></li><li><a href="#52-%E5%AF%B9%E4%BA%8E-json-%E7%9A%84%E4%BA%86%E8%A7%A3">52. 对于 JSON 的了解？</a></li><li><a href="#53-foreachcallfunctionaastyleoutline1px-solid-mathrandom124tostring16-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%97">53. [].forEach.call($$(“<em>“),function(a){a.style.outline=”1px solid #”+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</a></li><li><a href="#54-js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">54. js 延迟加载的方式有哪些？</a></li><li><a href="#55-ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-ajax">55. Ajax 是什么? 如何创建一个 Ajax？</a></li><li><a href="#56-%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">56. 谈一谈浏览器的缓存机制？</a></li><li><a href="#57-ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">57. Ajax 解决浏览器缓存问题？</a></li><li><a href="#58-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB">58. 同步和异步的区别？</a></li><li><a href="#59-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96">59. 什么是浏览器的同源政策？</a></li><li><a href="#60-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">60. 如何解决跨域问题？</a></li><li><a href="#61-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-cookie">61. 服务器代理转发时，该如何处理 cookie？</a></li><li><a href="#62-%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-">62. 简单谈一下 cookie ？</a></li><li><a href="#63-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A">63. 模块化开发怎么做？</a></li><li><a href="#64-js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">64. js 的几种模块规范？</a></li><li><a href="#65-amd-%E5%92%8C-cmd-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB">65. AMD 和 CMD 规范的区别？</a></li><li><a href="#66-es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97amdcmd-%E7%9A%84%E5%B7%AE%E5%BC%82">66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异</a></li><li><a href="#67-requirejs-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95-%E7%BC%93%E5%AD%98%E7%9A%84">67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</a></li><li><a href="#68-js-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E6%80%8E%E4%B9%88%E9%80%A0%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8">68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</a></li><li><a href="#69-ecmascript6-%E6%80%8E%E4%B9%88%E5%86%99-class%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-class-%E8%BF%99%E7%A7%8D%E4%B8%9C%E8%A5%BF">69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</a></li><li><a href="#70-documenwrite-%E5%92%8C-innerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">70. documen.write 和 innerHTML 的区别？</a></li><li><a href="#71-dom-%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%A7%BB%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9">71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</a></li><li><a href="#72-innerhtml-%E4%B8%8E-outerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">72. innerHTML 与 outerHTML 的区别？</a></li><li><a href="#73-call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB">73. .call() 和 .apply() 的区别？</a></li><li><a href="#74-javascript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">74. JavaScript 类数组对象的定义？</a></li><li><a href="#75-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B">75. 数组和对象有哪些原生方法，列举一下？</a></li><li><a href="#76-%E6%95%B0%E7%BB%84%E7%9A%84-fill-%E6%96%B9%E6%B3%95">76. 数组的 fill 方法？</a></li><li><a href="#77--%E7%9A%84%E9%95%BF%E5%BA%A6">77. [,,,] 的长度？</a></li><li><a href="#78-javascript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87">78. JavaScript 中的作用域与变量声明提升？</a></li><li><a href="#79-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-javascript-">79. 如何编写高性能的 Javascript ？</a></li><li><a href="#80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">80. 简单介绍一下 V8 引擎的垃圾回收机制</a></li><li><a href="#81-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">81. 哪些操作会造成内存泄漏？</a></li><li><a href="#82-%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E7%BB%99%E5%87%BA%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</a></li><li><a href="#83-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%BF%E9%87%8C">83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</a></li><li><a href="#84-%E6%8A%8A-script-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84-body-%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC">84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</a></li><li><a href="#85-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6">85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</a></li><li><a href="#86-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</a></li><li><a href="#87-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B9%88-%E7%9F%A5%E9%81%93-bdd-tdd-unit-test-%E4%B9%88-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B9%88mocha-sinon-jasmin-qunit">87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</a></li><li><a href="#88-%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">88. 检测浏览器版本版本有哪些方式？</a></li><li><a href="#89-%E4%BB%80%E4%B9%88%E6%98%AF-polyfill-">89. 什么是 Polyfill ？</a></li><li><a href="#90-%E4%BD%BF%E7%94%A8-js-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">90. 使用 JS 实现获取文件扩展名？</a></li><li><a href="#91-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96">91. 介绍一下 js 的节流与防抖？</a></li><li><a href="#92-objectis-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6--%E7%9A%84%E5%8C%BA%E5%88%AB">92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？</a></li><li><a href="#93-escapeencodeuriencodeuricomponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">93. escape,encodeURI,encodeURIComponent 有什么区别？</a></li><li><a href="#94-unicode-%E5%92%8C-utf-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">94. Unicode 和 UTF-8 之间的关系？</a></li><li><a href="#95-js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88">95. js 的事件循环是什么？</a></li><li><a href="#96-js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0">96. js 中的深浅拷贝实现？</a></li><li><a href="#97-%E6%89%8B%E5%86%99-callapply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0">97. 手写 call、apply 及 bind 函数</a></li><li><a href="#98-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">98. 函数柯里化的实现</a></li><li><a href="#99-%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</a></li><li><a href="#100-%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D">100. 原码、反码和补码的介绍</a></li><li><a href="#101-toprecision-%E5%92%8C-tofixed-%E5%92%8C-mathround-%E7%9A%84%E5%8C%BA%E5%88%AB">101. toPrecision 和 toFixed 和 Math.round 的区别？</a></li><li><a href="#102-%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-xss-%E6%94%BB%E5%87%BB">102. 什么是 XSS 攻击？如何防范 XSS 攻击？</a></li><li><a href="#103-%E4%BB%80%E4%B9%88%E6%98%AF-csp">103. 什么是 CSP？</a></li><li><a href="#104-%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-csrf-%E6%94%BB%E5%87%BB">104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</a></li><li><a href="#105-%E4%BB%80%E4%B9%88%E6%98%AF-samesite-cookie-%E5%B1%9E%E6%80%A7">105. 什么是 Samesite Cookie 属性？</a></li><li><a href="#106-%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81">106. 什么是点击劫持？如何防范点击劫持？</a></li><li><a href="#107-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">107. SQL 注入攻击？</a></li><li><a href="#108-%E4%BB%80%E4%B9%88%E6%98%AF-mvvm%E6%AF%94%E4%B9%8B-mvc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-mvp-">108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</a></li><li><a href="#109-vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">109. vue 双向数据绑定原理？</a></li><li><a href="#110-objectdefineproperty-%E4%BB%8B%E7%BB%8D">110. Object.defineProperty 介绍？</a></li><li><a href="#111-%E4%BD%BF%E7%94%A8-objectdefineproperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9">111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li><a href="#112-%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom%E4%B8%BA%E4%BB%80%E4%B9%88-virtual-dom-%E6%AF%94%E5%8E%9F%E7%94%9F-dom-%E5%BF%AB">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</a></li><li><a href="#113-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-dom-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82">113. 如何比较两个 DOM 树的差异？</a></li><li><a href="#114-%E4%BB%80%E4%B9%88%E6%98%AF-requestanimationframe-">114. 什么是 requestAnimationFrame ？</a></li><li><a href="#115-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95">115. 谈谈你对 webpack 的看法</a></li><li><a href="#116-offsetwidthoffsetheightclientwidthclientheight-%E4%B8%8E-scrollwidthscrollheight-%E7%9A%84%E5%8C%BA%E5%88%AB">116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</a></li><li><a href="#117-%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">117. 谈一谈你理解的函数式编程？</a></li><li><a href="#118-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">118. 异步编程的实现方式？</a></li><li><a href="#119-js-%E5%8A%A8%E7%94%BB%E4%B8%8E-css-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">119. Js 动画与 CSS 动画区别及相应实现</a></li><li><a href="#120-get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA">120. get 请求传参长度的误区</a></li><li><a href="#121-url-%E5%92%8C-uri-%E7%9A%84%E5%8C%BA%E5%88%AB">121. URL 和 URI 的区别？</a></li><li><a href="#122-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">122. get 和 post 请求在缓存方面的区别</a></li><li><a href="#123-%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">123. 图片的懒加载和预加载</a></li><li><a href="#124-mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB">124. mouseover 和 mouseenter 的区别？</a></li><li><a href="#125-js-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">125. js 拖拽功能的实现</a></li><li><a href="#126-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-settimeout-%E5%AE%9E%E7%8E%B0-setinterval%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F">126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</a></li><li><a href="#127-let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">127. let 和 const 的注意点？</a></li><li><a href="#128-%E4%BB%80%E4%B9%88%E6%98%AF-rest-%E5%8F%82%E6%95%B0">128. 什么是 rest 参数？</a></li><li><a href="#129-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84">129. 什么是尾调用，使用尾调用有什么好处？</a></li><li><a href="#130-symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">130. Symbol 类型的注意点？</a></li><li><a href="#131-set-%E5%92%8C-weakset-%E7%BB%93%E6%9E%84">131. Set 和 WeakSet 结构？</a></li><li><a href="#132-map-%E5%92%8C-weakmap-%E7%BB%93%E6%9E%84">132. Map 和 WeakMap 结构？</a></li><li><a href="#133-%E4%BB%80%E4%B9%88%E6%98%AF-proxy-">133. 什么是 Proxy ？</a></li><li><a href="#134-reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84">134. Reflect 对象创建目的？</a></li><li><a href="#135-require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">135. require 模块引入的查找方式？</a></li><li><a href="#136-%E4%BB%80%E4%B9%88%E6%98%AF-promise-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%98%AF-promisesa-%E8%A7%84%E8%8C%83">136. 什么是 Promise 对象，什么是 Promises/A+ 规范？</a></li><li><a href="#137-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-promise">137. 手写一个 Promise</a></li><li><a href="#138-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F">138. 如何检测浏览器所支持的最小字体大小？</a></li><li><a href="#139-%E6%80%8E%E4%B9%88%E5%81%9A-js-%E4%BB%A3%E7%A0%81-error-%E7%BB%9F%E8%AE%A1">139. 怎么做 JS 代码 Error 统计？</a></li><li><a href="#140-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">140. 单例模式模式是什么？</a></li><li><a href="#141-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">141. 策略模式是什么？</a></li><li><a href="#142-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">142. 代理模式是什么？</a></li><li><a href="#143-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">143. 中介者模式是什么？</a></li><li><a href="#144-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">144. 适配器模式是什么？</a></li><li><a href="#145-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">145. 观察者模式和发布订阅模式有什么不同？</a></li><li><a href="#146-vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88">146. Vue 的生命周期是什么？</a></li><li><a href="#147-vue-%E7%9A%84%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88">147. Vue 的各个生命阶段是什么？</a></li><li><a href="#148-vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">148. Vue 组件间的参数传递方式？</a></li><li><a href="#149-computed-%E5%92%8C-watch-%E7%9A%84%E5%B7%AE%E5%BC%82">149. computed 和 watch 的差异？</a></li><li><a href="#150-vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">150. vue-router 中的导航钩子函数</a></li><li><a href="#151-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB">151. $route 和 $router 的区别？</a></li><li><a href="#152-vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">152. vue 常用的修饰符？</a></li><li><a href="#153-vue-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8">153. vue 中 key 值的作用？</a></li><li><a href="#154-computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%AB">154. computed 和 watch 区别？</a></li><li><a href="#155-keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">155. keep-alive 组件有什么作用？</a></li><li><a href="#156-vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB">156. vue 中 mixin 和 mixins 区别？</a></li><li><a href="#157-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-content-type-">157. 开发中常用的几种 Content-Type ？</a></li><li><a href="#158-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0">158. 如何封装一个 javascript 的类型判断函数？</a></li><li><a href="#159-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1">159. 如何判断一个对象是否为空对象？</a></li><li><a href="#160-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1234">160. 使用闭包实现每隔一秒打印 1,2,3,4</a></li><li><a href="#161-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp">161. 手写一个 jsonp</a></li><li><a href="#162-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">162. 手写一个观察者模式？</a></li><li><a href="#163-eventemitter-%E5%AE%9E%E7%8E%B0">163. EventEmitter 实现</a></li><li><a href="#164-%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AF-js-%E9%9D%A2%E8%AF%95%E9%A2%98">164. 一道常被人轻视的前端 JS 面试题</a></li><li><a href="#165-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%E4%BB%80%E4%B9%88%E6%98%AF-performance-api">165. 如何确定页面的可用性时间，什么是 Performance API？</a></li><li><a href="#166-js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">166. js 中的命名规则</a></li><li><a href="#167-js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5">167. js 语句末尾分号是否可以省略？</a></li><li><a href="#168-objectassign">168. Object.assign()</a></li><li><a href="#169-mathceil-%E5%92%8C-mathfloor">169. Math.ceil 和 Math.floor</a></li><li><a href="#170-js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9">170. js for 循环注意点</a></li><li><a href="#171-%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%81%87%E8%AE%BE%E6%9C%89-100000-%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">171. 一个列表，假设有 100000 个数据，这个该怎么办？</a></li><li><a href="#172-js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0">172. js 中倒计时的纠偏实现？</a></li><li><a href="#173-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">173. 进程间通信的方式？</a></li><li><a href="#174-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">174. 如何查找一篇英文文章中出现频率最高的单词？</a></li></ul></li></ul></li></ul><h4 id="1-介绍-js-的基本数据类型"><a href="#1-介绍-js-的基本数据类型" class="headerlink" title="1. 介绍 js 的基本数据类型"></a>1. 介绍 js 的基本数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</span><br><span class="line">Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</span><br><span class="line">BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</span><br></pre></td></tr></table></figure><h4 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h4><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两种类型的区别是：存储位置不同。</span><br><span class="line">原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line"></span><br><span class="line">引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在</span><br><span class="line">栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实</span><br><span class="line">体。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</span><br><span class="line"></span><br><span class="line">基本数据类型....（参考1）</span><br><span class="line"></span><br><span class="line">复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</span><br><span class="line"></span><br><span class="line">两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中</span><br><span class="line">保存对应的指针来获取堆中的值。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/lxcao/article/details/52749421">《JavaScript 有几种类型的值？》</a><br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p><h4 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">堆和栈的概念存在于数据结构中和操作系统内存中。</span><br><span class="line"></span><br><span class="line">在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全</span><br><span class="line">二叉树是堆的一种实现方式。</span><br><span class="line"></span><br><span class="line">在操作系统中，内存被分为栈区和堆区。</span><br><span class="line"></span><br><span class="line">栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</span><br><span class="line"></span><br><span class="line">堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p><h4 id="4-内部属性-Class-是什么？"><a href="#4-内部属性-Class-是什么？" class="headerlink" title="4. 内部属性 [[Class]] 是什么？"></a>4. 内部属性 [[Class]] 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非</span><br><span class="line">传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( [1,2,3] );</span><br><span class="line">// &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( /regex-literal/i );</span><br><span class="line">// &quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="line">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="line">class Class1 &#123;&#125;</span><br><span class="line">Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;</span><br><span class="line">// 需要定制[[Class]]</span><br><span class="line">class Class2 &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    return &quot;Class2&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot;</span><br></pre></td></tr></table></figure><h4 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h4><p>涉及知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class="line">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class="line"></span><br><span class="line">标准内置对象的分类</span><br><span class="line"></span><br><span class="line">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class="line"></span><br><span class="line">例如 Infinity、NaN、undefined、null 字面量</span><br><span class="line"></span><br><span class="line">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class="line"></span><br><span class="line">例如 eval()、parseFloat()、parseInt() 等</span><br><span class="line"></span><br><span class="line">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class="line"></span><br><span class="line">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class="line"></span><br><span class="line">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class="line"></span><br><span class="line">例如 Number、Math、Date</span><br><span class="line"></span><br><span class="line">（5）字符串，用来表示和操作字符串的对象。</span><br><span class="line"></span><br><span class="line">例如 String、RegExp</span><br><span class="line"></span><br><span class="line">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class="line"></span><br><span class="line">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class="line"></span><br><span class="line">例如 Map、Set、WeakMap、WeakSet</span><br><span class="line"></span><br><span class="line">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class="line"></span><br><span class="line">例如 SIMD 等</span><br><span class="line"></span><br><span class="line">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class="line"></span><br><span class="line">例如 JSON 等</span><br><span class="line"></span><br><span class="line">（10）控制抽象对象</span><br><span class="line"></span><br><span class="line">例如 Promise、Generator 等</span><br><span class="line"></span><br><span class="line">（11）反射</span><br><span class="line"></span><br><span class="line">例如 Reflect、Proxy</span><br><span class="line"></span><br><span class="line">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class="line"></span><br><span class="line">例如 Intl、Intl.Collator 等</span><br><span class="line"></span><br><span class="line">（13）WebAssembly</span><br><span class="line"></span><br><span class="line">（14）其他</span><br><span class="line"></span><br><span class="line">例如 arguments</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函</span><br><span class="line">数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构</span><br><span class="line">造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24">《JS 所有内置对象属性和方法汇总》</a></p><h4 id="6-undefined-与-undeclared-的区别？"><a href="#6-undefined-与-undeclared-的区别？" class="headerlink" title="6. undefined 与 undeclared 的区别？"></a>6. undefined 与 undeclared 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class="line"></span><br><span class="line">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class="line">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure><h4 id="7-null-和-undefined-的区别？"><a href="#7-null-和-undefined-的区别？" class="headerlink" title="7. null 和 undefined 的区别？"></a>7. null 和 undefined 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line"></span><br><span class="line">undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line"></span><br><span class="line">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class="line">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class="line"></span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class="line">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html">《JavaScript 深入理解之 undefined 与 null》</a></p><h4 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</span><br><span class="line"></span><br><span class="line">表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</span><br><span class="line"></span><br><span class="line">按惯例我们用 void 0 来获得 undefined。</span><br></pre></td></tr></table></figure><h4 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在平常项目开发中，我们遵守一些这样的基本规范，比如说：</span><br><span class="line"></span><br><span class="line">（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时</span><br><span class="line">    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</span><br><span class="line"></span><br><span class="line">（2）代码中出现地址、时间等字符串时需要使用常量代替。</span><br><span class="line"></span><br><span class="line">（3）在进行比较的时候吧，尽量使用&#x27;===&#x27;, &#x27;!==&#x27;代替&#x27;==&#x27;, &#x27;!=&#x27;。</span><br><span class="line"></span><br><span class="line">（4）不要在内置对象的原型上添加方法，如 Array, Date。</span><br><span class="line"></span><br><span class="line">（5）switch 语句必须带有 default 分支。</span><br><span class="line"></span><br><span class="line">（6）for 循环必须使用大括号。</span><br><span class="line"></span><br><span class="line">（7）if 语句必须使用大括号。</span><br></pre></td></tr></table></figure><h4 id="10-JavaScript-原型，原型链？-有什么特点？"><a href="#10-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链？ 有什么特点？"></a>10. JavaScript 原型，原型链？ 有什么特点？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对</span><br><span class="line">象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部</span><br><span class="line">将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们</span><br><span class="line">是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这</span><br><span class="line">个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对</span><br><span class="line">象的原型。</span><br><span class="line"></span><br><span class="line">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又</span><br><span class="line">会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就</span><br><span class="line">是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与</span><br><span class="line">之相关的对象也会继承这一改变。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p><h4 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h4><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h4 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h4><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h4 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，</span><br><span class="line">即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中</span><br><span class="line">被定义为 Number.MIN_SAFE_INTEGER。</span><br><span class="line"></span><br><span class="line">如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次</span><br><span class="line">计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数</span><br><span class="line">来判断。</span><br></pre></td></tr></table></figure><h4 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a>14. typeof NaN 的结果是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出</span><br><span class="line">数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</span><br><span class="line"></span><br><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br><span class="line">NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN</span><br><span class="line">为 true。</span><br></pre></td></tr></table></figure><h4 id="15-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15. isNaN 和 Number.isNaN 函数的区别？"></a>15. isNaN 和 Number.isNaN 函数的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会</span><br><span class="line">返回 true ，会影响 NaN 的判断。</span><br><span class="line"></span><br><span class="line">函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为</span><br><span class="line">准确。</span><br></pre></td></tr></table></figure><h4 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样</span><br><span class="line">创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</span><br><span class="line"></span><br><span class="line">构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</span><br></pre></td></tr></table></figure><h4 id="17-其他值到字符串的转换规则？"><a href="#17-其他值到字符串的转换规则？" class="headerlink" title="17. 其他值到字符串的转换规则？"></a>17. 其他值到字符串的转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</span><br><span class="line"></span><br><span class="line">（1）Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</span><br><span class="line"></span><br><span class="line">（2）Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</span><br><span class="line"></span><br><span class="line">（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</span><br><span class="line"></span><br><span class="line">（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</span><br><span class="line"></span><br><span class="line">（3）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）</span><br><span class="line">    来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会</span><br><span class="line">    调用该方法并使用其返回值。</span><br></pre></td></tr></table></figure><h4 id="18-其他值到数字值的转换规则？"><a href="#18-其他值到数字值的转换规则？" class="headerlink" title="18. 其他值到数字值的转换规则？"></a>18. 其他值到数字值的转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</span><br><span class="line"></span><br><span class="line">（1）Undefined 类型的值转换为 NaN。</span><br><span class="line"></span><br><span class="line">（2）Null 类型的值转换为 0。</span><br><span class="line"></span><br><span class="line">（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</span><br><span class="line"></span><br><span class="line">（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</span><br><span class="line"></span><br><span class="line">（5）Symbol 类型的值不能转换为数字，会报错。</span><br><span class="line"></span><br><span class="line">（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</span><br><span class="line"></span><br><span class="line">为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</span><br><span class="line"></span><br><span class="line">如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</span><br></pre></td></tr></table></figure><h4 id="19-其他值到布尔类型的值的转换规则？"><a href="#19-其他值到布尔类型的值的转换规则？" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？"></a>19. 其他值到布尔类型的值的转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</span><br><span class="line"></span><br><span class="line">以下这些是假值：</span><br><span class="line">• undefined</span><br><span class="line">• null</span><br><span class="line">• false</span><br><span class="line">• +0、-0 和 NaN</span><br><span class="line">• &quot;&quot;</span><br><span class="line"></span><br><span class="line">假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</span><br></pre></td></tr></table></figure><h4 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="21-什么是假值对象？"><a href="#21-什么是假值对象？" class="headerlink" title="21. 什么是假值对象？"></a>21. 什么是假值对象？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和</span><br><span class="line">普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它</span><br><span class="line">是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</span><br></pre></td></tr></table></figure><h4 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</span><br><span class="line"></span><br><span class="line">~x 大致等同于 -(x+1)。</span><br></pre></td></tr></table></figure><h4 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu</span><br><span class="line">mber ()）不允许出现非数字字符，否则会失败并返回 NaN。</span><br></pre></td></tr></table></figure><h4 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. <code>+</code> 操作符什么时候用于字符串的拼接？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其</span><br><span class="line">中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以</span><br><span class="line">数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</span><br><span class="line"></span><br><span class="line">简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字</span><br><span class="line">加法。</span><br><span class="line"></span><br><span class="line">那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</span><br></pre></td></tr></table></figure><h4 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） if (..) 语句中的条件判断表达式。</span><br><span class="line">（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</span><br><span class="line">（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</span><br><span class="line">（4） ? : 中的条件判断表达式。</span><br><span class="line">（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</span><br></pre></td></tr></table></figure><h4 id="26-和-amp-amp-操作符的返回值？"><a href="#26-和-amp-amp-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件</span><br><span class="line">判断。</span><br><span class="line"></span><br><span class="line">对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</span><br><span class="line"></span><br><span class="line">&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</span><br><span class="line"></span><br><span class="line">|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</span><br></pre></td></tr></table></figure><h4 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</span><br><span class="line"></span><br><span class="line">Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果</span><br><span class="line">都是 true ）。</span><br></pre></td></tr></table></figure><h4 id="28-操作符的强制类型转换规则？"><a href="#28-操作符的强制类型转换规则？" class="headerlink" title="28. == 操作符的强制类型转换规则？"></a>28. == 操作符的强制类型转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</span><br><span class="line"></span><br><span class="line">（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</span><br><span class="line"></span><br><span class="line">（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</span><br><span class="line"></span><br><span class="line">（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</span><br><span class="line"></span><br><span class="line">（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</span><br><span class="line"></span><br><span class="line">（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/">《JavaScript 字符串间的比较》</a></p><h4 id="29-如何将字符串转化为数字，例如-‘12-3b’"><a href="#29-如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="29. 如何将字符串转化为数字，例如 ‘12.3b’?"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</span><br><span class="line"></span><br><span class="line">（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</span><br><span class="line"></span><br><span class="line">（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</span><br><span class="line"></span><br><span class="line">（4）使用 + 操作符的隐式转换。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p><h4 id="30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.<span class="title function_">replace</span>(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format1</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Intl</span>.<span class="title class_">NumberFormat</span>().<span class="title function_">format</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format2</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7">《JS 常用正则汇总》</a></p><h4 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h4><p><a href="http://www.hangge.com/blog/cache/detail_1872.html">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p><h4 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);</span><br><span class="line">    result.<span class="title function_">push</span>(arr[randomIndex]);</span><br><span class="line">    arr.<span class="title function_">splice</span>(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp,</span><br><span class="line">    len = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">    randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (len - index)) + index;</span><br><span class="line"></span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (length - index)) + index;</span><br><span class="line"></span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html">《JavaScript 学习笔记：数组随机排序》</a></p><h4 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js</span><br><span class="line">和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象</span><br><span class="line">创建方式，我了解到的方式有这么几种：</span><br><span class="line"></span><br><span class="line">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class="line"></span><br><span class="line">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class="line"></span><br><span class="line">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class="line"></span><br><span class="line">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class="line"></span><br><span class="line">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class="line"></span><br><span class="line">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br><span class="line"></span><br><span class="line">嗯我目前了解到的就是这么几种方式。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html">《JavaScript 深入理解之对象创建》</a></p><h4 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我了解的 js 中实现继承的几种方式有：</span><br><span class="line"></span><br><span class="line">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class="line"></span><br><span class="line">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class="line"></span><br><span class="line">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class="line"></span><br><span class="line">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html">《JavaScript 深入理解之继承》</a></p><h4 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayMyGrade</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My grade is &quot;</span> + <span class="variable language_">this</span>.<span class="property">grade</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="37-Javascript-的作用域链？"><a href="#37-Javascript-的作用域链？" class="headerlink" title="37. Javascript 的作用域链？"></a>37. Javascript 的作用域链？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和</span><br><span class="line">函数。</span><br><span class="line"></span><br><span class="line">作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前</span><br><span class="line">端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line"></span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br><span class="line"></span><br><span class="line">作用域链的创建过程跟执行上下文的建立有关....</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html">《JavaScript 深入理解之作用域链》</a></p><h4 id="38-谈谈-This-对象的理解"><a href="#38-谈谈-This-对象的理解" class="headerlink" title="38. 谈谈 This 对象的理解"></a>38. 谈谈 This 对象的理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模</span><br><span class="line">式来判断。</span><br></pre></td></tr></table></figure><ul><li><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p></li><li><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p></li><li><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p></li><li><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后</span><br><span class="line">是函数调用模式。</span><br></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 this 详解》</a></p><h4 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它的功能是把对应的字符串解析成 JS 代码并运行。</span><br><span class="line"></span><br><span class="line">应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">《eval()》</a></p><h4 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class="line"></span><br><span class="line">BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class="line">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class="line">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class="line">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class="line">象的子对象。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p><h4 id="41-写一个通用的事件侦听器函数"><a href="#41-写一个通用的事件侦听器函数" class="headerlink" title="41. 写一个通用的事件侦听器函数"></a>41. 写一个通用的事件侦听器函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventUtils</span> = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  <span class="attr">addEvent</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">addEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">detachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">stopPropagation</span>) &#123;</span><br><span class="line">      event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6">《JS 事件模型》</a></p><h4 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><ul><li><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p></li><li><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p></li><li><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h4 id="43-三种事件模型是什么？"><a href="#43-三种事件模型是什么？" class="headerlink" title="43. 三种事件模型是什么？"></a>43. 三种事件模型是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line"></span><br><span class="line">第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实</span><br><span class="line">现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class="line"></span><br><span class="line">第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class="line"></span><br><span class="line">第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h4 id="44-事件委托是什么？"><a href="#44-事件委托是什么？" class="headerlink" title="44. 事件委托是什么？"></a>44. 事件委托是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class="line">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class="line"></span><br><span class="line">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815">《JavaScript 事件委托详解》</a></p><h4 id="45-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#45-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="45. [“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 &quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;</span><br><span class="line"></span><br><span class="line">因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h4 id="46-什么是闭包，为什么要用它？"><a href="#46-什么是闭包，为什么要用它？" class="headerlink" title="46. 什么是闭包，为什么要用它？"></a>46. 什么是闭包，为什么要用它？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以</span><br><span class="line">访问到当前函数的局部变量。</span><br><span class="line"></span><br><span class="line">闭包有两个常用的用途。</span><br><span class="line"></span><br><span class="line">闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外</span><br><span class="line">部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class="line"></span><br><span class="line">函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以</span><br><span class="line">这个变量对象不会被回收。</span><br><span class="line"></span><br><span class="line">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html">《JavaScript 深入理解之闭包》</a></p><h4 id="47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</span><br><span class="line"></span><br><span class="line">设立&quot;严格模式&quot;的目的，主要有以下几个：</span><br></pre></td></tr></table></figure><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>1.禁止使用 with 语句。</li><li>2.禁止 this 关键字指向全局对象。</li><li>3.对象不能有重名的属性。</li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使</span><br><span class="line">用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一</span><br><span class="line">些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。</span><br><span class="line">我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">《Javascript 严格模式详解》</a></p><h4 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span><br><span class="line"></span><br><span class="line">第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</span><br><span class="line"></span><br><span class="line">第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的</span><br><span class="line">[[Class]] 属性来进行判断。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522">《js 判断一个对象是否属于某一类》</a></p><h4 id="49-instanceof-的作用？"><a href="#49-instanceof-的作用？" class="headerlink" title="49. instanceof 的作用？"></a>49. instanceof 的作用？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">《instanceof》</a></p><h4 id="50-new-操作符具体干了什么呢？如何实现？"><a href="#50-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50. new 操作符具体干了什么呢？如何实现？"></a>50. new 操作符具体干了什么呢？如何实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）首先创建了一个新的空对象</span></span><br><span class="line"><span class="comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span></span><br><span class="line"><span class="comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span></span><br><span class="line"><span class="comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>,</span><br><span class="line">    constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag =</span><br><span class="line">    result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="comment">// objectFactory(构造函数, 初始化参数);</span></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13">《JavaScript 深入之 new 的模拟实现》</a></p><h4 id="51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasOwnProperty</span><br><span class="line"></span><br><span class="line">所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和</span><br><span class="line">in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">《Object.prototype.hasOwnProperty()》</a></p><h4 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</span><br><span class="line"></span><br><span class="line">JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与</span><br><span class="line">值的映射）。</span><br><span class="line"></span><br><span class="line">JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</span><br><span class="line"></span><br><span class="line">在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</span><br><span class="line"></span><br><span class="line">因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</span><br><span class="line"></span><br><span class="line">在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</span><br><span class="line"></span><br><span class="line">另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368">《深入了解 JavaScript 中的 JSON 》</a></p><h4 id="53-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#53-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="53. [].forEach.call($$(““),function(a){a.style.outline=”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. [].forEach.call($$(“<em>“),function(a){a.style.outline=”1px solid #”+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</span><br><span class="line"></span><br><span class="line">（2）循环遍历 DOM 元素</span><br><span class="line"></span><br><span class="line">（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</span><br><span class="line"></span><br><span class="line">（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290">《通过一行代码学 JavaScript》</a></p><h4 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a>54. js 延迟加载的方式有哪些？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</span><br></pre></td></tr></table></figure><p>一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line"></span><br><span class="line">我了解到的几种方式是：</span><br><span class="line"></span><br><span class="line">第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line"></span><br><span class="line">第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line"></span><br><span class="line">第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line"></span><br><span class="line">第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h4 id="55-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55. Ajax 是什么? 如何创建一个 Ajax？"></a>55. Ajax 是什么? 如何创建一个 Ajax？</h4><p>相关知识点：</p><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的<br>异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>3.设置响应 HTTP 请求状态变化的函数</li><li>4.发送 HTTP 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 JavaScript 和 DOM 实现局部刷新</li></ul><p>一般实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="variable constant_">SERVER_URL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</span><br><span class="line"></span><br><span class="line">创建一个 ajax 有这样几个步骤</span><br><span class="line"></span><br><span class="line">首先是创建一个 XMLHttpRequest 对象。</span><br><span class="line"></span><br><span class="line">然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</span><br><span class="line"></span><br><span class="line">在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</span><br><span class="line"></span><br><span class="line">当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652">《传统 Ajax 已死，Fetch 永生》</a></p><h4 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</span><br><span class="line"></span><br><span class="line">web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</span><br><span class="line"></span><br><span class="line">使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</span><br><span class="line"></span><br><span class="line">服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</span><br><span class="line"></span><br><span class="line">Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，</span><br><span class="line">它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间</span><br><span class="line">的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires</span><br><span class="line">来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n</span><br><span class="line">o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</span><br><span class="line"></span><br><span class="line">一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。</span><br><span class="line"></span><br><span class="line">使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。</span><br><span class="line">如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</span><br><span class="line"></span><br><span class="line">服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，</span><br><span class="line">这样会造成缓存命中的不准确。</span><br><span class="line"></span><br><span class="line">因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</span><br><span class="line"></span><br><span class="line">当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</span><br><span class="line"></span><br><span class="line">强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08">《Cache-Control 字段值详解》</a></p><h4 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h4><ul><li><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p></li><li><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p></li><li><p>3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。</p></li><li><p>4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。</p></li><li><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a></p><h4 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </span><br><span class="line"></span><br><span class="line">异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返</span><br><span class="line">回为止再继续向下执行。</span><br><span class="line"></span><br><span class="line">异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等</span><br><span class="line">待消息的返回，当消息返回时系统再通知进程进行处理。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623">《同步和异步的区别》</a></p><h4 id="59-什么是浏览器的同源政策？"><a href="#59-什么是浏览器的同源政策？" class="headerlink" title="59. 什么是浏览器的同源政策？"></a>59. 什么是浏览器的同源政策？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个</span><br><span class="line">域的协议、域名、端口号必须相同，否则则不属于同一个域。</span><br><span class="line"></span><br><span class="line">同源政策主要限制了三个方面</span><br><span class="line"></span><br><span class="line">第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</span><br><span class="line"></span><br><span class="line">第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</span><br><span class="line"></span><br><span class="line">第三个是当前域下 ajax 无法发送跨域请求。</span><br><span class="line"></span><br><span class="line">同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者</span><br><span class="line">script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</span><br></pre></td></tr></table></figure><h4 id="60-如何解决跨域问题？"><a href="#60-如何解决跨域问题？" class="headerlink" title="60. 如何解决跨域问题？"></a>60. 如何解决跨域问题？</h4><p>相关知识点：</p><ul><li><ol><li>通过 jsonp 跨域</li></ol></li><li><ol start="2"><li>document.domain + iframe 跨域</li></ol></li><li><ol start="3"><li>location.hash + iframe</li></ol></li><li><ol start="4"><li>window.name + iframe 跨域</li></ol></li><li><ol start="5"><li>postMessage 跨域</li></ol></li><li><ol start="6"><li>跨域资源共享（CORS)</li></ol></li><li><ol start="7"><li>nginx 代理跨域</li></ol></li><li><ol start="8"><li>nodejs 中间件代理跨域</li></ol></li><li><ol start="9"><li>WebSocket 协议跨域</li></ol></li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">解决跨域的方法我们可以根据我们想要实现的目的来划分。</span><br><span class="line"></span><br><span class="line">首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</span><br><span class="line"></span><br><span class="line">（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</span><br><span class="line"></span><br><span class="line">如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</span><br><span class="line"></span><br><span class="line">（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</span><br><span class="line"></span><br><span class="line">（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</span><br><span class="line"></span><br><span class="line">（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</span><br><span class="line"></span><br><span class="line">如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</span><br><span class="line"></span><br><span class="line">（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</span><br><span class="line"></span><br><span class="line">（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</span><br><span class="line"></span><br><span class="line">非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</span><br><span class="line"></span><br><span class="line">（7）使用 websocket 协议，这个协议没有同源限制。</span><br><span class="line"></span><br><span class="line">（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p><h4 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h4><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4">《深入浅出 Nginx》</a></p><h4 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</span><br><span class="line"></span><br><span class="line">服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</span><br><span class="line"></span><br><span class="line">在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">《HTTP cookies》</a><br><a href="https://segmentfault.com/a/1190000004556040">《聊一聊 cookie》</a></p><h4 id="63-模块化开发怎么做？"><a href="#63-模块化开发怎么做？" class="headerlink" title="63. 模块化开发怎么做？"></a>63. 模块化开发怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class="line">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line"></span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class="line">染，并且模块间没有联系。</span><br><span class="line"></span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class="line">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line"></span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module">《Module 的语法》</a></p><h4 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案。</span><br><span class="line"></span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是</span><br><span class="line">服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式</span><br><span class="line">加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line"></span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定</span><br><span class="line">义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line"></span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js</span><br><span class="line">的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60</span><br><span class="line"></span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</span><br></pre></td></tr></table></figure><h4 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h4><p>它们之间的主要区别有两个方面。</p><p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇<br>就近依赖，只有在用到某个模块的时候再去 require。</p><p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br>模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br>在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br>的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789">《前端模块化，AMD 与 CMD 的区别》</a></p><h4 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异</h4><ul><li><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p></li><li><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ul><h4 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p><h4 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540">《JS 模块加载器加载原理是怎么样的？》</a></p><h4 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</span><br><span class="line"></span><br><span class="line">在 class 中添加的方法，其实是添加在类的原型上的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class">《Class 的基本语法》</a></p><h4 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.write 的内容会代替整个文档内容，会重写整个页面。</span><br><span class="line"></span><br><span class="line">innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50">《简述 document.write 和 innerHTML 的区别。》</a></p><h4 id="71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><p>（1）创建新节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createDocumentFragment</span>(node);</span><br><span class="line"><span class="title function_">createElement</span>(node);</span><br><span class="line"><span class="title function_">createTextNode</span>(text);</span><br></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">appendChild</span>(node)</span><br><span class="line"><span class="title function_">removeChild</span>(node)</span><br><span class="line"><span class="title function_">replaceChild</span>(<span class="keyword">new</span>,old)</span><br><span class="line"><span class="title function_">insertBefore</span>(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure><p>（3）查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getElementById</span>();</span><br><span class="line"><span class="title function_">getElementsByName</span>();</span><br><span class="line"><span class="title function_">getElementsByTagName</span>();</span><br><span class="line"><span class="title function_">getElementsByClassName</span>();</span><br><span class="line"><span class="title function_">querySelector</span>();</span><br><span class="line"><span class="title function_">querySelectorAll</span>();</span><br></pre></td></tr></table></figure><p>（4）属性操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getAttribute</span>(key);</span><br><span class="line"><span class="title function_">setAttribute</span>(key, value);</span><br><span class="line"><span class="title function_">hasAttribute</span>(key);</span><br><span class="line"><span class="title function_">removeAttribute</span>(key);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h4 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。</span><br><span class="line"></span><br><span class="line">innerHTML：内部 HTML，content&lt;br/&gt;；</span><br><span class="line">outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；</span><br><span class="line">innerText：内部文本，content ；</span><br><span class="line">outerText：内部文本，content ；</span><br></pre></td></tr></table></figure><h4 id="73-call-和-apply-的区别？"><a href="#73-call-和-apply-的区别？" class="headerlink" title="73. .call() 和 .apply() 的区别？"></a>73. .call() 和 .apply() 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它们的作用一模一样，区别仅在于传入参数的形式的不同。</span><br><span class="line"></span><br><span class="line">apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</span><br><span class="line"></span><br><span class="line">call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae">《apply、call 的区别和用途》</a></p><h4 id="74-JavaScript-类数组对象的定义？"><a href="#74-JavaScript-类数组对象的定义？" class="headerlink" title="74. JavaScript 类数组对象的定义？"></a>74. JavaScript 类数组对象的定义？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</span><br><span class="line"></span><br><span class="line">常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length</span><br><span class="line">属性值，代表可接收的参数个数。</span><br></pre></td></tr></table></figure><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/">《深入理解 JavaScript 类数组》</a></p><h4 id="75-数组和对象有哪些原生方法，列举一下？"><a href="#75-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75. 数组和对象有哪些原生方法，列举一下？"></a>75. 数组和对象有哪些原生方法，列举一下？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</span><br><span class="line"></span><br><span class="line">数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</span><br><span class="line"></span><br><span class="line">数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</span><br><span class="line"></span><br><span class="line">数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</span><br><span class="line"></span><br><span class="line">数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</span><br><span class="line"></span><br><span class="line">数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</span><br><span class="line"></span><br><span class="line">数组归并方法 reduce() 和 reduceRight() 方法</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 Array 类型详解》</a></p><h4 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</span><br><span class="line">fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">《Array.prototype.fill()》</a></p><h4 id="77-的长度？"><a href="#77-的长度？" class="headerlink" title="77. [,,,] 的长度？"></a>77. [,,,] 的长度？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</span><br><span class="line"></span><br><span class="line">JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAS</span><br><span class="line">cript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</span><br><span class="line"></span><br><span class="line">如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数</span><br><span class="line">量。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas">《尾后逗号》</a></p><h4 id="78-JavaScript-中的作用域与变量声明提升？"><a href="#78-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78. JavaScript 中的作用域与变量声明提升？"></a>78. JavaScript 中的作用域与变量声明提升？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</span><br><span class="line"></span><br><span class="line">造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html">《JavaScript 深入理解之变量对象》</a></p><h4 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h4><ul><li>1.使用位运算代替一些简单的四则运算。</li><li>2.避免使用过深的嵌套循环。</li><li>3.不要使用未定义的变量。</li><li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474">《如何编写高性能的 Javascript？》</a></p><h4 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line"></span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line"></span><br><span class="line">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line"></span><br><span class="line">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class="line"></span><br><span class="line">（2）如果对象不存活，则释放对象的空间。</span><br><span class="line"></span><br><span class="line">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class="line"></span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line"></span><br><span class="line">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class="line"></span><br><span class="line">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line"></span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332">《JavaScript 中的垃圾回收》</a></p><h4 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h4><p>相关知识点：</p><ul><li>1.意外的全局变量</li><li>2.被遗忘的计时器或回调函数</li><li>3.脱离 DOM 的引用</li><li>4.闭包</li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line"></span><br><span class="line">第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留</span><br><span class="line">在内存中，而无法被回收。</span><br><span class="line"></span><br><span class="line">第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回</span><br><span class="line">收。</span><br><span class="line"></span><br><span class="line">第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h4 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history</span><br><span class="line">对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可</span><br><span class="line">以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</span><br><span class="line"></span><br><span class="line">使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问</span><br><span class="line">题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">《Manipulating the browser history》</a></p><h4 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this === window ? &#x27;browser&#x27; : &#x27;node&#x27;;</span><br><span class="line"></span><br><span class="line">通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。</span><br></pre></td></tr></table></figure><h4 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018">《从 Chrome 源码看浏览器如何加载资源》</a></p><h4 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</span><br></pre></td></tr></table></figure><p>有三种办法来解决这个问题：</p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">《移动端 300ms 点击延迟和点击穿透》</a></p><h4 id="86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）什么是前端路由？</span><br><span class="line"></span><br><span class="line">前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</span><br><span class="line"></span><br><span class="line">（2）什么时候使用前端路由？</span><br><span class="line"></span><br><span class="line">在单页面应用，大部分页面结构不变，只改变部分内容的使用</span><br><span class="line"></span><br><span class="line">（3）前端路由有什么优点和缺点？</span><br><span class="line"></span><br><span class="line">优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</span><br><span class="line"></span><br><span class="line">缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</span><br><span class="line"></span><br><span class="line">前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137">《浅谈前端路由》</a><br><a href="https://www.zhihu.com/question/53064386">《前端路由是什么东西？》</a></p><h4 id="87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab">《浅谈前端单元测试》</a></p><h4 id="88-检测浏览器版本版本有哪些方式？"><a href="#88-检测浏览器版本版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本版本有哪些方式？"></a>88. 检测浏览器版本版本有哪些方式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">检测浏览器版本一共有两种方式：</span><br><span class="line"></span><br><span class="line">一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</span><br><span class="line"></span><br><span class="line">第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac">《JavaScript 判断浏览器类型》</a></p><h4 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</span><br><span class="line"></span><br><span class="line">比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</span><br><span class="line"></span><br><span class="line">一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1">《Polyfill 为何物》</a></p><h4 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> filename.<span class="title function_">slice</span>(((filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946">《如何更有效的获取文件扩展名》</a></p><h4 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>,</span><br><span class="line">      nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</span><br><span class="line"></span><br><span class="line">函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p><h4 id="92-Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两等号判等，会在比较时进行类型转换。</span><br><span class="line">三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。</span><br><span class="line"></span><br><span class="line">Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</span><br><span class="line"></span><br><span class="line">Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</span><br><span class="line"></span><br><span class="line">使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</span><br><span class="line"></span><br><span class="line">使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</span><br></pre></td></tr></table></figure><h4 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。</span><br><span class="line">它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</span><br><span class="line"></span><br><span class="line">encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</span><br><span class="line"></span><br><span class="line">escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h4 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</span><br><span class="line"></span><br><span class="line">UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h4 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line"></span><br><span class="line">微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</span><br><span class="line"></span><br><span class="line">宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲</span><br><span class="line">染等。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br><a href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h4 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        <span class="keyword">typeof</span> object[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</span><br><span class="line"></span><br><span class="line">深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p><h4 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h4 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p><h4 id="99-为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</span><br><span class="line"></span><br><span class="line">对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</span><br><span class="line"></span><br><span class="line">我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以</span><br><span class="line">使用 es6 的 Number.EPSILON</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !== 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p><h4 id="100-原码、反码和补码的介绍"><a href="#100-原码、反码和补码的介绍" class="headerlink" title="100. 原码、反码和补码的介绍"></a>100. 原码、反码和补码的介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</span><br><span class="line"></span><br><span class="line">正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。</span><br><span class="line">如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</span><br><span class="line"></span><br><span class="line">正数的补码和其原码一样；负数的补码为其反码加1。</span><br><span class="line"></span><br><span class="line">例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</span><br><span class="line">[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</span><br><span class="line"></span><br><span class="line">之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p><h4 id="101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>101. toPrecision 和 toFixed 和 Math.round 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。</span><br><span class="line">toFixed 是对小数点后指定位数取整，从小数点开始数起。</span><br><span class="line">Math.round 是将一个数字四舍五入到一个整数。</span><br></pre></td></tr></table></figure><h4 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</span><br><span class="line"></span><br><span class="line">XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">XSS 一般分为存储型、反射型和 DOM 型。</span><br><span class="line"></span><br><span class="line">存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。</span><br><span class="line"></span><br><span class="line">对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。</span><br><span class="line"></span><br><span class="line">因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</span><br><span class="line"></span><br><span class="line">还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</span><br><span class="line"></span><br><span class="line">还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p><h4 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</span><br><span class="line"></span><br><span class="line">通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta</span><br><span class="line">http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">《内容安全策略（CSP）》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2">《前端面试之道》</a></p><h4 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被</span><br><span class="line">攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</span><br><span class="line"></span><br><span class="line">CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</span><br><span class="line"></span><br><span class="line">一般的 CSRF 攻击类型有三种：</span><br><span class="line"></span><br><span class="line">第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提</span><br><span class="line">交。</span><br><span class="line"></span><br><span class="line">第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</span><br><span class="line"></span><br><span class="line">第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</span><br><span class="line"></span><br><span class="line">CSRF 可以用下面几种方法来防护：</span><br><span class="line"></span><br><span class="line">第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</span><br><span class="line"></span><br><span class="line">第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</span><br><span class="line"></span><br><span class="line">第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</span><br><span class="line"></span><br><span class="line">第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br><a href="https://www.jianshu.com/p/1f9c71850299">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p><h4 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。</span><br><span class="line"></span><br><span class="line">将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。</span><br><span class="line"></span><br><span class="line">将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。</span><br><span class="line"></span><br><span class="line">使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</span><br></pre></td></tr></table></figure><h4 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</span><br><span class="line"></span><br><span class="line">我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特</span><br><span class="line">定的一些情况才能作为 iframe 来使用。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/251704d8ff18">《web 安全之–点击劫持攻击与防御技术简介》</a></p><h4 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构</span><br><span class="line">造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bd5b820e51d456f72531fa8">《Web 安全漏洞之 SQL 注入》</a><br><a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">《如何防范常见的 Web 攻击》</a></p><h4 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</span><br><span class="line"></span><br><span class="line">比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</span><br><span class="line"></span><br><span class="line">MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Co</span><br><span class="line">ntroller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</span><br><span class="line"></span><br><span class="line">MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的</span><br><span class="line">Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</span><br><span class="line"></span><br><span class="line">MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功</span><br><span class="line">能。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468">《浅析前端开发中的 MVC/MVP/MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674">《一篇文章了解架构模式：MVC/MVP/MVVM》</a></p><h4 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。</span><br><span class="line"></span><br><span class="line">首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</span><br><span class="line"></span><br><span class="line">数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</span><br><span class="line"></span><br><span class="line">如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</span><br><span class="line"></span><br><span class="line">如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数</span><br><span class="line">据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></p><h4 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。</span><br><span class="line"></span><br><span class="line">一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">《Object.defineProperty()》</a></p><h4 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</span><br></pre></td></tr></table></figure><h4 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我对 Virtual DOM 的理解是，</span><br><span class="line"></span><br><span class="line">首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</span><br><span class="line"></span><br><span class="line">当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</span><br><span class="line"></span><br><span class="line">最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</span><br><span class="line"></span><br><span class="line">我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h4 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</span><br><span class="line"></span><br><span class="line">算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</span><br><span class="line"></span><br><span class="line">在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</span><br></pre></td></tr></table></figure><h4 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h4 id="115-谈谈你对-webpack-的看法"><a href="#115-谈谈你对-webpack-的看法" class="headerlink" title="115. 谈谈你对 webpack 的看法"></a>115. 谈谈你对 webpack 的看法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源</span><br><span class="line">数。</span><br><span class="line"></span><br><span class="line">我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</span><br><span class="line"></span><br><span class="line">Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</span><br><span class="line"></span><br><span class="line">Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</span><br><span class="line"></span><br><span class="line">Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</span><br><span class="line"></span><br><span class="line">loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。</span><br><span class="line"></span><br><span class="line">插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</span><br><span class="line"></span><br><span class="line">使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p><h4 id="116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。</span><br><span class="line">clientTop 返回的是上边框的宽度。</span><br><span class="line">clientLeft 返回的左边框的宽度。</span><br><span class="line"></span><br><span class="line">offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。</span><br><span class="line">offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。</span><br><span class="line">offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</span><br><span class="line"></span><br><span class="line">scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。</span><br><span class="line">scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。</span><br><span class="line">scrollLeft 属性返回的是元素滚动条到元素左边的距离。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p><h4 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。</span><br><span class="line"></span><br><span class="line">它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p><h4 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h4><p>相关资料：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">回调函数</span><br><span class="line">优点：简单、容易理解</span><br><span class="line">缺点：不利于维护，代码耦合高</span><br><span class="line"></span><br><span class="line">事件监听（采用时间驱动模式，取决于某个事件是否发生）：</span><br><span class="line">优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</span><br><span class="line">缺点：事件驱动型，流程不够清晰</span><br><span class="line"></span><br><span class="line">发布/订阅（观察者模式）</span><br><span class="line">类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</span><br><span class="line"></span><br><span class="line">Promise 对象</span><br><span class="line">优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；</span><br><span class="line">缺点：编写和理解，相对比较难</span><br><span class="line"></span><br><span class="line">Generator 函数</span><br><span class="line">优点：函数体内外的数据交换、错误处理机制</span><br><span class="line">缺点：流程管理不方便</span><br><span class="line"></span><br><span class="line">async 函数</span><br><span class="line">优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。</span><br><span class="line">缺点：错误处理机制</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js 中的异步机制可以分为以下几种：</span><br><span class="line"></span><br><span class="line">第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class="line"></span><br><span class="line">第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class="line"></span><br><span class="line">第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</span><br><span class="line"></span><br><span class="line">第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</span><br></pre></td></tr></table></figure><h4 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSS3 的动画的优点</span><br><span class="line"></span><br><span class="line">在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化</span><br><span class="line">代码相对简单</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line"></span><br><span class="line">在动画控制上不够灵活</span><br><span class="line">兼容性不好</span><br><span class="line"></span><br><span class="line">JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</span><br></pre></td></tr></table></figure><h4 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</span><br><span class="line"></span><br><span class="line">实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</span><br></pre></td></tr></table></figure><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h4 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URI: Uniform Resource Identifier      指的是统一资源标识符</span><br><span class="line">URL: Uniform Resource Location        指的是统一资源定位符</span><br><span class="line">URN: Universal Resource Name          指的是统一资源名称</span><br><span class="line"></span><br><span class="line">URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</span><br><span class="line"></span><br><span class="line">URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973">《URI、URL 和 URN 的区别》</a></p><h4 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</span><br><span class="line"></span><br><span class="line">post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p><h4 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</span><br><span class="line"></span><br><span class="line">懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</span><br><span class="line"></span><br><span class="line">两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</span><br><span class="line"></span><br><span class="line">预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</span><br><span class="line"></span><br><span class="line">这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/">《基于用户行为的图片等资源预加载》</a></p><h4 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。</span><br><span class="line"></span><br><span class="line">由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p><h4 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h4><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先是三个事件，分别是 mousedown，mousemove，mouseup</span><br><span class="line">当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。</span><br><span class="line">clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示</span><br><span class="line">元素的元素的初始坐标，移动的举例应该是：</span><br><span class="line">鼠标移动时候的坐标-鼠标按下去时候的坐标。</span><br><span class="line">也就是说定位信息为：</span><br><span class="line">鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠</span><br><span class="line">标抬起，拖拽过程结束。</span><br><span class="line"></span><br><span class="line">这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会</span><br><span class="line">执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状</span><br><span class="line">态。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠</span><br><span class="line">标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。</span><br><span class="line">最后 mouseup 事件触发后，清除状态，结束拖拽事件。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465">《原生 js 实现拖拽功能基本思路》</a></p><h4 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.<span class="property">flag</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</span><br><span class="line"></span><br><span class="line">针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737">《setInterval 有什么缺点？》</a></p><h4 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h4><ul><li>1.声明的变量只在声明时的代码块内有效</li><li>2.不存在声明提升</li><li>3.存在暂时性死区，如果在变量声明前使用，会报错</li><li>4.不允许重复声明，重复声明会报错</li></ul><h4 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest 参数（形式为...变量名），用于获取函数的多余参数。</span><br></pre></td></tr></table></figure><h4 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</span><br></pre></td></tr></table></figure><h4 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h4><ul><li>1.Symbol 函数前不能使用 new 命令，否则会报错。</li><li>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ul><h4 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h4><ul><li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</li></ul><h4 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h4><ul><li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h4 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</span><br><span class="line"></span><br><span class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</span><br></pre></td></tr></table></figure><h4 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h4><ul><li>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li><li>2.修改某些 Object 方法的返回结果，让其变得更合理。</li><li>3.让 Object 操作都变成函数行为。</li><li>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li></ul><h4 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当 Node 遇到 require(X) 时，按下面的顺序处理。</span><br><span class="line"></span><br><span class="line">（1）如果 X 是内置模块（比如 require(&#x27;http&#x27;)）</span><br><span class="line">　　a. 返回该模块。</span><br><span class="line">　　b. 不再继续执行。</span><br><span class="line"></span><br><span class="line">（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 的绝对路径。</span><br><span class="line">　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X</span><br><span class="line">    X.js</span><br><span class="line">    X.json</span><br><span class="line">    X.node</span><br><span class="line"></span><br><span class="line">　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X/package.json（main字段）</span><br><span class="line">    X/index.js</span><br><span class="line">    X/index.json</span><br><span class="line">    X/index.node</span><br><span class="line"></span><br><span class="line">（3）如果 X 不带路径</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。</span><br><span class="line">　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</span><br><span class="line"></span><br><span class="line">（4）抛出 &quot;not found&quot;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html">《require() 源码解读》</a></p><h4 id="136-什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises/A+ 规范？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</span><br><span class="line"></span><br><span class="line">Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们</span><br><span class="line">可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566">《Promises/A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">《Promise》</a></p><h4 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESOLVED</span> = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存初始化状态</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 rejected 传入的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 的回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">resolvedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 reject 的回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 resolved 方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变，</span></span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.<span class="property">state</span> = <span class="variable constant_">RESOLVED</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.<span class="property">resolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 rejected 方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变</span></span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.<span class="property">rejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将两个方法传入函数执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 遇到错误时，捕获错误，执行 reject 函数</span></span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是等待状态，则将函数加入对应列表中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvedCallbacks</span>.<span class="title function_">push</span>(onResolved);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span>.<span class="title function_">push</span>(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果状态已经凝固，则直接执行对应状态的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">RESOLVED</span>) &#123;</span><br><span class="line">    <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</span><br></pre></td></tr></table></figure><h4 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error 统计使用浏览器的 window.error 事件。</span><br></pre></td></tr></table></figure><h4 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</span><br></pre></td></tr></table></figure><h4 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候</span><br><span class="line">用来将视图层的方法定义和方法调用分离。</span><br></pre></td></tr></table></figure><h4 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</span><br></pre></td></tr></table></figure><h4 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</span><br></pre></td></tr></table></figure><h4 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种</span><br><span class="line">新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种</span><br><span class="line">自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</span><br></pre></td></tr></table></figure><p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d">《JavaScript 中常见设计模式整理》</a></p><h4 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发布订阅模式其实属于广义上的观察者模式</span><br><span class="line"></span><br><span class="line">在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</span><br><span class="line"></span><br><span class="line">而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749">《观察者模式和发布订阅模式有什么不同？》</a></p><h4 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</span><br></pre></td></tr></table></figure><h4 id="147-Vue-的各个生命阶段是什么？"><a href="#147-Vue-的各个生命阶段是什么？" class="headerlink" title="147. Vue 的各个生命阶段是什么？"></a>147. Vue 的各个生命阶段是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</span><br><span class="line"></span><br><span class="line">（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。</span><br><span class="line"></span><br><span class="line">（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</span><br><span class="line"></span><br><span class="line">（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</span><br><span class="line"></span><br><span class="line">（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。</span><br><span class="line"></span><br><span class="line">（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</span><br><span class="line"></span><br><span class="line">（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</span><br><span class="line"></span><br><span class="line">（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</span><br><span class="line"></span><br><span class="line">（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line"></span><br><span class="line">当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html">《Vue 实例》</a></p><h4 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">（1）父子组件间通信</span><br><span class="line"></span><br><span class="line">第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事</span><br><span class="line">件来向父组件发送数据。</span><br><span class="line"></span><br><span class="line">第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组</span><br><span class="line">件，这样也可以实现通信。</span><br><span class="line"></span><br><span class="line">第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件</span><br><span class="line">中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</span><br><span class="line"></span><br><span class="line">（2）兄弟组件间通信</span><br><span class="line"></span><br><span class="line">第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实</span><br><span class="line">例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</span><br><span class="line"></span><br><span class="line">第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。</span><br><span class="line"></span><br><span class="line">（3）任意组件之间</span><br><span class="line"></span><br><span class="line">使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候</span><br><span class="line">可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个</span><br><span class="line">公共数据进行读写操作，这样达到了解耦的目的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345">《VUE 组件之间数据传递全集》</a></p><h4 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</span><br><span class="line"></span><br><span class="line">（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</span><br><span class="line"></span><br><span class="line">（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h4 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）全局的钩子函数 beforeEach 和 afterEach</span><br><span class="line"></span><br><span class="line">beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</span><br><span class="line"></span><br><span class="line">（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</span><br><span class="line"></span><br><span class="line">（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组</span><br><span class="line">件内部直接进行定义的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p><h4 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span><br></pre></td></tr></table></figure><h4 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</span><br></pre></td></tr></table></figure><h4 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue 中 key 值的作用可以分为两种情况来考虑。</span><br><span class="line"></span><br><span class="line">第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span><br><span class="line"></span><br><span class="line">第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h4 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</span><br><span class="line"></span><br><span class="line">watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</span><br></pre></td></tr></table></figure><h4 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</span><br></pre></td></tr></table></figure><h4 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mixin 用于全局混入，会影响到每个组件实例。</span><br><span class="line"></span><br><span class="line">mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h4 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL</span><br><span class="line">转码。</span><br><span class="line"></span><br><span class="line">（2）multipart/form-data</span><br><span class="line"></span><br><span class="line">该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</span><br><span class="line"></span><br><span class="line">（3）application/json</span><br><span class="line"></span><br><span class="line">告诉服务器消息主体是序列化后的 JSON 字符串。</span><br><span class="line"></span><br><span class="line">（4）text/xml</span><br><span class="line"></span><br><span class="line">该种方式主要用来提交 XML 格式的数据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">《常用的几种 Content-Type》</a></p><h4 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value),</span><br><span class="line">      type = valueClass.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    type.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/28">《JavaScript 专题之类型判断(上)》</a></p><h4 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkNullObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/FungLeo/article/details/78113661">《js 判断一个 object 对象是否为空》</a></p><h4 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, params, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否含有参数</span></span><br><span class="line">  <span class="keyword">let</span> queryString = url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) === <span class="string">&quot;-1&quot;</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.<span class="title function_">hasOwnProperty</span>(k)) &#123;</span><br><span class="line">      queryString += k + <span class="string">&quot;=&quot;</span> + params[k] + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数名</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">      .<span class="title function_">toString</span>()</span><br><span class="line">      .<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    callbackName = <span class="string">&quot;myJsonp&quot;</span> + random;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  queryString += <span class="string">&quot;callback=&quot;</span> + callbackName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建请求</span></span><br><span class="line">  <span class="keyword">let</span> scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  scriptNode.<span class="property">src</span> = url + queryString;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>[callbackName] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="title function_">callback</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除这个引入的脚本</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/zzc5464/p/jsonp.html">《原生 jsonp 具体实现》</a><br><a href="https://segmentfault.com/a/1190000007665361#articleHeader1">《jsonp 的原理与实现》</a></p><h4 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听函数</span></span><br><span class="line">    <span class="attr">subscribe</span>: <span class="keyword">function</span>(<span class="params">topic, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      topics[topic].<span class="title function_">push</span>(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件，触发观察者回调事件</span></span><br><span class="line">    <span class="attr">publish</span>: <span class="keyword">function</span>(<span class="params">topic, info</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">          <span class="title function_">handler</span>(info);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的一个观察者的回调事件</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="keyword">function</span>(<span class="params">topic, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.<span class="title function_">hasOwnProperty</span>(topic)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> handlerIndex = -<span class="number">1</span>;</span><br><span class="line">      topics[topic].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === handler) &#123;</span><br><span class="line">          handlerIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        topics[topic].<span class="title function_">splice</span>(handlerIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的所有观察者的回调事件</span></span><br><span class="line">    <span class="attr">removeAll</span>: <span class="keyword">function</span>(<span class="params">topic</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader1">《JS 事件模型》</a></p><h4 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event] || [];</span><br><span class="line">    callbacks.<span class="title function_">push</span>(callback);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = callbacks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = callbacks &amp;&amp; callbacks.<span class="title function_">filter</span>(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line">    callbacks.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapFun = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(...args);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(event, wrapFun);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(event, wrapFun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/Wscats/Good-text-Share/issues/85">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br><a href="https://segmentfault.com/q/1010000008430170">《一道考察运算符优先级的 JavaScript 面试题》</a><br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">《一道常被人轻视的前端 JS 面试题》</a></p><h4 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</span><br><span class="line"></span><br><span class="line">使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</span><br><span class="line"></span><br><span class="line">为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒</span><br><span class="line">的千分之一（1秒的百万分之一）。</span><br><span class="line"></span><br><span class="line">navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</span><br><span class="line"></span><br><span class="line">loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</span><br></pre></td></tr></table></figure><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.<span class="property">timing</span>;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.<span class="property">loadEventEnd</span> - t.<span class="property">navigationStart</span>;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h4 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）第一个字符必须是字母、下划线（_）或美元符号（$）</span><br><span class="line">（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</span><br><span class="line"></span><br><span class="line">一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp">《ECMAScript 变量》</a></p><h4 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有</span><br><span class="line">利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</span><br></pre></td></tr></table></figure><h4 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br></pre></td></tr></table></figure><h4 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</span><br><span class="line"></span><br><span class="line">Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</span><br></pre></td></tr></table></figure><h4 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span></span><br><span class="line"><span class="comment">// 当判断语句为空时，循环会一直进行。</span></span><br></pre></td></tr></table></figure><h4 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</span><br><span class="line"></span><br><span class="line">（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</span><br><span class="line"></span><br><span class="line">（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</span><br></pre></td></tr></table></figure><h4 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</span><br><span class="line"></span><br><span class="line">一般解决倒计时中的误差的有这样两种办法：</span><br><span class="line"></span><br><span class="line">（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc">《JavaScript 前端倒计时纠偏实现》</a></p><h4 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h4><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">《进程与线程的一个简单解释》</a></p><h4 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMostWord</span>(<span class="params">article</span>) &#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> wordList = article.<span class="title function_">match</span>(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.<span class="title function_">join</span>(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.<span class="title function_">push</span>(item);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.<span class="title function_">match</span>(word).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JavaScript-面试知识点总结&quot;&gt;&lt;a href=&quot;#JavaScript-面试知识点总结&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 面试知识点总结&quot;&gt;&lt;/a&gt;JavaScript 面试知识点总结&lt;/h2&gt;&lt;p&gt;本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试智力题</title>
    <link href="https://qyjs.github.io/2020/09/21/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <id>https://qyjs.github.io/2020/09/21/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><p>本部分主要是笔者在练习常见面试智力题所做的笔记，如果出现错误，希望大家指出！</p><h2 id="常见智力题"><a href="#常见智力题" class="headerlink" title="常见智力题"></a>常见智力题</h2><ol><li><p>时针与分针夹角度数问题？</p><p>分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</span><br><span class="line"></span><br><span class="line">我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。</span><br><span class="line"></span><br><span class="line">时针每走一格为 30 度。</span><br><span class="line"></span><br><span class="line">因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。</span><br><span class="line"></span><br><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; </span><br></pre></td></tr></table></figure><p>详细资料参考：<br><a href="https://blog.csdn.net/prstaxy/article/details/22210829">《面试智力题 — 时针与分针夹角度数问题》</a></p></li><li><p>用3升，5升杯子怎么量出4升水？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。</span><br><span class="line"></span><br><span class="line">（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。</span><br><span class="line"></span><br><span class="line">（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</span><br></pre></td></tr></table></figure></li><li><p>四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。</span><br><span class="line"></span><br><span class="line">（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。</span><br><span class="line"></span><br><span class="line">（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4</span><br><span class="line">    片药片。</span><br><span class="line"></span><br><span class="line">（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</span><br></pre></td></tr></table></figure></li><li><p>四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1<br>我只能翻两张牌，我翻哪两张？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</span><br></pre></td></tr></table></figure></li><li><p>赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我认为一共至少需要 7 次才能选出最快的三匹马。</span><br><span class="line"></span><br><span class="line">（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直</span><br><span class="line">    接淘汰掉，那么我们现在还剩下了 15 匹马。</span><br><span class="line"></span><br><span class="line">（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余</span><br><span class="line">    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，</span><br><span class="line">    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，</span><br><span class="line">    它们都有竞争最快第二第三的机会。</span><br><span class="line"></span><br><span class="line">（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</span><br></pre></td></tr></table></figure></li><li><p>五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都<br>不同，那么A的配偶握手了几次？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。</span><br><span class="line"></span><br><span class="line">（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因</span><br><span class="line">    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。</span><br><span class="line"></span><br><span class="line">（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有</span><br><span class="line">    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。</span><br><span class="line"></span><br><span class="line">（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手</span><br><span class="line">    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数</span><br><span class="line">    为 1 的人是配偶。</span><br><span class="line"></span><br><span class="line">（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。</span><br><span class="line"></span><br><span class="line">（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。</span><br><span class="line"></span><br><span class="line">（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</span><br></pre></td></tr></table></figure><span id="more"></span></li><li><p>你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。</span><br><span class="line"></span><br><span class="line">（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路</span><br><span class="line">    程。</span><br></pre></td></tr></table></figure></li><li><p>烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。</span><br><span class="line">  </span><br><span class="line">（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。</span><br><span class="line"></span><br><span class="line">（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。</span><br><span class="line"></span><br><span class="line">（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。</span><br><span class="line"></span><br><span class="line">（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</span><br></pre></td></tr></table></figure></li><li><p>有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。</span><br><span class="line"></span><br><span class="line">（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。</span><br><span class="line"></span><br><span class="line">（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</span><br></pre></td></tr></table></figure></li><li><p>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果<br>有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回<br>的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此</span><br><span class="line">两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</span><br></pre></td></tr></table></figure></li><li><p>你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最<br>大的选中机会？在你的计划中，得到红球的准确几率是多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</span><br></pre></td></tr></table></figure></li><li><p>假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找<br>出这个较重的球？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最少两次可以称出。</span><br><span class="line"></span><br><span class="line">首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。</span><br><span class="line"></span><br><span class="line">第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如</span><br><span class="line">果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</span><br></pre></td></tr></table></figure></li><li><p>在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一<br>盏灯？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）首先打开一盏灯 10 分钟，然后打开第二盏。</span><br><span class="line">（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开</span><br><span class="line">    的。</span><br></pre></td></tr></table></figure></li><li><p>他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心<br>将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</span><br></pre></td></tr></table></figure></li><li><p>有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说<br>筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。</span><br><span class="line"></span><br><span class="line">对应水果标签的筐的标签改为另一种水果。</span><br><span class="line"></span><br><span class="line">另一种水果标签的框改为混合。</span><br></pre></td></tr></table></figure></li><li><p>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。</span><br><span class="line"></span><br><span class="line">（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多</span><br><span class="line">    90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。</span><br><span class="line"></span><br><span class="line">因此三种球都喜欢的人占比为 10%-60%</span><br></pre></td></tr></table></figure></li><li><p>五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</span><br></pre></td></tr></table></figure><p>更多的智力题可以参考：<br><a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题200+题和解答》</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常见面试智力题总结&quot;&gt;&lt;a href=&quot;#常见面试智力题总结&quot; class=&quot;headerlink&quot; title=&quot;常见面试智力题总结&quot;&gt;&lt;/a&gt;常见面试智力题总结&lt;/h1&gt;&lt;p&gt;本部分主要是笔者在练习常见面试智力题所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;
&lt;h2 id=&quot;常见智力题&quot;&gt;&lt;a href=&quot;#常见智力题&quot; class=&quot;headerlink&quot; title=&quot;常见智力题&quot;&gt;&lt;/a&gt;常见智力题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;时针与分针夹角度数问题？&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;时针每走一格为 30 度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;答案：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;详细资料参考：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/prstaxy/article/details/22210829&quot;&gt;《面试智力题 — 时针与分针夹角度数问题》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用3升，5升杯子怎么量出4升水？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    片药片。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1&lt;br&gt;我只能翻两张牌，我翻哪两张？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;我认为一共至少需要 7 次才能选出最快的三匹马。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    接淘汰掉，那么我们现在还剩下了 15 匹马。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    它们都有竞争最快第二第三的机会。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都&lt;br&gt;不同，那么A的配偶握手了几次？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    为 1 的人是配偶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Offer" scheme="https://qyjs.github.io/categories/Offer/"/>
    
    
    <category term="Offer" scheme="https://qyjs.github.io/tags/Offer/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统</title>
    <link href="https://qyjs.github.io/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://qyjs.github.io/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p>本部分主要是笔者在学习现代操作系统和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p><h2 id="现代操作系统阅读笔记"><a href="#现代操作系统阅读笔记" class="headerlink" title="现代操作系统阅读笔记"></a>现代操作系统阅读笔记</h2><h3 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h3><h4 id="1-操作系统定义"><a href="#1-操作系统定义" class="headerlink" title="1. 操作系统定义"></a>1. 操作系统定义</h4><p>操作系统是运行在内核态的软件，它执行两个基本上独立的任务。</p><ul><li><p>隐藏计算机底层硬件的实现，为用户及应用程序提供一个资源集的清晰抽象。</p></li><li><p>管理计算机硬件资源。</p></li></ul><p>任何操作系统的核心是它可处理的系统调用集。这些系统带欧阳真实地说明了操作系统做的工作。</p><h4 id="2-计算机运行模式"><a href="#2-计算机运行模式" class="headerlink" title="2. 计算机运行模式"></a>2. 计算机运行模式</h4><p>多数计算机有两种运行模式：内核态和用户态。</p><p>软件中最基础的部分是操作系统，它运行在内核态。这内核态模式下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下，在用户态下，只能使用机器指令中的一个子集。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-1.png" alt="计算机运行模式"></p><h4 id="3-shell-与-GUI"><a href="#3-shell-与-GUI" class="headerlink" title="3. shell 与 GUI"></a>3. shell 与 GUI</h4><p>用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（GUI）。</p><p>它们并不是操作系统的一部分，它们是运行在用户态最低层次的用户接口程序</p><h4 id="4-对于抽象的理解"><a href="#4-对于抽象的理解" class="headerlink" title="4. 对于抽象的理解"></a>4. 对于抽象的理解</h4><p>现代计算机系统中，大量使用了抽象这一概念。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其中第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。</p><p>以抽象的角度看操作系统，它的任务就是创建好的抽象，并实现和管理它所创建的抽象。</p><h4 id="5-多路复用资源方式"><a href="#5-多路复用资源方式" class="headerlink" title="5. 多路复用资源方式"></a>5. 多路复用资源方式</h4><p>在时间上复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。</p><p>在空间上复用：每个客户得到资源的一部分。</p><h4 id="6-I-O-设备的结构"><a href="#6-I-O-设备的结构" class="headerlink" title="6. I/O 设备的结构"></a>6. I/O 设备的结构</h4><p>I/O 设备一般包括两个部分：设备控制器和设备本身。控制器插在电路板上的一块芯片或一组芯片，这块电路板物理地控制芯片，它从操作系统接收命令。</p><p>控制器的任务是为操作系统提供一个简单的接口。每类设备控制器是不同的，所以需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。为了使用设备驱动程序，必须要把设备驱动程序装入到操作系统中，这样它可在核心态中运行。</p><p>每个设备控制器都有少量的用于通信的寄存器，所有的寄存器的集合构成了I/O 空间。</p><h4 id="7-IDE-概念"><a href="#7-IDE-概念" class="headerlink" title="7. IDE 概念"></a>7. IDE 概念</h4><p>IDE 表示集成驱动电子设备，是许多计算机的磁盘标准。</p><h4 id="8-实现输入输出的三种方式"><a href="#8-实现输入输出的三种方式" class="headerlink" title="8. 实现输入输出的三种方式"></a>8. 实现输入输出的三种方式</h4><p>第一种方式，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。当 I/O 结束后，设备驱动程序把数据送到指定的地方（若有此需要），并返回。然后操作系统将控制返回给调用者。这种方式称为忙等待（busy waiting），其缺点是要占据CPU ，CPU 一直轮询设备直到对应的 I/O 操作完成。</p><p>第二种方式，设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成。</p><p>  <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-2.png" alt="终端实例"></p><p>第三种方式，为I/O使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预。</p><h4 id="9-CMOS-存储器"><a href="#9-CMOS-存储器" class="headerlink" title="9. CMOS 存储器"></a>9. CMOS 存储器</h4><p>CMOS 存储器是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。 CMOS 存储器和递增时间的时钟电路有一块小电池驱动，所以，即使计算机没有上电，时间也可以正确地更新。</p><h4 id="10-USB-概念"><a href="#10-USB-概念" class="headerlink" title="10. USB 概念"></a>10. USB 概念</h4><p>USB 是通用串行总线，是用来将所有的慢速 I/O 设备，诸如键盘和鼠标，与计算机相连。USB 是一种集中式总线，其根设备每 1ms 轮询一次 I/O 设备，看是否有消息收发。所有的 USB 设备共享一个 USB 设备驱动器，于是就不需要为新的 USB 设备安装新的设备驱动器了。</p><h4 id="11-即插即用概念"><a href="#11-即插即用概念" class="headerlink" title="11. 即插即用概念"></a>11. 即插即用概念</h4><p>在一般的计算机工作环境下，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求导致了 Intel 和微软设计了一种名为即插即用的 I/O 系统。</p><p>在即插即用之前，每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。即插即用所做的工作是，系统自动地收集有关 I/O 设备的信息，集中赋予 I/O 地址，然后通知每块卡所用的数值。</p><h4 id="12-计算机的启动"><a href="#12-计算机的启动" class="headerlink" title="12. 计算机的启动"></a>12. 计算机的启动</h4><p>Pentium 的简要启动过程如下。在每个 Pentium 上有一块母板。在母板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序存放在一块闪速 RAM 中，它是非可易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。</p><p>简要过程如下：</p><ol><li><p>BIOS 开始运行。它首先检查计算机设备的状态信息是否正常。</p></li><li><p>扫描并记录总线所连设备。</p></li><li><p>依次搜索启动设备，导入操作系统。</p></li><li><p>操作系统询问 BIOS ，获得配置信息，获取所有设备的驱动程序并调入内核。</p></li><li><p>初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。</p></li></ol><h4 id="13-操作系统分类"><a href="#13-操作系统分类" class="headerlink" title="13. 操作系统分类"></a>13. 操作系统分类</h4><p>大型机操作系统、服务器操作系统、多处理器操作系统、个人计算机操作系统、掌上计算机操作系统、嵌入式操作系统、传感器节点操作系统、实时操作系统、智能卡操作系统</p><h4 id="14-实时操作系统的基本概念"><a href="#14-实时操作系统的基本概念" class="headerlink" title="14. 实时操作系统的基本概念"></a>14. 实时操作系统的基本概念</h4><p>实时操作系统的特征是将时间作为关键参数。通常分为硬实时操作系统和软实时操作系统。</p><p>在硬实时操作系统中，某个规定的动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p><p>在软实时操作系统中，偶尔违反最终时限是不希望的，但可以接受，并且不会引起任何实时性的损害。</p><h4 id="15-UID"><a href="#15-UID" class="headerlink" title="15. UID"></a>15. UID</h4><p>系统管理器授权每个进程使用一个给定的 UID 标识。每个被启动的进程都有一个启动该进程的用户 UID 。子进程与父进程拥有一样 UID。用户可以是某个组的成员，每个组也有一个 GID 标识。</p><h4 id="16-文件路径"><a href="#16-文件路径" class="headerlink" title="16. 文件路径"></a>16. 文件路径</h4><p>在 UNIX 中，绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用正斜线 <code>/</code> 隔开。最开始的正斜线标识这是从根目录开始的绝对路径。</p><p>在 MS-DOS 和 Windows 中，用反斜线 <code>\</code> 作为分隔符。</p><h4 id="17-文件系统安装"><a href="#17-文件系统安装" class="headerlink" title="17. 文件系统安装"></a>17. 文件系统安装</h4><p>UNIX 一个重要概念是安装文件系统。几乎所有的个人计算机都有一个或多个光盘驱动器，可以插入 CD-ROM 和 DV D。它们几乎都有 USB 接口，可以插入 USB 存储棒（实际是固态磁盘驱动器）。为了提供一个出色的方式处理可移动介质，UNIX 允许把在 CD-ROM 或 DVD 上的文件系统接入到主文件树上。 mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。</p><h4 id="18-特殊文件"><a href="#18-特殊文件" class="headerlink" title="18. 特殊文件"></a>18. 特殊文件</h4><p>提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可通过同样的系统调用进行读写。</p><p>有两类特殊文件：块特殊文件和字符特殊文件。</p><p>块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第4块，程序可以直接访问设备的第4块而不必考虑存放该文件的文件系统结构。</p><p>字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在 /dev 目录中。例如，/dev/lp是打印机。</p><h4 id="19-文件保护"><a href="#19-文件保护" class="headerlink" title="19. 文件保护"></a>19. 文件保护</h4><p>UNIX 操作系统通过对每个文件赋予一个9位的二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个3位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的 rwx 位。</p><h4 id="20-系统调用概念"><a href="#20-系统调用概念" class="headerlink" title="20. 系统调用概念"></a>20. 系统调用概念</h4><p>如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。</p><h4 id="21-POSIX"><a href="#21-POSIX" class="headerlink" title="21. POSIX"></a>21. POSIX</h4><p>UNIX 有很多不兼容的版本，从而导致了混乱。为了能使编写的程序能够在任何版本的 UNIX 系统运行，IEEE提出了一个 UNIX 标准，称为 POSIX，目前大多数 UNIX 版本都支持他。 POSIX 标准定义了凡是 UNIX 必须支持的小型系统调用接口。</p><h4 id="22-Windows-Win32-API"><a href="#22-Windows-Win32-API" class="headerlink" title="22. Windows Win32 API"></a>22. Windows Win32 API</h4><p>Windows 和 UNIX 的主要差别在于编程方式。一个 UNIX 程序包括做各种处理的代码以及从事完成特定服务的系统调用。相反，一个 Windows 程序通常是一个事件驱动程序。其中主程序等待某些事件发生，然后调用一个过程处理该事件。</p><p>在 UNIX 中，系统调用（如read）和系统调用所使用的库过程（如read）之间几乎是一一对应的关系。换句话说，对于每个系统调用，差不多就涉及一个被调用的库过程。</p><p>在 Windows 中，情况就大不相同了。首先，库调用和实际的系统调用是几乎不对应的。微软定义了一套过程，称为应用编程接口（Application Program Interface，Win32 API），程序员用这套过程获得操作系统的服务。</p><p>Win32 并不是非常统一的或有一致的接口。其主要原因是由于 Win32 需要与早期的在 Windows 3.x 中使用的16位接口向后兼容。</p><p>Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。</p><h4 id="23-操作系统结构"><a href="#23-操作系统结构" class="headerlink" title="23. 操作系统结构"></a>23. 操作系统结构</h4><p>单体结构、层次式结构、微内核、客户机-服务器模式、虚拟机、外核、</p><h4 id="24-微内核的概念"><a href="#24-微内核的概念" class="headerlink" title="24. 微内核的概念"></a>24. 微内核的概念</h4><p>在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。</p><h4 id="25-机制与策略分离原则"><a href="#25-机制与策略分离原则" class="headerlink" title="25. 机制与策略分离原则"></a>25. 机制与策略分离原则</h4><p>策略指的是做什么，机制指的是怎么做。例如一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程以优先级）可以由用户态中的进程完成。在这个方式中，机制和策略是分离的，从而使系统内核变得更小。</p><h4 id="26-make-程序"><a href="#26-make-程序" class="headerlink" title="26. make 程序"></a>26. make 程序</h4><p>在 UNIX 系统中，有个名为 make 的程序（其大量的变体如 gmake、pmake 等），它读入 Makefile ，该 Makefile 说明哪个文件与哪个文件相关。make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后，是否有任何它依赖（代码和头文件）的文件已经被修改了。如果有，目标文件需要重新编译。在大型项目中，创建 Makefile 是一件容易出错的工作，所以出现了一些工具使该工作能够自动完成。</p><span id="more"></span><h3 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h3><h4 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h4><h4 id="1-进程模型"><a href="#1-进程模型" class="headerlink" title="1. 进程模型"></a>1. 进程模型</h4><p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p><p>由于CPU在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常也不可再现。所以，在对进程编程时决不能对时序做任何确定的假设。</p><h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><p>有4种主要事件导致进程的创建：</p><ul><li><p><strong>系统初始化</strong></p><blockquote><p>启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反，却具有某些专门的功能。停留在后台处理诸如电子邮件、Web 页面、新闻、打印之类活动的进程称为守护进程</p></blockquote></li><li><p><strong>执行了正在运行的进程所调用的进程创建系统调用</strong></p><blockquote><p>一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以容易地划分成若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。</p></blockquote></li><li><p><strong>用户请求创建一个新进程</strong></p><blockquote><p>在交互式系统中，键入一个命令或者点（双）击一个图标就可以启动一个程序。这两个动作中的任何一个都会开始一个新的进程，并在其中运行所选择的程序。</p></blockquote></li><li><p><strong>一个批处理作业的初始化</strong></p><blockquote><p>最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中（可能是远程地）提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p></blockquote></li></ul><p>在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。</p><p>在 Windows 中，一个Win32函数调用 CreateProcess 既处理进程的创建，也负责把正确的程序装入新的进程。</p><p>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。</p><h4 id="3-进程的终止"><a href="#3-进程的终止" class="headerlink" title="3. 进程的终止"></a>3. 进程的终止</h4><p>进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起：</p><ul><li><p><strong>正常退出（自愿的）</strong></p><blockquote><p>多数进程是由于完成了它们的工作而终止。在 UNIX 中该调用是exit，而在 Windows 中，相关的调用是 ExitProcess 。</p></blockquote></li><li><p><strong>出错退出（自愿的）</strong></p><blockquote><p>进程终止的第二个原因是进程发现了严重错误。</p></blockquote></li><li><p><strong>严重错误（非自愿）</strong></p><blockquote><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致。</p></blockquote></li><li><p><strong>被其他进程杀死（非自愿）</strong></p><blockquote><p>第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程。在 UNIX 中，这个系统调用是 kill 。在 Win32中对应的函数是 TerminateProcess 。</p></blockquote></li></ul><h4 id="4-进程的层次结构"><a href="#4-进程的层次结构" class="headerlink" title="4. 进程的层次结构"></a>4. 进程的层次结构</h4><p>某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。</p><p>在 UNIX 中，进程和它的所有子女以及后裔共同组成一个进程组。</p><p>在 Windows 中没有进程层次的概念，所有的进程都是地位相同的。惟一类似于进程层次的暗示是在创建进程的时侯，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。</p><h4 id="5-UNIX-启动时的初始化"><a href="#5-UNIX-启动时的初始化" class="headerlink" title="5. UNIX 启动时的初始化"></a>5. UNIX 启动时的初始化</h4><p>一个称为 init 的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。</p><h4 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6. 进程的状态"></a>6. 进程的状态</h4><p>进程存在三种状态：</p><ul><li>运行态（该时刻进程实际占用CPU）。</li><li>就绪态（可运行，但因为其他进程正在运行而暂时停止）。</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）。</li></ul><p>状态间的转化关系为</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-3.png" alt="进程间状态转换"></p><h4 id="7-进程的实现"><a href="#7-进程的实现" class="headerlink" title="7. 进程的实现"></a>7. 进程的实现</h4><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项。（也可称为进程控制块。）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p><h4 id="8-多道程序设计模型"><a href="#8-多道程序设计模型" class="headerlink" title="8. 多道程序设计模型"></a>8. 多道程序设计模型</h4><p>采用多道程序设计可以提高 CPU 的利用率。从概率的角度来看 CPU 的利用率。假设一个进程等待 I/O 操作的时间与其停留在内存中时间的比为   。当内存中同时有 n 个进程时，则所有 n 个进程都在等待 I/O（此时 CPU 空转）的概率是 pⁿ 。CPU 的利用率由下面的公式给出：</p><blockquote><p>CPU 利用率 = 1-pⁿ</p></blockquote><h4 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h4><h4 id="1-线程的使用原因"><a href="#1-线程的使用原因" class="headerlink" title="1. 线程的使用原因"></a>1. 线程的使用原因</h4><p>人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</p><p>第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。在许多系统中，创建一个线程较创建一个进程要快10～100倍。</p><p>需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</p><h4 id="2-线程模型"><a href="#2-线程模型" class="headerlink" title="2. 线程模型"></a>2. 线程模型</h4><p>进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。</p><p>线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。</p><h4 id="3-在用户空间中实现线程"><a href="#3-在用户空间中实现线程" class="headerlink" title="3. 在用户空间中实现线程"></a>3. 在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。我们已经见过其中的四个过程：pthread_create ，pthread_exit ，pthread_join 和 pthread_yield 。不过，一般还会有更多的过程。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-4.png" alt="用户线程实现"></p><p>在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和内核中的进程表类似。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p><p><strong>优点</strong></p><ol><li><p>用户级线程包可以在不支持线程的操作系统上实现。</p></li><li><p>线程的切换可以在几条指令内完成。进行类似于这样的线程切换至少比陷入内核要快一个数量级（或许更多）。</p></li><li><p>保存线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p></li><li><p>它允许每个进程有自己定制的调度算法。</p></li></ol><p><strong>缺点</strong></p><ol><li><p>第一个问题是如何实现阻塞系统调用。假设在还没有任何击键之前，一个线程读取键盘。让该线程实际进行该系统调用是不可接受的，因为这会停止所有的线程。</p></li><li><p>页面故障问题。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p></li><li><p>如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU 。</p></li><li><p>通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是CPU密集型而且极少有阻塞的应用程序而言，没有很大的意义。</p></li></ol><h4 id="4-在内核中实现线程"><a href="#4-在内核中实现线程" class="headerlink" title="4. 在内核中实现线程"></a>4. 在内核中实现线程</h4><p>在内核中实现线程时，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。内核的线程表保存了每个线程的寄存器、状态和其他信息。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-5.png" alt="内核线程实现"></p><p>所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的 CPU （或者没有可运行的线程存在了）为止。</p><h4 id="5-混合实现"><a href="#5-混合实现" class="headerlink" title="5. 混合实现"></a>5. 混合实现</h4><p>人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-6.png" alt="混合线程实现"></p><p>采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。</p><h4 id="6-调度程序激活机制"><a href="#6-调度程序激活机制" class="headerlink" title="6. 调度程序激活机制"></a>6. 调度程序激活机制</h4><p>调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。</p><p>使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这个机制称为上行调用。一旦如此激活，运行时系统就重新调度其线程。</p><p><strong>调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。</strong></p><h4 id="7-弹出式线程"><a href="#7-弹出式线程" class="headerlink" title="7. 弹出式线程"></a>7. 弹出式线程</h4><p>一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。</p><p>弹出式线程的关键好处是，由于这种线程相当新，没有历史这样，就有可能快速创建这类线程。对该新线程指定所要处理的消息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。</p><h4 id="三、-进程间通信"><a href="#三、-进程间通信" class="headerlink" title="三、 进程间通信"></a>三、 进程间通信</h4><p>进程间通信需要关注的三个问题：</p><ol><li><p>一个进程如何把信息传递给另一个。</p></li><li><p>如何确保两个或更多的进程在关键活动中不会出现交叉。</p></li><li><p>正确的顺序。</p></li></ol><h4 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h4><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。</p><h4 id="2-临界区"><a href="#2-临界区" class="headerlink" title="2. 临界区"></a>2. 临界区</h4><p>在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。</p><p>对于保证使用共享数据的并发进程能够正确和高效地进行协作，一个好的解决方案，需要满足以下4个条件：</p><ul><li>任何两个进程不能同时处于其临界区。</li><li>不应对CPU的速度和数量做任何假设。</li><li>临界区外运行的进程不得阻塞其他进程。</li><li>不得使进程无限期等待进入临界区。</li></ul><h4 id="3-忙等待的互斥"><a href="#3-忙等待的互斥" class="headerlink" title="3. 忙等待的互斥"></a>3. 忙等待的互斥</h4><h5 id="（1）-屏蔽中断"><a href="#（1）-屏蔽中断" class="headerlink" title="（1） 屏蔽中断"></a>（1） 屏蔽中断</h5><p>在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。</p><p><strong>缺点：</strong></p><ol><li><p>若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。</p></li><li><p>如果系统是多处理器（有两个或可能更多的处理器），则屏蔽中断仅仅对执行disable 指令的那个 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。</p></li></ol><p>但是对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。</p><p>所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</p><h5 id="（2）-锁变量"><a href="#（2）-锁变量" class="headerlink" title="（2） 锁变量"></a>（2） 锁变量</h5><p>设想有一个共享（锁）变量，其初始值为0。当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该进程将等待直到其值变为0。于是，0就表示临界区内没有进程，1表示已经有某个进程进入临界区。</p><p><strong>缺点：锁变量的读写不是原子操作，可能被其他进程中断</strong></p><p>假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行，将该锁变量设置为1。当第一个进程再次能运行时，它同样也将该锁设置为1，则此时同时有两个进程进入临界区中。</p><h5 id="（3）严格轮换法"><a href="#（3）严格轮换法" class="headerlink" title="（3）严格轮换法"></a>（3）严格轮换法</h5><p>定义一个整型变量 turn ，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程0检查 turn ，发现其值为0，于是进入临界区。进程1也发现其值为0，所以在一个等待循环中不停地测试 turn ，看其值何时变为1。连续测试一个变量直到某个值出现为止，称为忙等待。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-7.png" alt="严格轮换法"></p><p>只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁（spin lock）。</p><p><strong>缺点：</strong></p><ol><li><p>采用忙等待的方式，会浪费 CPU 时间。</p></li><li><p>该方案要求两个进程严格地轮流进入它们的临界区，会造成一个临界区外运行的进程阻塞其他进程的情况。</p></li></ol><h5 id="（4）Peterson-解法"><a href="#（4）Peterson-解法" class="headerlink" title="（4）Peterson 解法"></a>（4）Peterson 解法</h5><p>在使用共享变量（即进入其临界区）之前，各个进程使用其进程号0或1作为参数来调用 enter_region 。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 leave_region ，表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-8.png" alt="Peterson 解法"></p><h5 id="（5）TSL-指令"><a href="#（5）TSL-指令" class="headerlink" title="（5）TSL 指令"></a>（5）TSL 指令</h5><p>TSL 指令是硬件支持的一种方案，称为测试并加锁，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。</p><p>读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。因此不会出现前面第二种方法锁变量的问题。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-9.png" alt="TSL 指令"></p><p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为0时，任何进程都可以使用 TSL 指令将其设置为1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为0。</p><p>一个可替代 TSL 的指令是 XCHG ，它原子性地交换了两个位置的内容，它本质上与 TSL 的解决办法一样。所有的Intel x86 CPU 在低层同步中使用 XCHG 指令。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-10.png" alt="XCHG 指令"></p><p><strong>缺点：</strong></p><ol><li>采用忙等待的方式，会浪费 CPU 时间。</li></ol><h4 id="4-睡眠与唤醒"><a href="#4-睡眠与唤醒" class="headerlink" title="4. 睡眠与唤醒"></a>4. 睡眠与唤醒</h4><p>Peterson 解法和 TSL 或 XCHG 解法都是正确的，但它们都有忙等待的缺点。这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。</p><p>我们可以使用睡眠与唤醒的机制，使它们在无法进入临界区时将阻塞，而不是忙等待。</p><p>最简单的是 sleep 和 wakeup 。 sleep 是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup 调用有一个参数，即要被唤醒的进程。</p><p><strong>缺点：</strong></p><p>参考生产者-消费者问题，发给一个（尚）未睡眠进程的 wakeup 信号会出现丢失，从而出现生产者和消费者同时睡眠的情况。</p><p>一种快速的弥补方法是修改规则，加上一个唤醒等待位。当一个 wakeup 信号发送给一个清醒的进程信号时，将该位置1。随后，当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒。但原则上讲，这并没有从根本上解决问题。</p><h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h4><p>信号量是一个整型变量用来累计唤醒次数，供以后使用。一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。</p><p>对信号量一共有两种操作：down 和 up （分别为一般化后的 sleep 和 wakeup ）。</p><p>对一信号量执行 down 操作，则是检查其值是否大于0。若该值大于0，则将其值减1（即用掉一个保存的唤醒信号）并继续；若该值为0，则进程将睡眠，而且此时down操作并未结束。</p><p>对一信号量执行 up 操作，会对信号量的值增1。如果一个或多个进程在该信号量上睡眠，信号量的值仍旧是0，但在其上睡眠的进程会被唤醒一个。</p><p>检查数值、修改变量值以及可能发生的睡眠和唤醒操作均作为一个单一的、不可分割的原子操作完成。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。</p><h4 id="6-互斥量"><a href="#6-互斥量" class="headerlink" title="6. 互斥量"></a>6. 互斥量</h4><p>如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。</p><p>互斥量是一个可以处于两态之一的变量：解锁和加锁。当一个线程（或进程）需要访问临界区时，它调用 mutex_lock 。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用 mutex_unlock 。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-11.png" alt="互斥量"></p><p>enter_region 和 mutex_lock 的代码很相似，但有一个关键的区别。</p><p>当 enter_region 进入临界区失败时，它始终重复测试锁（忙等待）。实际上，由于时钟超时的作用，会调度其他进程运行。这样迟早拥有锁的进程会进入运行并释放锁。</p><p>在（用户）线程中，情形有所不同，因为没有时钟停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁。因此当 mutex_lock 取锁失败时，它调用 thread_yield 将 CPU 放弃给另一个线程。这样，就没有忙等待。在该线程下次运行时，它再一次对锁进行测试。</p><h4 id="7-条件变量"><a href="#7-条件变量" class="headerlink" title="7. 条件变量"></a>7. 条件变量</h4><p>条件变量允许线程由于一些未达到的条件而阻塞。</p><p>与条件变量相关的最重要的两个操作是 pthread_cond_wait 和 pthread_cond_signal 。前者阻塞调用线程直到另一其他线程向它发信号（使用后一个调用）。</p><p>条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。</p><h4 id="8-管程"><a href="#8-管程" class="headerlink" title="8. 管程"></a>8. 管程</h4><p>管程是一种高级同步原语，管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。</p><p>当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果</p><p>管程提供了一种实现互斥的简便途径，通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。</p><h4 id="9-消息传递"><a href="#9-消息传递" class="headerlink" title="9. 消息传递"></a>9. 消息传递</h4><p>这种进程间通信的方法使用两条原语 send 和 receive ，它们像信号量而不像管程，是系统调用而不是语言成分。</p><p>前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源（或者是任意源，如果接收者不介意的话）接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者，带着一个错误码立即返回。</p><h4 id="10-屏障"><a href="#10-屏障" class="headerlink" title="10. 屏障"></a>10. 屏障</h4><p>在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p><h4 id="四、调度"><a href="#四、调度" class="headerlink" title="四、调度"></a>四、调度</h4><p>当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序使用的算法称为调度算法。</p><h4 id="1-何时调度"><a href="#1-何时调度" class="headerlink" title="1. 何时调度"></a>1. 何时调度</h4><ol><li><p>在创建一个新进程之后，需要决定是运行父进程还是运行子进程。</p></li><li><p>在一个进程退出时必须做出调度决策。</p></li><li><p>当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</p></li><li><p>第四，在一个 I/O 中断发生时，必须做出调度决策。</p></li></ol><h4 id="2-调度算法分类"><a href="#2-调度算法分类" class="headerlink" title="2. 调度算法分类"></a>2. 调度算法分类</h4><ol><li>批处理。</li><li>交互式。</li><li>实时。</li></ol><h4 id="3-调度算法的目标"><a href="#3-调度算法的目标" class="headerlink" title="3. 调度算法的目标"></a>3. 调度算法的目标</h4><p>为了设计调度算法，有必要考虑什么是一个好的调度算法。某些目标取决于环境（批处理、交互式或实时），但是还有一些目标是适用于所有情形的。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-12.png" alt="调度算法的目标"></p><h4 id="4-批处理系统中的调度"><a href="#4-批处理系统中的调度" class="headerlink" title="4. 批处理系统中的调度"></a>4. 批处理系统中的调度</h4><h5 id="（1）先来先服务"><a href="#（1）先来先服务" class="headerlink" title="（1）先来先服务"></a>（1）先来先服务</h5><p>在所有调度算法中，最简单的是非抢占式的先来先服务算法。使用该算法，进程按照它们请求 CPU 的顺序使用 CPU 。</p><p><strong>优点：</strong></p><p>这个算法的主要优点是易于理解并且便于在程序中运用。</p><p><strong>缺点：</strong></p><p>平均等待时间过长。</p><h5 id="（2）最短作业优先"><a href="#（2）最短作业优先" class="headerlink" title="（2）最短作业优先"></a>（2）最短作业优先</h5><p>当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先算法。</p><p>只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的。</p><h5 id="（3）最短剩余时间优先"><a href="#（3）最短剩余时间优先" class="headerlink" title="（3）最短剩余时间优先"></a>（3）最短剩余时间优先</h5><p>最短作业优先的抢占式版本是最短剩余时间优先算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p><h4 id="5-交互式系统中的调度"><a href="#5-交互式系统中的调度" class="headerlink" title="5. 交互式系统中的调度"></a>5. 交互式系统中的调度</h4><h5 id="（1）轮转调度"><a href="#（1）轮转调度" class="headerlink" title="（1）轮转调度"></a>（1）轮转调度</h5><p>一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺 CPU 并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。</p><p>需要注意的是，时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20ms～50 ms通常是一个比较合理的折中。</p><h4 id="（2）优先级调度"><a href="#（2）优先级调度" class="headerlink" title="（2）优先级调度"></a>（2）优先级调度</h4><p>每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这个动作导致该进程的优先级低于次高优先级的进程，则进行进程切换。</p><h4 id="（3）多级队列"><a href="#（3）多级队列" class="headerlink" title="（3）多级队列"></a>（3）多级队列</h4><p>将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用其他调度方式。</p><h4 id="（4）最短进程优先"><a href="#（4）最短进程优先" class="headerlink" title="（4）最短进程优先"></a>（4）最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互进程，那将是非常好的。</p><h4 id="（5）保证调度"><a href="#（5）保证调度" class="headerlink" title="（5）保证调度"></a>（5）保证调度</h4><p>向用户作出明确的性能保证，然后去实现它。</p><p>一种很实际并很容易实现的保证是：若用户工作时有 n 个用户登录，则用户将获得 CPU 处理能力的 1/n 。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。看上去足够公平了。</p><h4 id="（6）彩票调度"><a href="#（6）彩票调度" class="headerlink" title="（6）彩票调度"></a>（6）彩票调度</h4><p>向进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。在应用到 CPU 调度时，系统可以掌握每秒钟50次的一种彩票，作为奖励每个获奖者可以得到20 ms 的 CPU 时间。</p><h4 id="（7）公平分享调度"><a href="#（7）公平分享调度" class="headerlink" title="（7）公平分享调度"></a>（7）公平分享调度</h4><p>到现在为止，我们假设被调度的都是各个进程自身，并不关注其所有者是谁。</p><p>为了避免这种情形，某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得50% CPU 时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。</p><h4 id="6-策略和机制"><a href="#6-策略和机制" class="headerlink" title="6. 策略和机制"></a>6. 策略和机制</h4><p>我们讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p><p>解决问题的方法是将调度机制与调度策略分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。</p><p>在这里，调度机制位于内核，而调度策略则由用户进程决定。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机操作系统&quot;&gt;&lt;a href=&quot;#计算机操作系统&quot; class=&quot;headerlink&quot; title=&quot;计算机操作系统&quot;&gt;&lt;/a&gt;计算机操作系统&lt;/h1&gt;&lt;p&gt;本部分主要是笔者在学习现代操作系统和一些相关面试题所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;
&lt;h2 id=&quot;现代操作系统阅读笔记&quot;&gt;&lt;a href=&quot;#现代操作系统阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;现代操作系统阅读笔记&quot;&gt;&lt;/a&gt;现代操作系统阅读笔记&lt;/h2&gt;&lt;h3 id=&quot;第一章-引论&quot;&gt;&lt;a href=&quot;#第一章-引论&quot; class=&quot;headerlink&quot; title=&quot;第一章 引论&quot;&gt;&lt;/a&gt;第一章 引论&lt;/h3&gt;&lt;h4 id=&quot;1-操作系统定义&quot;&gt;&lt;a href=&quot;#1-操作系统定义&quot; class=&quot;headerlink&quot; title=&quot;1. 操作系统定义&quot;&gt;&lt;/a&gt;1. 操作系统定义&lt;/h4&gt;&lt;p&gt;操作系统是运行在内核态的软件，它执行两个基本上独立的任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;隐藏计算机底层硬件的实现，为用户及应用程序提供一个资源集的清晰抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;管理计算机硬件资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何操作系统的核心是它可处理的系统调用集。这些系统带欧阳真实地说明了操作系统做的工作。&lt;/p&gt;
&lt;h4 id=&quot;2-计算机运行模式&quot;&gt;&lt;a href=&quot;#2-计算机运行模式&quot; class=&quot;headerlink&quot; title=&quot;2. 计算机运行模式&quot;&gt;&lt;/a&gt;2. 计算机运行模式&lt;/h4&gt;&lt;p&gt;多数计算机有两种运行模式：内核态和用户态。&lt;/p&gt;
&lt;p&gt;软件中最基础的部分是操作系统，它运行在内核态。这内核态模式下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下，在用户态下，只能使用机器指令中的一个子集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-1.png&quot; alt=&quot;计算机运行模式&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-shell-与-GUI&quot;&gt;&lt;a href=&quot;#3-shell-与-GUI&quot; class=&quot;headerlink&quot; title=&quot;3. shell 与 GUI&quot;&gt;&lt;/a&gt;3. shell 与 GUI&lt;/h4&gt;&lt;p&gt;用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（GUI）。&lt;/p&gt;
&lt;p&gt;它们并不是操作系统的一部分，它们是运行在用户态最低层次的用户接口程序&lt;/p&gt;
&lt;h4 id=&quot;4-对于抽象的理解&quot;&gt;&lt;a href=&quot;#4-对于抽象的理解&quot; class=&quot;headerlink&quot; title=&quot;4. 对于抽象的理解&quot;&gt;&lt;/a&gt;4. 对于抽象的理解&lt;/h4&gt;&lt;p&gt;现代计算机系统中，大量使用了抽象这一概念。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其中第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。&lt;/p&gt;
&lt;p&gt;以抽象的角度看操作系统，它的任务就是创建好的抽象，并实现和管理它所创建的抽象。&lt;/p&gt;
&lt;h4 id=&quot;5-多路复用资源方式&quot;&gt;&lt;a href=&quot;#5-多路复用资源方式&quot; class=&quot;headerlink&quot; title=&quot;5. 多路复用资源方式&quot;&gt;&lt;/a&gt;5. 多路复用资源方式&lt;/h4&gt;&lt;p&gt;在时间上复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。&lt;/p&gt;
&lt;p&gt;在空间上复用：每个客户得到资源的一部分。&lt;/p&gt;
&lt;h4 id=&quot;6-I-O-设备的结构&quot;&gt;&lt;a href=&quot;#6-I-O-设备的结构&quot; class=&quot;headerlink&quot; title=&quot;6. I/O 设备的结构&quot;&gt;&lt;/a&gt;6. I/O 设备的结构&lt;/h4&gt;&lt;p&gt;I/O 设备一般包括两个部分：设备控制器和设备本身。控制器插在电路板上的一块芯片或一组芯片，这块电路板物理地控制芯片，它从操作系统接收命令。&lt;/p&gt;
&lt;p&gt;控制器的任务是为操作系统提供一个简单的接口。每类设备控制器是不同的，所以需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。为了使用设备驱动程序，必须要把设备驱动程序装入到操作系统中，这样它可在核心态中运行。&lt;/p&gt;
&lt;p&gt;每个设备控制器都有少量的用于通信的寄存器，所有的寄存器的集合构成了I/O 空间。&lt;/p&gt;
&lt;h4 id=&quot;7-IDE-概念&quot;&gt;&lt;a href=&quot;#7-IDE-概念&quot; class=&quot;headerlink&quot; title=&quot;7. IDE 概念&quot;&gt;&lt;/a&gt;7. IDE 概念&lt;/h4&gt;&lt;p&gt;IDE 表示集成驱动电子设备，是许多计算机的磁盘标准。&lt;/p&gt;
&lt;h4 id=&quot;8-实现输入输出的三种方式&quot;&gt;&lt;a href=&quot;#8-实现输入输出的三种方式&quot; class=&quot;headerlink&quot; title=&quot;8. 实现输入输出的三种方式&quot;&gt;&lt;/a&gt;8. 实现输入输出的三种方式&lt;/h4&gt;&lt;p&gt;第一种方式，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。当 I/O 结束后，设备驱动程序把数据送到指定的地方（若有此需要），并返回。然后操作系统将控制返回给调用者。这种方式称为忙等待（busy waiting），其缺点是要占据CPU ，CPU 一直轮询设备直到对应的 I/O 操作完成。&lt;/p&gt;
&lt;p&gt;第二种方式，设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-2.png&quot; alt=&quot;终端实例&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三种方式，为I/O使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预。&lt;/p&gt;
&lt;h4 id=&quot;9-CMOS-存储器&quot;&gt;&lt;a href=&quot;#9-CMOS-存储器&quot; class=&quot;headerlink&quot; title=&quot;9. CMOS 存储器&quot;&gt;&lt;/a&gt;9. CMOS 存储器&lt;/h4&gt;&lt;p&gt;CMOS 存储器是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。 CMOS 存储器和递增时间的时钟电路有一块小电池驱动，所以，即使计算机没有上电，时间也可以正确地更新。&lt;/p&gt;
&lt;h4 id=&quot;10-USB-概念&quot;&gt;&lt;a href=&quot;#10-USB-概念&quot; class=&quot;headerlink&quot; title=&quot;10. USB 概念&quot;&gt;&lt;/a&gt;10. USB 概念&lt;/h4&gt;&lt;p&gt;USB 是通用串行总线，是用来将所有的慢速 I/O 设备，诸如键盘和鼠标，与计算机相连。USB 是一种集中式总线，其根设备每 1ms 轮询一次 I/O 设备，看是否有消息收发。所有的 USB 设备共享一个 USB 设备驱动器，于是就不需要为新的 USB 设备安装新的设备驱动器了。&lt;/p&gt;
&lt;h4 id=&quot;11-即插即用概念&quot;&gt;&lt;a href=&quot;#11-即插即用概念&quot; class=&quot;headerlink&quot; title=&quot;11. 即插即用概念&quot;&gt;&lt;/a&gt;11. 即插即用概念&lt;/h4&gt;&lt;p&gt;在一般的计算机工作环境下，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求导致了 Intel 和微软设计了一种名为即插即用的 I/O 系统。&lt;/p&gt;
&lt;p&gt;在即插即用之前，每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。即插即用所做的工作是，系统自动地收集有关 I/O 设备的信息，集中赋予 I/O 地址，然后通知每块卡所用的数值。&lt;/p&gt;
&lt;h4 id=&quot;12-计算机的启动&quot;&gt;&lt;a href=&quot;#12-计算机的启动&quot; class=&quot;headerlink&quot; title=&quot;12. 计算机的启动&quot;&gt;&lt;/a&gt;12. 计算机的启动&lt;/h4&gt;&lt;p&gt;Pentium 的简要启动过程如下。在每个 Pentium 上有一块母板。在母板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序存放在一块闪速 RAM 中，它是非可易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。&lt;/p&gt;
&lt;p&gt;简要过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BIOS 开始运行。它首先检查计算机设备的状态信息是否正常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扫描并记录总线所连设备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;依次搜索启动设备，导入操作系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统询问 BIOS ，获得配置信息，获取所有设备的驱动程序并调入内核。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;13-操作系统分类&quot;&gt;&lt;a href=&quot;#13-操作系统分类&quot; class=&quot;headerlink&quot; title=&quot;13. 操作系统分类&quot;&gt;&lt;/a&gt;13. 操作系统分类&lt;/h4&gt;&lt;p&gt;大型机操作系统、服务器操作系统、多处理器操作系统、个人计算机操作系统、掌上计算机操作系统、嵌入式操作系统、传感器节点操作系统、实时操作系统、智能卡操作系统&lt;/p&gt;
&lt;h4 id=&quot;14-实时操作系统的基本概念&quot;&gt;&lt;a href=&quot;#14-实时操作系统的基本概念&quot; class=&quot;headerlink&quot; title=&quot;14. 实时操作系统的基本概念&quot;&gt;&lt;/a&gt;14. 实时操作系统的基本概念&lt;/h4&gt;&lt;p&gt;实时操作系统的特征是将时间作为关键参数。通常分为硬实时操作系统和软实时操作系统。&lt;/p&gt;
&lt;p&gt;在硬实时操作系统中，某个规定的动作必须绝对地在规定的时刻（或规定的时间范围）发生。&lt;/p&gt;
&lt;p&gt;在软实时操作系统中，偶尔违反最终时限是不希望的，但可以接受，并且不会引起任何实时性的损害。&lt;/p&gt;
&lt;h4 id=&quot;15-UID&quot;&gt;&lt;a href=&quot;#15-UID&quot; class=&quot;headerlink&quot; title=&quot;15. UID&quot;&gt;&lt;/a&gt;15. UID&lt;/h4&gt;&lt;p&gt;系统管理器授权每个进程使用一个给定的 UID 标识。每个被启动的进程都有一个启动该进程的用户 UID 。子进程与父进程拥有一样 UID。用户可以是某个组的成员，每个组也有一个 GID 标识。&lt;/p&gt;
&lt;h4 id=&quot;16-文件路径&quot;&gt;&lt;a href=&quot;#16-文件路径&quot; class=&quot;headerlink&quot; title=&quot;16. 文件路径&quot;&gt;&lt;/a&gt;16. 文件路径&lt;/h4&gt;&lt;p&gt;在 UNIX 中，绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用正斜线 &lt;code&gt;/&lt;/code&gt; 隔开。最开始的正斜线标识这是从根目录开始的绝对路径。&lt;/p&gt;
&lt;p&gt;在 MS-DOS 和 Windows 中，用反斜线 &lt;code&gt;&#92;&lt;/code&gt; 作为分隔符。&lt;/p&gt;
&lt;h4 id=&quot;17-文件系统安装&quot;&gt;&lt;a href=&quot;#17-文件系统安装&quot; class=&quot;headerlink&quot; title=&quot;17. 文件系统安装&quot;&gt;&lt;/a&gt;17. 文件系统安装&lt;/h4&gt;&lt;p&gt;UNIX 一个重要概念是安装文件系统。几乎所有的个人计算机都有一个或多个光盘驱动器，可以插入 CD-ROM 和 DV D。它们几乎都有 USB 接口，可以插入 USB 存储棒（实际是固态磁盘驱动器）。为了提供一个出色的方式处理可移动介质，UNIX 允许把在 CD-ROM 或 DVD 上的文件系统接入到主文件树上。 mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。&lt;/p&gt;
&lt;h4 id=&quot;18-特殊文件&quot;&gt;&lt;a href=&quot;#18-特殊文件&quot; class=&quot;headerlink&quot; title=&quot;18. 特殊文件&quot;&gt;&lt;/a&gt;18. 特殊文件&lt;/h4&gt;&lt;p&gt;提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可通过同样的系统调用进行读写。&lt;/p&gt;
&lt;p&gt;有两类特殊文件：块特殊文件和字符特殊文件。&lt;/p&gt;
&lt;p&gt;块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第4块，程序可以直接访问设备的第4块而不必考虑存放该文件的文件系统结构。&lt;/p&gt;
&lt;p&gt;字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在 /dev 目录中。例如，/dev/lp是打印机。&lt;/p&gt;
&lt;h4 id=&quot;19-文件保护&quot;&gt;&lt;a href=&quot;#19-文件保护&quot; class=&quot;headerlink&quot; title=&quot;19. 文件保护&quot;&gt;&lt;/a&gt;19. 文件保护&lt;/h4&gt;&lt;p&gt;UNIX 操作系统通过对每个文件赋予一个9位的二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个3位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的 rwx 位。&lt;/p&gt;
&lt;h4 id=&quot;20-系统调用概念&quot;&gt;&lt;a href=&quot;#20-系统调用概念&quot; class=&quot;headerlink&quot; title=&quot;20. 系统调用概念&quot;&gt;&lt;/a&gt;20. 系统调用概念&lt;/h4&gt;&lt;p&gt;如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。&lt;/p&gt;
&lt;h4 id=&quot;21-POSIX&quot;&gt;&lt;a href=&quot;#21-POSIX&quot; class=&quot;headerlink&quot; title=&quot;21. POSIX&quot;&gt;&lt;/a&gt;21. POSIX&lt;/h4&gt;&lt;p&gt;UNIX 有很多不兼容的版本，从而导致了混乱。为了能使编写的程序能够在任何版本的 UNIX 系统运行，IEEE提出了一个 UNIX 标准，称为 POSIX，目前大多数 UNIX 版本都支持他。 POSIX 标准定义了凡是 UNIX 必须支持的小型系统调用接口。&lt;/p&gt;
&lt;h4 id=&quot;22-Windows-Win32-API&quot;&gt;&lt;a href=&quot;#22-Windows-Win32-API&quot; class=&quot;headerlink&quot; title=&quot;22. Windows Win32 API&quot;&gt;&lt;/a&gt;22. Windows Win32 API&lt;/h4&gt;&lt;p&gt;Windows 和 UNIX 的主要差别在于编程方式。一个 UNIX 程序包括做各种处理的代码以及从事完成特定服务的系统调用。相反，一个 Windows 程序通常是一个事件驱动程序。其中主程序等待某些事件发生，然后调用一个过程处理该事件。&lt;/p&gt;
&lt;p&gt;在 UNIX 中，系统调用（如read）和系统调用所使用的库过程（如read）之间几乎是一一对应的关系。换句话说，对于每个系统调用，差不多就涉及一个被调用的库过程。&lt;/p&gt;
&lt;p&gt;在 Windows 中，情况就大不相同了。首先，库调用和实际的系统调用是几乎不对应的。微软定义了一套过程，称为应用编程接口（Application Program Interface，Win32 API），程序员用这套过程获得操作系统的服务。&lt;/p&gt;
&lt;p&gt;Win32 并不是非常统一的或有一致的接口。其主要原因是由于 Win32 需要与早期的在 Windows 3.x 中使用的16位接口向后兼容。&lt;/p&gt;
&lt;p&gt;Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。&lt;/p&gt;
&lt;h4 id=&quot;23-操作系统结构&quot;&gt;&lt;a href=&quot;#23-操作系统结构&quot; class=&quot;headerlink&quot; title=&quot;23. 操作系统结构&quot;&gt;&lt;/a&gt;23. 操作系统结构&lt;/h4&gt;&lt;p&gt;单体结构、层次式结构、微内核、客户机-服务器模式、虚拟机、外核、&lt;/p&gt;
&lt;h4 id=&quot;24-微内核的概念&quot;&gt;&lt;a href=&quot;#24-微内核的概念&quot; class=&quot;headerlink&quot; title=&quot;24. 微内核的概念&quot;&gt;&lt;/a&gt;24. 微内核的概念&lt;/h4&gt;&lt;p&gt;在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。&lt;/p&gt;
&lt;h4 id=&quot;25-机制与策略分离原则&quot;&gt;&lt;a href=&quot;#25-机制与策略分离原则&quot; class=&quot;headerlink&quot; title=&quot;25. 机制与策略分离原则&quot;&gt;&lt;/a&gt;25. 机制与策略分离原则&lt;/h4&gt;&lt;p&gt;策略指的是做什么，机制指的是怎么做。例如一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程以优先级）可以由用户态中的进程完成。在这个方式中，机制和策略是分离的，从而使系统内核变得更小。&lt;/p&gt;
&lt;h4 id=&quot;26-make-程序&quot;&gt;&lt;a href=&quot;#26-make-程序&quot; class=&quot;headerlink&quot; title=&quot;26. make 程序&quot;&gt;&lt;/a&gt;26. make 程序&lt;/h4&gt;&lt;p&gt;在 UNIX 系统中，有个名为 make 的程序（其大量的变体如 gmake、pmake 等），它读入 Makefile ，该 Makefile 说明哪个文件与哪个文件相关。make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后，是否有任何它依赖（代码和头文件）的文件已经被修改了。如果有，目标文件需要重新编译。在大型项目中，创建 Makefile 是一件容易出错的工作，所以出现了一些工具使该工作能够自动完成。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试记录</title>
    <link href="https://qyjs.github.io/2020/09/21/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://qyjs.github.io/2020/09/21/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试记录总结"><a href="#面试记录总结" class="headerlink" title="面试记录总结"></a>面试记录总结</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93">面试记录总结</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E8%8E%B7%E5%BE%97-offer">阿里巴巴（获得 OFFER）</a><ul><li><a href="#1-2019-3-25-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%B8%80%E9%9D%A2">1. 2019-3-25 阿里巴巴（淘宝）一面</a></li><li><a href="#2-2019-3-28-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E9%9D%A2">2. 2019-3-28 阿里巴巴（淘宝）二面</a></li><li><a href="#3-2019-4-1-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%B8%89%E9%9D%A2">3. 2019-4-1 阿里巴巴（淘宝）三面</a></li><li><a href="#4-2019-4-3-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E5%9B%9B%E9%9D%A2hr">4. 2019-4-3 阿里巴巴（淘宝）四面（hr）</a></li><li><a href="#5-2019-4-29-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%80%E9%9D%A2">5. 2019-4-29 阿里巴巴（阿里云）一面</a></li><li><a href="#6-2019-5-27-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%8C%E9%9D%A2">6. 2019-5-27 阿里巴巴（阿里云）二面</a></li><li><a href="#7-2019-5-29-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E8%BD%AE%E4%B8%80%E9%9D%A2">7. 2019-5-29 阿里巴巴（淘宝二轮）一面</a></li><li><a href="#8-2019-5-31-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E8%BD%AE%E4%BA%8C%E9%9D%A2">8. 2019-5-31 阿里巴巴（淘宝二轮）二面</a></li><li><a href="#9-2019-5-31-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E8%BD%AE%E4%B8%89%E9%9D%A2hr">9. 2019-5-31 阿里巴巴（淘宝二轮）三面（hr）</a></li></ul></li><li><a href="#%E8%85%BE%E8%AE%AF%E8%8E%B7%E5%BE%97-offer">腾讯（获得 OFFER）</a><ul><li><a href="#1-2019-4-26-%E8%85%BE%E8%AE%AFteg%E4%B8%80%E9%9D%A2">1. 2019-4-26 腾讯（TEG）一面</a></li><li><a href="#2-2019-4-29-%E8%85%BE%E8%AE%AFteg%E4%BA%8C%E9%9D%A2">2. 2019-4-29 腾讯（TEG）二面</a></li><li><a href="#3-2019-5-9-%E8%85%BE%E8%AE%AFteg%E4%B8%89%E9%9D%A2">3. 2019-5-9 腾讯（TEG）三面</a></li><li><a href="#4-2019-5-17-%E8%85%BE%E8%AE%AFteg%E5%9B%9B%E9%9D%A2hr">4. 2019-5-17 腾讯（TEG）四面（hr）</a></li></ul></li><li><a href="#%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E8%8E%B7%E5%BE%97-offer">网易互娱（获得 OFFER）</a><ul><li><a href="#1-2019-4-15-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2">1. 2019-4-15 网易互娱一面</a></li><li><a href="#2-2019-4-18-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%BA%8C%E9%9D%A2">2. 2019-4-18 网易互娱二面</a></li></ul></li><li><a href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8">字节跳动</a><ul><li><a href="#1-2019-3-23-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2">1. 2019-3-23 字节跳动一面</a></li></ul></li><li><a href="#%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C">微众银行</a><ul><li><a href="#1-2019-4-1-%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C%E4%B8%80%E9%9D%A2">1. 2019-4-1 微众银行一面</a></li></ul></li><li><a href="#%E9%85%B7%E5%AE%B6%E4%B9%90%E8%8E%B7%E5%BE%97-offer">酷家乐（获得 OFFER）</a><ul><li><a href="#1-2019-4-18-%E9%85%B7%E5%AE%B6%E4%B9%90%E4%B8%80%E9%9D%A2">1. 2019-4-18 酷家乐一面</a></li><li><a href="#2-2019-4-22-%E9%85%B7%E5%AE%B6%E4%B9%90%E4%BA%8C%E9%9D%A2">2. 2019-4-22 酷家乐二面</a></li><li><a href="#3-2019-4-25-%E9%85%B7%E5%AE%B6%E4%B9%90%E4%B8%89%E9%9D%A2">3. 2019-4-25 酷家乐三面</a></li></ul></li><li><a href="#%E4%BA%AC%E4%B8%9C">京东</a><ul><li><a href="#1-2019-4-22-%E4%BA%AC%E4%B8%9C%E4%B8%80%E9%9D%A2">1. 2019-4-22 京东一面</a></li></ul></li><li><a href="#%E4%BA%BF%E8%81%94%E7%BD%91%E7%BB%9C">亿联网络</a><ul><li><a href="#1-2019-4-24-%E4%BA%BF%E8%81%94%E7%BD%91%E7%BB%9C%E4%B8%80%E9%9D%A2">1. 2019-4-24 亿联网络一面</a></li></ul></li><li><a href="#oppo%E8%8E%B7%E5%BE%97-offer">OPPO（获得 OFFER）</a><ul><li><a href="#1-2019-4-26-oppo%E4%B8%80%E9%9D%A2">1. 2019-4-26 OPPO一面</a></li><li><a href="#2-2019-5-8-oppo%E4%BA%8C%E9%9D%A2hr">2. 2019-5-8 OPPO二面（hr）</a></li></ul></li><li><a href="#%E5%8D%8E%E4%B8%BA%E8%8E%B7%E5%BE%97-offer">华为（获得 OFFER）</a><ul><li><a href="#1-2019-4-28-%E5%8D%8E%E4%B8%BA%E4%B8%80%E9%9D%A2">1. 2019-4-28 华为一面</a></li><li><a href="#2-2019-4-28-%E5%8D%8E%E4%B8%BA%E4%BA%8C%E9%9D%A2">2. 2019-4-28 华为二面</a><span id="more"></span><h3 id="阿里巴巴（获得-OFFER）"><a href="#阿里巴巴（获得-OFFER）" class="headerlink" title="阿里巴巴（获得 OFFER）"></a>阿里巴巴（获得 OFFER）</h3></li></ul></li></ul></li></ul><h4 id="1-2019-3-25-阿里巴巴（淘宝）一面"><a href="#1-2019-3-25-阿里巴巴（淘宝）一面" class="headerlink" title="1. 2019-3-25 阿里巴巴（淘宝）一面"></a>1. 2019-3-25 阿里巴巴（淘宝）一面</h4><ol><li>笔试题随机排序</li><li>笔试题实现商品分配</li><li>浏览器存储机制，cacheStorage</li><li>cookie 原理</li><li>项目 mvp 原理</li><li>Vue 组件间通信</li><li>双向绑定的原理</li><li>网站性能优化</li><li>页面的可用性时间的计算 performance api</li><li>Webpack 配置</li><li>Webassblem</li><li>网络安全</li><li>This的指向</li><li>前沿知识</li><li>Hybrid</li><li>Node.js</li><li>原型链</li><li>跨域</li><li>移动端的点击事件</li><li>移动端布局</li><li>前端路由的实现方式</li></ol><p>面试时间：3.25 20:10-22:25  135分钟</p><h4 id="2-2019-3-28-阿里巴巴（淘宝）二面"><a href="#2-2019-3-28-阿里巴巴（淘宝）二面" class="headerlink" title="2. 2019-3-28 阿里巴巴（淘宝）二面"></a>2. 2019-3-28 阿里巴巴（淘宝）二面</h4><ol><li>项目 mvp 模式</li><li>图片优化</li><li>移动端开发基础</li><li>WebAssembly</li></ol><h4 id="3-2019-4-1-阿里巴巴（淘宝）三面"><a href="#3-2019-4-1-阿里巴巴（淘宝）三面" class="headerlink" title="3. 2019-4-1 阿里巴巴（淘宝）三面"></a>3. 2019-4-1 阿里巴巴（淘宝）三面</h4><ol><li>项目介绍</li><li>Vuex</li><li>项目 mvp 模式介绍</li><li>Ajax请求创建</li><li>Promise 调用</li><li>Flex 布局</li><li>盒模型</li><li>Git rebase</li><li>随机排序</li><li>Promise</li><li>Fetch 没回答</li><li>Grid 没回答</li></ol><p>面试时间:  4.1 15:20-15:57  37 分钟</p><h4 id="4-2019-4-3-阿里巴巴（淘宝）四面（hr）"><a href="#4-2019-4-3-阿里巴巴（淘宝）四面（hr）" class="headerlink" title="4. 2019-4-3 阿里巴巴（淘宝）四面（hr）"></a>4. 2019-4-3 阿里巴巴（淘宝）四面（hr）</h4><ol><li>项目介绍</li><li>自我评价、同学评价</li><li>家乡</li><li>自己的优点</li><li>学校课程</li><li>未来5年的规划</li><li>投了哪些公司</li><li>学习生涯</li><li>有没有女朋友</li><li>性格</li><li>从项目中学到的东西</li></ol><p>面试时间:  4.3 16:20-16:47  27 分钟</p><h4 id="5-2019-4-29-阿里巴巴（阿里云）一面"><a href="#5-2019-4-29-阿里巴巴（阿里云）一面" class="headerlink" title="5. 2019-4-29 阿里巴巴（阿里云）一面"></a>5. 2019-4-29 阿里巴巴（阿里云）一面</h4><ol><li>快速排序</li><li>反转链表</li><li>继承</li><li>深度优先遍历</li><li>Es6</li><li>情景题 ui 组件设计</li><li>列表数据加载问题</li><li>懒加载扩展</li></ol><h4 id="6-2019-5-27-阿里巴巴（阿里云）二面"><a href="#6-2019-5-27-阿里巴巴（阿里云）二面" class="headerlink" title="6. 2019-5-27 阿里巴巴（阿里云）二面"></a>6. 2019-5-27 阿里巴巴（阿里云）二面</h4><ol><li>Es6 新特性</li><li>Object 方法</li><li>Html5 方法</li><li>Js 性能优化</li><li>快速排序不用递归实现</li></ol><p>面试时间：5.27  20:32-20:58  26 分钟</p><h4 id="7-2019-5-29-阿里巴巴（淘宝二轮）一面"><a href="#7-2019-5-29-阿里巴巴（淘宝二轮）一面" class="headerlink" title="7. 2019-5-29 阿里巴巴（淘宝二轮）一面"></a>7. 2019-5-29 阿里巴巴（淘宝二轮）一面</h4><ol><li>简历第一个项目</li><li>简历第二个项目</li><li>简历第三个项目</li><li>服务端了解知识</li><li>Node.js 了解</li><li>移动端相关</li><li>React 基础</li></ol><p>面试时间：5.29  16:58-18:35  97分钟</p><h4 id="8-2019-5-31-阿里巴巴（淘宝二轮）二面"><a href="#8-2019-5-31-阿里巴巴（淘宝二轮）二面" class="headerlink" title="8. 2019-5-31 阿里巴巴（淘宝二轮）二面"></a>8. 2019-5-31 阿里巴巴（淘宝二轮）二面</h4><ol><li>项目经历</li><li>技术选型</li><li>为何这样选择</li><li>项目提效率提升亮点</li><li>项目目的</li></ol><p>面试时间：5.31  12:58-13:20  22分钟</p><h4 id="9-2019-5-31-阿里巴巴（淘宝二轮）三面（hr）"><a href="#9-2019-5-31-阿里巴巴（淘宝二轮）三面（hr）" class="headerlink" title="9. 2019-5-31 阿里巴巴（淘宝二轮）三面（hr）"></a>9. 2019-5-31 阿里巴巴（淘宝二轮）三面（hr）</h4><ol><li>项目介绍</li><li>收获</li><li>个人优势</li><li>和腾讯offer 的选择</li><li>职业规划</li><li>如何获取前端前沿知识</li></ol><p>面试时间： 5.31  13:31-13:48  17分钟</p><h3 id="腾讯（获得-OFFER）"><a href="#腾讯（获得-OFFER）" class="headerlink" title="腾讯（获得 OFFER）"></a>腾讯（获得 OFFER）</h3><h4 id="1-2019-4-26-腾讯（TEG）一面"><a href="#1-2019-4-26-腾讯（TEG）一面" class="headerlink" title="1. 2019-4-26 腾讯（TEG）一面"></a>1. 2019-4-26 腾讯（TEG）一面</h4><ol><li>实习时间</li><li>前端项目</li><li>节流与防抖</li><li>margin 重叠</li><li>BFC</li><li>This 对象</li><li>Loader 和 plugin 的差别</li><li>原型的获取</li><li>单页应用的seo</li><li>EventBus</li><li>Vuex</li></ol><p>面试时间： 4.26 18:28-19:05  37分钟</p><h4 id="2-2019-4-29-腾讯（TEG）二面"><a href="#2-2019-4-29-腾讯（TEG）二面" class="headerlink" title="2. 2019-4-29 腾讯（TEG）二面"></a>2. 2019-4-29 腾讯（TEG）二面</h4><ol><li>项目</li><li>Vue router实现</li><li>Vuex</li><li>项目管理规范</li><li>5个价值不同的问题分给5个不同的人的方式</li><li>For of 和 for in 的区别</li><li>图片加载</li><li>正则表达式</li><li>页面遍历</li><li>如何判断参数是否传入</li><li>路由如何保存滚动位置</li></ol><p>面试时间：4.29 19:15-20:30  75 分钟</p><h4 id="3-2019-5-9-腾讯（TEG）三面"><a href="#3-2019-5-9-腾讯（TEG）三面" class="headerlink" title="3. 2019-5-9 腾讯（TEG）三面"></a>3. 2019-5-9 腾讯（TEG）三面</h4><ol><li>项目经历</li><li>最困难的事</li><li>兴趣爱好</li><li>项目分工、人员讨论</li><li>性格</li><li>面试是否会准备</li></ol><p>面试时间： 5.9 19:03-19:43  40 分钟</p><h4 id="4-2019-5-17-腾讯（TEG）四面（hr）"><a href="#4-2019-5-17-腾讯（TEG）四面（hr）" class="headerlink" title="4. 2019-5-17 腾讯（TEG）四面（hr）"></a>4. 2019-5-17 腾讯（TEG）四面（hr）</h4><ol><li>项目问题</li><li>新的解决方案</li><li>实验室</li><li>最难的问题</li><li>家乡</li><li>父母工作</li><li>对职位的看法</li><li>是否支持外地工作</li><li>是否有直系亲属在腾讯</li><li>实习时间</li><li>中间是否回校</li><li>兴趣爱好</li><li>薪资有要求吗</li></ol><p>面试时间： 5.17 14:23-14:45  22分钟</p><h3 id="网易互娱（获得-OFFER）"><a href="#网易互娱（获得-OFFER）" class="headerlink" title="网易互娱（获得 OFFER）"></a>网易互娱（获得 OFFER）</h3><h4 id="1-2019-4-15-网易互娱一面"><a href="#1-2019-4-15-网易互娱一面" class="headerlink" title="1. 2019-4-15 网易互娱一面"></a>1. 2019-4-15 网易互娱一面</h4><ol><li>项目介绍</li><li>Vue 理解</li><li>路由的理解</li><li>ES6 理解</li></ol><p>面试时间:  4.15 11:11-11:44  33 分钟</p><h4 id="2-2019-4-18-网易互娱二面"><a href="#2-2019-4-18-网易互娱二面" class="headerlink" title="2. 2019-4-18 网易互娱二面"></a>2. 2019-4-18 网易互娱二面</h4><ol><li>项目介绍</li><li>权限系统的理解</li><li>对于炉石传说的理解</li><li>代码规范</li><li>商品利润下降的原因</li></ol><p>面试时间:  4.18 10:00-10:42  42 分钟</p><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><h4 id="1-2019-3-23-字节跳动一面"><a href="#1-2019-3-23-字节跳动一面" class="headerlink" title="1. 2019-3-23 字节跳动一面"></a>1. 2019-3-23 字节跳动一面</h4><ol><li>Webpack 了解</li><li>http 缓存</li><li>http1.0 和 http1.1 的区别</li><li>css 上下固定为100px，中间为自适应高度</li><li>一道代码分析题</li><li>BFC</li><li>类数组有哪些，如何转换</li><li>跨域</li><li>cors 简单请求和复杂请求的区别</li><li>项目中图片的性能优化</li><li>前端的性能优化</li><li>Base64 在 html 中的缺点</li><li>500 张图片，如何实现预加载优化</li><li>二维码扫描登录的原理，服务器推送，客户端轮询</li></ol><p>面试时间：3.23 9:00-10:17  67 分钟</p><h3 id="微众银行"><a href="#微众银行" class="headerlink" title="微众银行"></a>微众银行</h3><h4 id="1-2019-4-1-微众银行一面"><a href="#1-2019-4-1-微众银行一面" class="headerlink" title="1. 2019-4-1 微众银行一面"></a>1. 2019-4-1 微众银行一面</h4><ol><li>Vue 双向绑定</li><li>虚拟 Dom</li><li>Diff 算法</li><li>闭包</li><li>闭包造成内存泄漏举例</li><li>继承</li><li>http 和 https 的区别</li><li>es6 的了解</li><li>是否会愿意留在公司</li><li>你的优点</li><li>为什么选择微众</li></ol><p>面试时间:  4.1 19:00-19:40  40 分钟</p><h3 id="酷家乐（获得-OFFER）"><a href="#酷家乐（获得-OFFER）" class="headerlink" title="酷家乐（获得 OFFER）"></a>酷家乐（获得 OFFER）</h3><h4 id="1-2019-4-18-酷家乐一面"><a href="#1-2019-4-18-酷家乐一面" class="headerlink" title="1. 2019-4-18 酷家乐一面"></a>1. 2019-4-18 酷家乐一面</h4><ol><li>基本数据类型</li><li>null 和 undefined 的区别</li><li>class 相对于 es5 的继承有什么区别</li><li>作用域和闭包</li><li>Webpack loader 和 plugins 的区别</li><li>原型链和 this</li><li>输入 url 的过程</li><li>层叠上下文</li><li>Git rebase 和 git merge 的区别</li><li>前端学习的方式</li><li>为什么选择前端</li></ol><p>面试时间：4.18 14:35-15:10 35分钟</p><h4 id="2-2019-4-22-酷家乐二面"><a href="#2-2019-4-22-酷家乐二面" class="headerlink" title="2. 2019-4-22 酷家乐二面"></a>2. 2019-4-22 酷家乐二面</h4><ol><li>项目介绍</li><li>Vue 的双向绑定机制</li><li>权限管理</li><li>Vue 中组件通信方式</li><li>Vue Data 中为什么要使用函数的方式</li><li>面向对象设计问题，自动超市购买商品设计</li><li>智力题，五只鸡五天能下五个蛋，多少只鸡一百天下一百个蛋</li><li>智力题，药罐污染问题</li></ol><p>面试时间： 4.22 15:06-16:06  60 分钟</p><h4 id="3-2019-4-25-酷家乐三面"><a href="#3-2019-4-25-酷家乐三面" class="headerlink" title="3. 2019-4-25 酷家乐三面"></a>3. 2019-4-25 酷家乐三面</h4><ol><li>实习时间</li><li>前端方向</li><li>项目</li><li>懒加载</li><li>状态持久化</li><li>图片优化的方式</li><li>浏览器如何判断是否支持 webp 格式图片</li><li>Display 的常见属性</li><li>改变url的几种方式</li></ol><p>面试时间： 4.25 20:35-21:10  35分钟</p><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><h4 id="1-2019-4-22-京东一面"><a href="#1-2019-4-22-京东一面" class="headerlink" title="1. 2019-4-22 京东一面"></a>1. 2019-4-22 京东一面</h4><ol><li>前端工程师的理解</li><li>项目介绍</li><li>Vuex 的底层实现</li><li>Vue router 的实现</li><li>缓存的了解</li><li>Computed 和 watch 的区别</li><li>Proto 和 ptototype</li><li>Object.defineProperty() 方法</li><li>发布订阅者模式和观察者模式的区别</li><li>no-cache</li><li>cache-control 可以有几个值，没有限制吧….</li><li>webpack-loader</li><li>其他构建工具</li></ol><p>面试时间:  4.22 11:01-10:32  31 分钟</p><h3 id="亿联网络"><a href="#亿联网络" class="headerlink" title="亿联网络"></a>亿联网络</h3><h4 id="1-2019-4-24-亿联网络一面"><a href="#1-2019-4-24-亿联网络一面" class="headerlink" title="1. 2019-4-24 亿联网络一面"></a>1. 2019-4-24 亿联网络一面</h4><ol><li>项目介绍</li><li>懒加载具体实现</li><li>数组打平</li><li>Kmp</li><li>磁盘读取</li><li>数据库索引</li></ol><p>面试时间：4.24 17:00-17:30  30分钟</p><h3 id="OPPO（获得-OFFER）"><a href="#OPPO（获得-OFFER）" class="headerlink" title="OPPO（获得 OFFER）"></a>OPPO（获得 OFFER）</h3><h4 id="1-2019-4-26-OPPO一面"><a href="#1-2019-4-26-OPPO一面" class="headerlink" title="1. 2019-4-26 OPPO一面"></a>1. 2019-4-26 OPPO一面</h4><ol><li>Js 数据类型</li><li>判断 Array</li><li>DOMContentLoaded 事件和 Load 事件的区别</li><li>闭包</li><li>模块化</li><li>模块循环引用</li><li>Js 文件异步加载</li><li>Vue 双向绑定</li><li>Watch 和 computed</li><li>虚拟 dom</li><li>浏览器缓存</li></ol><p>面试时间： 4.26 14:00-14:30  30分钟</p><h4 id="2-2019-5-8-OPPO二面（hr）"><a href="#2-2019-5-8-OPPO二面（hr）" class="headerlink" title="2. 2019-5-8 OPPO二面（hr）"></a>2. 2019-5-8 OPPO二面（hr）</h4><ol><li>自我介绍</li><li>压力最大的时候</li><li>学习方法</li><li>为什么选择 oppo</li><li>实习时间</li><li>其他的爱好</li><li>其他的公司</li></ol><p>面试时间：5.8 16:30-16:50  20分钟</p><h3 id="华为（获得-OFFER）"><a href="#华为（获得-OFFER）" class="headerlink" title="华为（获得 OFFER）"></a>华为（获得 OFFER）</h3><h4 id="1-2019-4-28-华为一面"><a href="#1-2019-4-28-华为一面" class="headerlink" title="1. 2019-4-28 华为一面"></a>1. 2019-4-28 华为一面</h4><ol><li>项目经历</li><li>实习时间</li></ol><p>面试时间： 4.28 14:00-14:25  25分钟</p><h4 id="2-2019-4-28-华为二面"><a href="#2-2019-4-28-华为二面" class="headerlink" title="2. 2019-4-28 华为二面"></a>2. 2019-4-28 华为二面</h4><ol><li>项目经历</li><li>什么是 es5</li><li>Webpack</li><li>后端框架</li><li>有女朋友吗</li><li>工作地点</li><li>实习时间</li></ol><p>面试时间：4.28 14:30-14:55  25分钟</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;面试记录总结&quot;&gt;&lt;a href=&quot;#面试记录总结&quot; class=&quot;headerlink&quot; title=&quot;面试记录总结&quot;&gt;&lt;/a&gt;面试记录总结&lt;/h2&gt;&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93&quot;&gt;面试记录总结&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%9B%AE%E5%BD%95&quot;&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E8%8E%B7%E5%BE%97-offer&quot;&gt;阿里巴巴（获得 OFFER）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-3-25-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-3-25 阿里巴巴（淘宝）一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2019-3-28-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E9%9D%A2&quot;&gt;2. 2019-3-28 阿里巴巴（淘宝）二面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-2019-4-1-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%B8%89%E9%9D%A2&quot;&gt;3. 2019-4-1 阿里巴巴（淘宝）三面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-2019-4-3-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E5%9B%9B%E9%9D%A2hr&quot;&gt;4. 2019-4-3 阿里巴巴（淘宝）四面（hr）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-2019-4-29-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%80%E9%9D%A2&quot;&gt;5. 2019-4-29 阿里巴巴（阿里云）一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-2019-5-27-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%8C%E9%9D%A2&quot;&gt;6. 2019-5-27 阿里巴巴（阿里云）二面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-2019-5-29-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E8%BD%AE%E4%B8%80%E9%9D%A2&quot;&gt;7. 2019-5-29 阿里巴巴（淘宝二轮）一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8-2019-5-31-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E8%BD%AE%E4%BA%8C%E9%9D%A2&quot;&gt;8. 2019-5-31 阿里巴巴（淘宝二轮）二面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9-2019-5-31-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%B7%98%E5%AE%9D%E4%BA%8C%E8%BD%AE%E4%B8%89%E9%9D%A2hr&quot;&gt;9. 2019-5-31 阿里巴巴（淘宝二轮）三面（hr）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%85%BE%E8%AE%AF%E8%8E%B7%E5%BE%97-offer&quot;&gt;腾讯（获得 OFFER）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-26-%E8%85%BE%E8%AE%AFteg%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-26 腾讯（TEG）一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2019-4-29-%E8%85%BE%E8%AE%AFteg%E4%BA%8C%E9%9D%A2&quot;&gt;2. 2019-4-29 腾讯（TEG）二面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-2019-5-9-%E8%85%BE%E8%AE%AFteg%E4%B8%89%E9%9D%A2&quot;&gt;3. 2019-5-9 腾讯（TEG）三面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-2019-5-17-%E8%85%BE%E8%AE%AFteg%E5%9B%9B%E9%9D%A2hr&quot;&gt;4. 2019-5-17 腾讯（TEG）四面（hr）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E8%8E%B7%E5%BE%97-offer&quot;&gt;网易互娱（获得 OFFER）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-15-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-15 网易互娱一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2019-4-18-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%BA%8C%E9%9D%A2&quot;&gt;2. 2019-4-18 网易互娱二面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8&quot;&gt;字节跳动&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-3-23-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-3-23 字节跳动一面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C&quot;&gt;微众银行&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-1-%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-1 微众银行一面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%85%B7%E5%AE%B6%E4%B9%90%E8%8E%B7%E5%BE%97-offer&quot;&gt;酷家乐（获得 OFFER）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-18-%E9%85%B7%E5%AE%B6%E4%B9%90%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-18 酷家乐一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2019-4-22-%E9%85%B7%E5%AE%B6%E4%B9%90%E4%BA%8C%E9%9D%A2&quot;&gt;2. 2019-4-22 酷家乐二面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-2019-4-25-%E9%85%B7%E5%AE%B6%E4%B9%90%E4%B8%89%E9%9D%A2&quot;&gt;3. 2019-4-25 酷家乐三面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%AC%E4%B8%9C&quot;&gt;京东&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-22-%E4%BA%AC%E4%B8%9C%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-22 京东一面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%BF%E8%81%94%E7%BD%91%E7%BB%9C&quot;&gt;亿联网络&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-24-%E4%BA%BF%E8%81%94%E7%BD%91%E7%BB%9C%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-24 亿联网络一面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#oppo%E8%8E%B7%E5%BE%97-offer&quot;&gt;OPPO（获得 OFFER）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-26-oppo%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-26 OPPO一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2019-5-8-oppo%E4%BA%8C%E9%9D%A2hr&quot;&gt;2. 2019-5-8 OPPO二面（hr）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%8E%E4%B8%BA%E8%8E%B7%E5%BE%97-offer&quot;&gt;华为（获得 OFFER）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-2019-4-28-%E5%8D%8E%E4%B8%BA%E4%B8%80%E9%9D%A2&quot;&gt;1. 2019-4-28 华为一面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2019-4-28-%E5%8D%8E%E4%B8%BA%E4%BA%8C%E9%9D%A2&quot;&gt;2. 2019-4-28 华为二面&lt;/a&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>算法知识</title>
    <link href="https://qyjs.github.io/2020/09/21/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/"/>
    <id>https://qyjs.github.io/2020/09/21/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法知识总结"><a href="#算法知识总结" class="headerlink" title="算法知识总结"></a>算法知识总结</h1><p>本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93">算法知识总结</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">常用算法和数据结构总结</a><ul><li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0">快速排序相对于其他排序效率更高的原因</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">系统自带排序实现</a></li><li><a href="#%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定性</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93">排序面试题目总结</a></li></ul></li><li><a href="#%E6%A0%91">树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8">二叉树相关性质</a></li><li><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">满二叉树</a></li><li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91avl">平衡二叉查找树（AVL）</a></li><li><a href="#b-%E6%A0%91">B-树</a></li><li><a href="#b%E6%A0%91">B+树</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">数据库索引</a></li><li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li><li><a href="#huffman-%E6%A0%91">Huffman 树</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a></li><li><a href="#%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9">求解二叉树中两个节点的最近公共祖先节点</a></li></ul></li><li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul><li><a href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">反转单向链表</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a><ul><li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98">爬楼梯问题</a><ul><li><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">递归方法分析</a></li><li><a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95">备忘录方法</a></li><li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95">迭代法</a></li></ul></li></ul></li><li><a href="#%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98">经典笔试题</a><ul><li><a href="#1-js-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E8%B6%85%E8%BF%87%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%8A%9F%E8%83%BD">1. js 实现一个函数，完成超过范围的两个大整数相加功能</a></li><li><a href="#2-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96">2. js 如何实现数组扁平化？</a></li><li><a href="#3-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">3. js 如何实现数组去重？</a></li><li><a href="#4-%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC">4. 如何求数组的最大值和最小值？</a></li><li><a href="#5-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5. 如何求两个数的最大公约数？</a></li><li><a href="#6-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">6. 如何求两个数的最小公倍数？</a></li><li><a href="#7-%E5%AE%9E%E7%8E%B0-indexof-%E6%96%B9%E6%B3%95">7. 实现 IndexOf 方法？</a></li><li><a href="#8-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2">8. 判断一个字符串是否为回文字符串？</a></li><li><a href="#9-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%8A%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%AF%94%E5%A6%82-sum1232valueof">9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</a></li><li><a href="#10-%E4%BD%BF%E7%94%A8-reduce-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0-foreachmapfilter">10. 使用 reduce 方法实现 forEach、map、filter</a></li><li><a href="#11-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E8%A6%81%E6%B1%82%E5%88%86%E5%88%AB%E5%9C%A8-134-%E7%A7%92%E5%90%8E%E6%89%93%E5%8D%B0%E5%87%BA-1-2-3">11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</a></li><li><a href="#12-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">12. 如何查找一篇英文文章中出现频率最高的单词？</a></li></ul></li></ul></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93">常见面试智力题总结</a><pre><code>- [1. 时针与分针夹角度数问题？](#1-时针与分针夹角度数问题)- [2. 用3升，5升杯子怎么量出4升水？](#2-用3升5升杯子怎么量出4升水)- [3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？](#3-四个药罐中有一个浑浊的药罐浑浊的每片药片都比其他三个干净的药罐多一克如何只用一次天平找出浑浊的药罐)- [4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？](#4-四张卡片卡片正面是数字反面是字母现在桌上四张卡片状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-我只能翻两张牌我翻哪两张)- [5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？](#5-赛马问题25-匹马5-个赛道最少几次能选出最快的三匹马)- [6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？](#6-五队夫妇参加聚会每个人不能和自己的配偶握手只能最多和他人握手一次a问了其他人发现每个人的握手次数都不同那么a的配偶握手了几次)- [7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？](#7-你只能带行走-60-公里的油只能在起始点加油如何穿过-80-公里的沙漠)- [8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？](#8-烧一根不均匀的绳要用一个小时如何用它来判断一个小时十五分钟)- [9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？](#9-有7克2克砝码各一个天平一只如何只用这些物品三次将140克的盐分成5090克各一份)- [10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？](#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约另一辆火车以第小时20公里的速度从纽约开往洛杉矶如果有一只鸟以外30公里每小时的速度和两辆火车现时启动从洛杉矶出发碰到另辆车后返回依次在两辆火车来回的飞行直道两面辆火车相遇请问这只小鸟飞行了多长距离)- [11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？](#11-你有两个罐子50个红色弹球50个蓝色弹球随机选出一个罐子随机选取出一个弹球放入罐子怎么给红色弹球最大的选中机会在你的计划中得到红球的准确几率是多少)- [12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？](#12-假设你有8个球其中一个略微重一些但是找出这个球的惟一方法是将两个球放在天平上对比最少要称多少次才能找出这个较重的球)- [13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？](#13-在房里有三盏灯房外有三个开关在房外看不见房内的情况你只能进门一次你用什么方法来区分那个开关控制那一盏灯)- [14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？](#14-他们都各自买了两对黑袜和两对白袜八对袜子的布质大小完全相同而每对袜子都有一张商标纸连着两位盲人不小心将八对袜子混在一起他们每人怎样才能取回黑袜和白袜各两对呢)- [15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签](#15-有三筐水果一筐装的全是苹果第二筐装的全是橘子第三筐是橘子与苹果混在一起筐上的标签都是骗人的就是说筐上的标签都是错的你的任务是拿出其中一筐从里面只拿一只水果然后正确写出三筐水果的标签)- [16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？](#16-一个班级60喜欢足球70喜欢篮球80喜欢排球问即三种球都喜欢占比有多少)- [17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？](#17-五只鸡五天能下五个蛋一百天下一百个蛋需要多少只鸡)</code></pre></li><li><a href="#%E5%89%91%E6%8C%87-offer-%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93">剑指 offer 思路总结</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a><ul><li><a href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">1. 二维数组中的查找</a></li><li><a href="#2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">2. 替换空格</a></li><li><a href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">3. 从尾到头打印链表</a></li><li><a href="#4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">4. 重建二叉树</a></li><li><a href="#5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">5. 用两个栈实现队列</a></li><li><a href="#6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">6. 旋转数组的最小数字</a></li><li><a href="#7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">7. 斐波那契数列</a></li><li><a href="#8-%E8%B7%B3%E5%8F%B0%E9%98%B6">8. 跳台阶</a></li><li><a href="#9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6">9. 变态跳台阶</a></li><li><a href="#10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96">10. 矩形覆盖</a></li><li><a href="#11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">11. 二进制中1的个数</a></li><li><a href="#12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">12. 数值的整数次方</a></li><li><a href="#13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">13. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">14. 链表中倒数第 k 个节点</a></li><li><a href="#15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">15. 反转链表</a></li><li><a href="#16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">16. 合并两个排序的链表</a></li><li><a href="#17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">17. 树的子结构</a></li><li><a href="#18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">18. 二叉树的镜像</a></li><li><a href="#19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">19. 顺时针打印矩阵</a></li><li><a href="#20-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0-min-%E5%87%BD%E6%95%B0">20. 定义一个栈，实现 min 函数</a></li><li><a href="#21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA">21. 栈的压入弹出</a></li><li><a href="#22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">22. 从上往下打印二叉树</a></li><li><a href="#23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">23. 二叉搜索树的后序遍历</a></li><li><a href="#24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E8%B7%AF%E5%BE%84">24. 二叉树中和为某一值路径</a></li><li><a href="#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">25. 复杂链表的复制</a></li><li><a href="#26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">26. 二叉搜索树与双向链表</a></li><li><a href="#27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">27. 字符串的排列</a></li><li><a href="#28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">28. 数组中出现次数超过一半的数字</a></li><li><a href="#29-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0">29. 最小的 K 个数</a></li><li><a href="#30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">30. 连续子数组的最大和</a></li><li><a href="#31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">31. 整数中1出现的次数（待深入理解）</a></li><li><a href="#32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">32. 把数组排成最小的数</a></li><li><a href="#33-%E4%B8%91%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">33. 丑数（待深入理解）</a></li><li><a href="#34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">34. 第一个只出现一次的字符</a></li><li><a href="#35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">35. 数组中的逆序对</a></li><li><a href="#36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">36. 两个链表的第一个公共结点</a></li><li><a href="#37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">37. 数字在排序数组中出现的次数</a></li><li><a href="#38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">38. 二叉树的深度</a></li><li><a href="#39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">39. 平衡二叉树</a></li><li><a href="#40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">40. 数组中只出现一次的数字</a></li><li><a href="#41-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">41. 和为 S 的连续正数序列</a></li><li><a href="#42-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">42. 和为 S 的两个数字</a></li><li><a href="#43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">43. 左旋转字符串</a></li><li><a href="#44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97">44. 翻转单词顺序列</a></li><li><a href="#45-%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90">45. 扑克牌的顺子</a></li><li><a href="#46-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98">46. 圆圈中最后剩下的数字（约瑟夫环问题）</a></li><li><a href="#47-123n">47. 1+2+3+…+n</a></li><li><a href="#48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">48. 不用加减乘除做加法</a></li><li><a href="#49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">49. 把字符串转换成整数</a></li><li><a href="#50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">50. 数组中重复的数字</a></li><li><a href="#51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">51. 构建乘积数组</a></li><li><a href="#52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D">52. 正则表达式的匹配</a></li><li><a href="#53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">53. 表示数值的字符串</a></li><li><a href="#54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6">54. 字符流中第一个不重复的字符</a></li><li><a href="#55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9">55. 链表中环的入口结点</a></li><li><a href="#56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9">56. 删除链表中重复的结点</a></li><li><a href="#57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">57. 二叉树的下一个结点</a></li><li><a href="#58-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">58. 对称二叉树</a></li><li><a href="#59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">59. 按之字形顺序打印二叉树（待深入理解）</a></li><li><a href="#60-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8C%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%E4%BB%8E%E5%B7%A6%E8%87%B3%E5%8F%B3%E8%BE%93%E5%87%BA%E6%AF%8F%E4%B8%80%E5%B1%82%E8%BE%93%E5%87%BA%E4%B8%80%E8%A1%8C">60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</a></li><li><a href="#61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">61. 序列化二叉树（待深入理解）</a></li><li><a href="#62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">62. 二叉搜索树的第 K 个节点</a></li><li><a href="#63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">63. 数据流中的中位数（待深入理解）</a></li><li><a href="#64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">64. 滑动窗口中的最大值（待深入理解）</a></li><li><a href="#65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">65. 矩阵中的路径（待深入理解）</a></li><li><a href="#66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">66. 机器人的运动范围（待深入理解）</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98">相关算法题</a><ul><li><a href="#1-%E6%98%8E%E6%98%9F%E9%97%AE%E9%A2%98">1. 明星问题</a></li><li><a href="#2-%E6%AD%A3%E8%B4%9F%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C">2. 正负数组求和</a></li></ul></li></ul></li></ul><h1 id="常用算法和数据结构总结"><a href="#常用算法和数据结构总结" class="headerlink" title="常用算法和数据结构总结"></a>常用算法和数据结构总结</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，<br>最终达到完全有序。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lastIndex &gt; <span class="number">0</span>) &#123; <span class="comment">// 当最后一个交换的元素为第一个时，说明后面全部排序完毕</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span>, k = lastIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">               lastIndex = j; <span class="comment">// 设置最后一次交换元素的位置</span></span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>冒泡排序有两种优化方式。</p><p>一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。<br>因此我们不需要再执行之后的外层循环，此时可以直接结束。</p><p>一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下<br>一轮循环中无需再去比较。</p><p>优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p><p>冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a><br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/">《常见排序算法 - 鸡尾酒排序 》</a><br><a href="https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1">《前端笔试&amp;面试爬坑系列—算法》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41">《前端面试之道》</a></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p><p>在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实<br>我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较<br>仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> minIndex = i; <span class="comment">// 设置当前循环最小元素索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前元素比最小元素索引，则更新最小元素索引</span></span><br><span class="line">      <span class="keyword">if</span> (array[minIndex] &gt; array[j]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换最小元素到当前位置</span></span><br><span class="line">    <span class="comment">// [array[i], array[minIndex]] = [array[minIndex], array[i]];</span></span><br><span class="line">    <span class="title function_">swap</span>(array, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = array[left];</span><br><span class="line">  array[left] = array[right];</span><br><span class="line">  array[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。</p><p>选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，<br>继续接，可能是中间数，就插在中间….依次</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环从 1 开始，0 位置为默认的已排序的序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = array[i]; <span class="comment">// 保存当前需要排序的元素</span></span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置</span></span><br><span class="line">    <span class="keyword">while</span> (j -<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将找到的位置插入元素</span></span><br><span class="line">    array[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p><p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元<br>素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hillSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一层确定增量的大小，每次增量的大小减半</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>); gap &gt;= <span class="number">1</span>; gap = <span class="built_in">parseInt</span>(gap &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个分组使用插入排序，相当于将插入排序的1换成了 n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = array[i];</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; array[j - gap] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - gap];</span><br><span class="line">        j -= gap;</span><br><span class="line">      &#125;</span><br><span class="line">      array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行<br>基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一<br>次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p><p>简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，<br>所以排序速度也很快。</p><p>希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p><p>插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，<br>所以希尔排序是一个不稳定的排序。</p><p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">《图解排序算法(二)之希尔排序》</a><br><a href="https://blog.csdn.net/u013630349/article/details/48250109">《数据结构基础 希尔排序 之 算法复杂度浅析》</a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后<br>将数组排序合并，最终合并为排序好的数组。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于0，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>), <span class="comment">// 找到中间索引值</span></span><br><span class="line">    left = array.<span class="title function_">slice</span>(<span class="number">0</span>, mid), <span class="comment">// 截取左半部分</span></span><br><span class="line">    right = array.<span class="title function_">slice</span>(mid, length); <span class="comment">// 截取右半部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right)); <span class="comment">// 递归分解后，进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArray, rightArray</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    leftLength = leftArray.<span class="property">length</span>,</span><br><span class="line">    rightLength = rightArray.<span class="property">length</span>,</span><br><span class="line">    il = <span class="number">0</span>,</span><br><span class="line">    ir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArray[il] &lt; rightArray[ir]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(leftArray[il++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(rightArray[ir++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(leftArray[il++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (ir &lt; rightLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(rightArray[ir++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每<br>一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p><p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归<br>并排序的空间复杂度为 O(n)。</p><p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">《图解排序算法(四)之归并排序》</a><br><a href="https://www.zhihu.com/question/27274006">《归并排序的空间复杂度？》</a></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据<br>都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span> || start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="title function_">partition</span>(array, start, end); <span class="comment">// 将数组划分为两部分，并返回右部分的第一个元素的索引值</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">quickSort</span>(array, start, index - <span class="number">1</span>); <span class="comment">// 递归排序左半部分</span></span><br><span class="line">  <span class="title function_">quickSort</span>(array, index + <span class="number">1</span>, end); <span class="comment">// 递归排序右半部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pivot = array[start]; <span class="comment">// 取第一个值为枢纽值，获取枢纽值的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 start 等于 end 指针时结束循环</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 end 指针指向的值大等于枢纽值时，end 指针向前移动</span></span><br><span class="line">    <span class="keyword">while</span> (array[end] &gt;= pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将比枢纽值小的值交换到 start 位置</span></span><br><span class="line">    array[start] = array[end];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动</span></span><br><span class="line">    <span class="keyword">while</span> (array[start] &lt; pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将比枢纽值大的值交换到 end 位置，进入下一次循环</span></span><br><span class="line">    array[end] = array[start];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将枢纽值交换到中间点</span></span><br><span class="line">  array[start] = pivot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回中间索引值</span></span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值<br>等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者<br>start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的<br>值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递<br>归左右两边的的序列。</p><p>当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂<br>度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。</p><p>当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏<br>的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。</p><p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p><p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6262208.html">《图解排序算法(五)之快速排序——三数取中法》</a><br><a href="https://segmentfault.com/a/1190000004410119#articleHeader2">《关于快速排序的四种写法》</a><br><a href="https://harttle.land/2015/09/27/quick-sort.html">《快速排序的时间和空间复杂度》</a><br><a href="https://blog.csdn.net/weshjiness/article/details/8660583">《快速排序最好，最坏，平均复杂度分析》</a><br><a href="https://blog.csdn.net/qq_33758761/article/details/76782610">《快速排序算法的递归深度》</a></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行<br>交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，<br>便能得到一个有序序列了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">buildMaxHeap</span>(array); <span class="comment">// 将传入的数组建立为大顶堆</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(array, <span class="number">0</span>, i);</span><br><span class="line">    <span class="title function_">adjustMaxHeap</span>(array, <span class="number">0</span>, i); <span class="comment">// 将剩下的元素重新构建为大顶堆</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adjustMaxHeap</span>(<span class="params">array, index, heapSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> iMax,</span><br><span class="line">    iLeft,</span><br><span class="line">    iRight;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    iMax = index; <span class="comment">// 保存最大值的索引</span></span><br><span class="line">    iLeft = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">// 获取左子元素的索引</span></span><br><span class="line">    iRight = <span class="number">2</span> * index + <span class="number">2</span>; <span class="comment">// 获取右子元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子元素存在，且左子元素大于最大值，则更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) &#123;</span><br><span class="line">      iMax = iLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子元素存在，且右子元素大于最大值，则更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">      iMax = iRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树</span></span><br><span class="line">    <span class="keyword">if</span> (iMax !== index) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(array, index, iMax);</span><br><span class="line">      index = iMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果未被更新，说明该子树满足大顶堆的要求，退出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>,</span><br><span class="line">    iParent = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// 获取最后一个非叶子点的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">adjustMaxHeap</span>(array, i, length); <span class="comment">// 循环调整每一个子树，使其满足大顶堆的要求</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, i, j</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = array[i];</span><br><span class="line">  array[i] = array[j];</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在<br>不管什么情况下都是 O(nlogn)。</p><p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">《图解排序算法(三)之堆排序》</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">《常见排序算法 - 堆排序 (Heap Sort)》</a><br><a href="https://www.zhihu.com/question/20729324">《堆排序中建堆过程时间复杂度O(n)怎么来的？》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297">《排序算法之 堆排序 及其时间复杂度和空间复杂度》</a><br><a href="https://blog.csdn.net/hrn1216/article/details/51465270">《最小堆 构建、插入、删除的过程图解》</a></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将<br>所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样<br>从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">radixSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> bucket = [],</span><br><span class="line">    max = array[<span class="number">0</span>],</span><br><span class="line">    loop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定排序数组中的最大值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">      max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定最大值的位数</span></span><br><span class="line">  loop = (max + <span class="string">&#x27;&#x27;</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化桶</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bucket[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = array[j] + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (str.<span class="property">length</span> &gt;= i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = <span class="built_in">parseInt</span>(str[str.<span class="property">length</span> - <span class="number">1</span> - i]); <span class="comment">// 获取当前位的值，作为插入的索引</span></span><br><span class="line">        bucket[k].<span class="title function_">push</span>(array[j]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理位数不够的情况，高位默认为 0</span></span><br><span class="line">        bucket[<span class="number">0</span>].<span class="title function_">push</span>(array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array.<span class="title function_">splice</span>(<span class="number">0</span>, length); <span class="comment">// 清空旧的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用桶重新初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> t = bucket[i].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">        array.<span class="title function_">push</span>(bucket[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bucket[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定<br>排序。</p><p>详细资料可以参考：<br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/">《常见排序算法 - 基数排序》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44594415">《排序算法之 基数排序 及其时间复杂度和空间复杂度》</a></p><p>算法总结可以参考：<br><a href="https://blog.csdn.net/zolalad/article/details/11848739">《算法的时间复杂度和空间复杂度-总结》</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">《十大经典排序算法（动图演示）》</a><br><a href="https://blog.csdn.net/wangiijing/article/details/51485119">《各类排序算法的对比及实现》</a></p><h3 id="快速排序相对于其他排序效率更高的原因"><a href="#快速排序相对于其他排序效率更高的原因" class="headerlink" title="快速排序相对于其他排序效率更高的原因"></a>快速排序相对于其他排序效率更高的原因</h3><p>上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同<br>数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p><p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看<br>的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最<br>坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？</p><p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因<br>此归并排序首先就被排除掉了。</p><p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p><p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在<br>枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我<br>们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互<br>换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较<br>是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p><p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机<br>中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原<br>理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当<br>前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理<br>来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于<br>空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行<br>数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显<br>提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来<br>说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更<br>高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可<br>以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其<br>他的因素。</p><p>相关资料可以参考：<br><a href="https://www.zhihu.com/question/23873747">《为什么在平均情况下快速排序比堆排序要优秀？》</a><br><a href="https://blog.csdn.net/qq_36770641/article/details/82669788">《为什么说快速排序是性能最好的排序算法？》</a></p><h3 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h3><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据<br>量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，<br>而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p><p>稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，<br>当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p><h3 id="排序面试题目总结"><a href="#排序面试题目总结" class="headerlink" title="排序面试题目总结"></a>排序面试题目总结</h3><ol><li><p>快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p></li><li><p>初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p></li><li><p>合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p></li><li><p>外部排序常用的算法是归并排序。</p></li><li><p>数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p></li><li><p>如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p></li><li><p>插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p></li><li><p>对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p></li><li><p>下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。<br>因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p></li><li><p>拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p></li><li><p>任何一个基于”比较”的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!，<br>时间下界为 O(nlogn)</p></li><li><p>m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p></li><li><p>对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</p></li><li><p>在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p></li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树相关性质"><a href="#二叉树相关性质" class="headerlink" title="二叉树相关性质"></a>二叉树相关性质</h3><ol><li><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p></li><li><p>叶节点或终端节点：度为零的节点；</p></li><li><p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。</p></li><li><p>树的高度或深度：树中节点的最大层次。</p></li><li><p>在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i&gt;=1。</p></li><li><p>深度为 h 的二叉树最多有 2^h-1个结点(h&gt;=1)，最少有 h 个结点。</p></li><li><p>对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1；</p></li><li><p>给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。</p></li><li><p>二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。</p></li><li><p>二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。</p></li><li><p>二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。</p></li><li><p>二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。</p></li><li><p>一个带权的无向连通图的最小生成树的权值之和是唯一的。</p></li><li><p>只有一个结点的二叉树的度为 0 。</p></li><li><p>二叉树的度是以节点的最大的度数定义的。</p></li><li><p>树的后序遍历序列等同于该树对应的二叉树的中序序列。</p></li><li><p>树的先序遍历序列等同于该树对应的二叉树的先序序列。</p></li><li><p>线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列：<br>debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。</p></li><li><p>递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，<br>也就是深度d！=logn，有可能d&gt;&gt;logn。所以栈大小应该是O（d）</p></li><li><p>一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，<br>即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。</p></li><li><p>引入二叉线索树的目的是加快查找结点的前驱或后继的速度。</p></li><li><p>二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。</p></li><li><p>不管是几叉树，节点数等于=分叉数+1</p></li><li><p>任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。</p></li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/adminabcd/article/details/46672759">《n 个节点的二叉树有多少种形态》</a><br><a href="https://www.cnblogs.com/guoyaohua/p/8595289.html">《数据结构二叉树知识点总结》</a><br><a href="https://www.jianshu.com/p/2943a21d2a99">《还原二叉树–已知先序中序或者后序中序》</a><br><a href="https://blog.csdn.net/linraise/article/details/11745559">《树、森林与二叉树的转换》</a></p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满<br>二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满<br>二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</p><p>性质：</p><ol><li><p>具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数)</p></li><li><p>有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则<br>如果 I&gt;1，则其父结点的编号为 I/2；</p></li><li><p>完全二叉树，如果 2 <em>I &lt;= N，则其左儿子（即左子树的根结点）的编号为2* I；若2 *I &gt; N，则无左儿子；如<br>果 2</em> I + 1 &lt;= N，则其右儿子的结点编号为 2 *I + 1；若 2* I + 1 &gt; N，则无右儿子。</p></li></ol><h3 id="平衡二叉查找树（AVL）"><a href="#平衡二叉查找树（AVL）" class="headerlink" title="平衡二叉查找树（AVL）"></a>平衡二叉查找树（AVL）</h3><p>平衡二叉查找树具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li></ol><p>平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有<br>一点帮帮助，反而增加了维护的成本。</p><p>平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树<br>的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/suimeng/p/4560056.html">《平衡二叉树，AVL树之图解篇》</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O<br>次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，<br>我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少<br>索引树的高度是提高索引效率的关键。</p><p>B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每<br>个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页<br>只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树<br>的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查<br>找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561220&idx=1&sn=2a6d8a0290f967027b1d54456f586405&chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&scene=21#wechat_redirect">《漫画：什么是 B- 树？》</a></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。<br>B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点<br>中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够<br>包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含<br>了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561244&idx=1&sn=df3abafd3aa2f5a3abfe507bfc26982f&chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&scene=21#wechat_redirect">《漫画：什么是 B+ 树？》</a></p><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建<br>立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是<br>由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。</p><p>相关资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/23624390">《深入浅出数据库索引原理》</a><br><a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html">《数据库的最简单实现》</a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子<br>节点的最长路径不会超过最短路径的两倍。</p><p>红黑树的有具体的规则：</p><p>1.节点是红色或黑色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p><p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561574&idx=1&sn=edab54460a85c9686e0ec0f5d178907c&chksm=f1feeaa5c68963b3689d23db68ab14a9c50a33dd5e9244a74d7765321b42af7ec14abfadf9ac&scene=21#wechat_redirect">《漫画：什么是红黑树？》</a><br><a href="https://cloud.tencent.com/developer/article/1101517">《漫画算法等精选文章目录》</a></p><h3 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h3><p>给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉<br>树，也称为 Huffman 树。</p><p>利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码<br>不是另一个字符编码的前缀。</p><p>性质：</p><ol><li><p>对应一组权重构造出来的 Huffman 树一般不是唯一的</p></li><li><p>Huffman 树具有最小的带权路径长度</p></li><li><p>Huffman 树中没有度为1的结点</p></li><li><p>哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近</p></li><li><p>Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和</p></li></ol><p>详细资料可以参考：</p><p><a href="https://blog.csdn.net/google19890102/article/details/54848262">《数据结构和算法—— Huffman 树和 Huffman 编码》</a><br><a href="https://blog.csdn.net/fx677588/article/details/70767446">《详细图解哈夫曼 Huffman 编码树》</a></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，<br>对于数值型和非数值型数据，比如字母和字符串，都是如此。</p><p>实现树节点类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类，树的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现二叉查找树类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现树的节点插入方法</p><p>节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，<br>否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。<br>循环这个过程直到找到合适的插入位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断根节点是否为空，如果不为空则递归插入到树中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertNode</span>(<span class="params">node, newNode</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。</span></span><br><span class="line">  <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">left</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">right</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过递归实现树的先序、中序、后序遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历通过递归实现</span></span><br><span class="line"><span class="comment">// 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。</span></span><br><span class="line"> <span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">preOrderTraverseNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     node.<span class="title function_">show</span>();</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 中序遍历通过递归实现</span></span><br><span class="line"> <span class="comment">// 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。</span></span><br><span class="line"> <span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">inOrderTraverseNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">     node.<span class="title function_">show</span>();</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后序遍历通过递归实现</span></span><br><span class="line"> <span class="comment">// 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。</span></span><br><span class="line"> <span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">postOrderTraverseNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">     node.<span class="title function_">show</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过循环实现树的先序、中序、后序遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历通过循环实现</span></span><br><span class="line"><span class="comment">// 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将</span></span><br><span class="line"><span class="comment">// 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。</span></span><br><span class="line"><span class="title function_">preOrderTraverseByStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现将根节点入栈，开始遍历</span></span><br><span class="line">  stack.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从栈中获取当前节点</span></span><br><span class="line">    <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行节点操作</span></span><br><span class="line">    node.<span class="title function_">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根</span></span><br><span class="line">    <span class="comment">// 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历通过循环实现</span></span><br><span class="line"><span class="comment">// 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有</span></span><br><span class="line"><span class="comment">// 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。</span></span><br><span class="line"><span class="title function_">inOrderTraverseByStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [],</span><br><span class="line">    node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">  <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">  <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> || node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(node);</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node = stack.<span class="title function_">pop</span>();</span><br><span class="line">      node.<span class="title function_">show</span>();</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历通过循环来实现</span></span><br><span class="line"><span class="comment">// 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次</span></span><br><span class="line"><span class="comment">// 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。</span></span><br><span class="line"><span class="title function_">postOrderTraverseByStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack1 = [],</span><br><span class="line">    stack2 = [],</span><br><span class="line">    node = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line">  <span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">  <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line"></span><br><span class="line">  stack1.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack1.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    stack2.<span class="title function_">push</span>(node);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">      stack1.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">      stack1.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack2.<span class="title function_">pop</span>();</span><br><span class="line">    node.<span class="title function_">show</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现寻找最大最小节点值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找最小值，在最左边的叶子节点上</span></span><br><span class="line"> <span class="title function_">findMinNode</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">left</span>) &#123;</span><br><span class="line">     node = node.<span class="property">left</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 寻找最大值，在最右边的叶子节点上</span></span><br><span class="line"></span><br><span class="line"> <span class="title function_">findMaxNode</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">right</span>) &#123;</span><br><span class="line">     node = node.<span class="property">right</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现寻找特定大小节点值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找特定值</span></span><br><span class="line"><span class="title function_">find</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findNode</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现移除节点值</p><p>移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如<br>果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 移除指定值节点</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">removeNode</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找指定节点</span></span><br><span class="line">  <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种情况——没有叶节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点</span></span><br><span class="line">    <span class="comment">// 的值，保持树的特性，然后将替换的节点去掉</span></span><br><span class="line">    <span class="keyword">let</span> aux = <span class="variable language_">this</span>.<span class="title function_">findMinNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    node.<span class="property">value</span> = aux.<span class="property">value</span>;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node.<span class="property">right</span>, aux);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求解二叉树中两个节点的最近公共祖先节点"><a href="#求解二叉树中两个节点的最近公共祖先节点" class="headerlink" title="求解二叉树中两个节点的最近公共祖先节点"></a>求解二叉树中两个节点的最近公共祖先节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑</span><br><span class="line"></span><br><span class="line">（1）该二叉树为搜索二叉树 </span><br><span class="line"></span><br><span class="line">    解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于</span><br><span class="line">    根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个</span><br><span class="line">    节点的值小时，该节点则为两个节点的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。</span><br><span class="line"></span><br><span class="line">    通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点</span><br><span class="line">    的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。</span><br><span class="line"></span><br><span class="line">    这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同</span><br><span class="line">    的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/xyzbaihaiping/article/details/52122885">《二叉树中两个节点的最近公共祖先节点》</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><p>需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是<br>一道面试常考题。</p><p>思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> current = head;</span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">    <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">    <span class="comment">// 然后把当前节点的 next 设为上一个节点</span></span><br><span class="line">    <span class="comment">// 然后把 current 设为下一个节点，pre 设为当前节点</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        next = current.<span class="property">next</span>;</span><br><span class="line">        current.<span class="property">next</span> = pre;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？</p><h4 id="递归方法分析"><a href="#递归方法分析" class="headerlink" title="递归方法分析"></a>递归方法分析</h4><p>由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，<br>因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上<br>从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到<br>2级阶梯的走法数量。</p><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClimbingWays</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getClimbingWays</span>(n - <span class="number">1</span>) + <span class="title function_">getClimbingWays</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度<br>为递归的深度 O(logn)。</p><h4 id="备忘录方法"><a href="#备忘录方法" class="headerlink" title="备忘录方法"></a>备忘录方法</h4><p>分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给<br>保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。</p><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getClimbingWays</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="title function_">getClimbingWays</span>(n - <span class="number">1</span>) + <span class="title function_">getClimbingWays</span>(n - <span class="number">2</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(n, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。</p><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClimbingWays</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561168&idx=1&sn=9d1c6f7ba6d651c75399c4aa5254a7d8&chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&scene=21#wechat_redirect">《漫画：什么是动态规划？（整合版）》</a></p><h2 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h2><h4 id="1-js-实现一个函数，完成超过范围的两个大整数相加功能"><a href="#1-js-实现一个函数，完成超过范围的两个大整数相加功能" class="headerlink" title="1. js 实现一个函数，完成超过范围的两个大整数相加功能"></a>1. js 实现一个函数，完成超过范围的两个大整数相加功能</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumberAdd</span>(<span class="params">number1, number2</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>, <span class="comment">// 保存最后结果</span></span><br><span class="line">    carry = <span class="literal">false</span>; <span class="comment">// 保留进位结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将字符串转换为数组</span></span><br><span class="line">  number1 = number1.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  number2 = number2.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当数组的长度都变为0，并且最终不再进位时，结束循环</span></span><br><span class="line">  <span class="keyword">while</span> (number1.<span class="property">length</span> || number2.<span class="property">length</span> || carry) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0</span></span><br><span class="line">    carry += ~~number1.<span class="title function_">pop</span>() + ~~number2.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取加法结果的个位加入最终结果</span></span><br><span class="line">    result = carry % <span class="number">10</span> + result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0</span></span><br><span class="line">    carry = carry &gt; <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回最终结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/fe_dev/article/details/80079372">《JavaScript实现超范围的数相加》</a><br>   <a href="https://blog.csdn.net/q1059081877q/article/details/80689194">《js 实现大整数加法》</a></p><h4 id="2-js-如何实现数组扁平化？"><a href="#2-js-如何实现数组扁平化？" class="headerlink" title="2. js 如何实现数组扁平化？"></a>2. js 如何实现数组扁平化？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中</span></span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) ? <span class="title function_">flattenArray</span>(item) : item);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> +item;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/36">《JavaScript专题之数组扁平化》</a></p><h4 id="3-js-如何实现数组去重？"><a href="#3-js-如何实现数组去重？" class="headerlink" title="3. js 如何实现数组去重？"></a>3. js 如何实现数组去重？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/27">《JavaScript专题之数组去重》</a></p><h4 id="4-如何求数组的最大值和最小值？"><a href="#4-如何求数组的最大值和最小值？" class="headerlink" title="4. 如何求数组的最大值和最小值？"></a>4. 如何求数组的最大值和最小值？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/35">《JavaScript专题之如何求数组的最大值和最小值》</a></p><h4 id="5-如何求两个数的最大公约数？"><a href="#5-如何求两个数的最大公约数？" class="headerlink" title="5. 如何求两个数的最大公约数？"></a>5. 如何求两个数的最大公约数？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，</span><br><span class="line">直到余数为<span class="number">0</span>时，最后的被除数就是两个数的最大公约数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxCommonDivisor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getMaxCommonDivisor</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-如何求两个数的最小公倍数？"><a href="#6-如何求两个数的最小公倍数？" class="headerlink" title="6. 如何求两个数的最小公倍数？"></a>6. 如何求两个数的最小公倍数？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本思想是采用将两个数相乘，然后除以它们的最大公约数</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMinCommonMultiple</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b / <span class="title function_">getMaxCommonDivisor</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/cssfirefly/archive/2012/10/23/2734936.html">《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》</a></p><h4 id="7-实现-IndexOf-方法？"><a href="#7-实现-IndexOf-方法？" class="headerlink" title="7. 实现 IndexOf 方法？"></a>7. 实现 IndexOf 方法？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">indexFun</span>(<span class="params">array, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === val) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="8-判断一个字符串是否为回文字符串？"><a href="#8-判断一个字符串是否为回文字符串？" class="headerlink" title="8. 判断一个字符串是否为回文字符串？"></a>8. 判断一个字符串是否为回文字符串？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/[\W_]/g</span>, <span class="comment">// 匹配所有非单词的字符以及下划线</span></span><br><span class="line">    newStr = str.<span class="title function_">replace</span>(reg, <span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>(), <span class="comment">// 替换为空字符并将大写字母转换为小写</span></span><br><span class="line">    reverseStr = newStr.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 将字符串反转</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr === newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf"><a href="#9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf" class="headerlink" title="9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()"></a>9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">result = args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> pre + item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">  result = args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + item;</span><br><span class="line">  &#125;, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-使用-reduce-方法实现-forEach、map、filter"><a href="#10-使用-reduce-方法实现-forEach、map、filter" class="headerlink" title="10. 使用 reduce 方法实现 forEach、map、filter"></a>10. 使用 reduce 方法实现 forEach、map、filter</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEachUseReduce</span>(<span class="params">array, handler</span>) &#123;</span><br><span class="line">  array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item, index</span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(item, index);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapUseReduce</span>(<span class="params">array, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item, index</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mapItem = <span class="title function_">handler</span>(item, index);</span><br><span class="line">    result.<span class="title function_">push</span>(mapItem);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterUseReduce</span>(<span class="params">array, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item, index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">handler</span>(item, index)) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”"><a href="#11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”" class="headerlink" title="11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”"></a>11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">time</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addTask</span>(<span class="params">task, t</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">time</span> += t;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>([task, <span class="variable language_">this</span>.<span class="property">time</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        item[<span class="number">0</span>]();</span><br><span class="line">      &#125;, item[<span class="number">1</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-如何查找一篇英文文章中出现频率最高的单词？"><a href="#12-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="12. 如何查找一篇英文文章中出现频率最高的单词？"></a>12. 如何查找一篇英文文章中出现频率最高的单词？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMostWord</span>(<span class="params">article</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法性判断</span></span><br><span class="line"><span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数处理</span></span><br><span class="line">article = article.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wordList = article.<span class="title function_">match</span>(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line"> visited = [],</span><br><span class="line"> maxNum = <span class="number">0</span>,</span><br><span class="line"> maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">article = <span class="string">&quot; &quot;</span> + wordList.<span class="title function_">join</span>(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">wordList.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (visited.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">     num = article.<span class="title function_">match</span>(word).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">     maxNum = num;</span><br><span class="line">     maxWord = item;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><h4 id="1-时针与分针夹角度数问题？"><a href="#1-时针与分针夹角度数问题？" class="headerlink" title="1. 时针与分针夹角度数问题？"></a>1. 时针与分针夹角度数问题？</h4><p>   分析：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</span><br><span class="line"></span><br><span class="line">我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。</span><br><span class="line"></span><br><span class="line">时针每走一格为 30 度。</span><br><span class="line"></span><br><span class="line">因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。</span><br><span class="line"></span><br><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure><p>   答案：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; </span><br></pre></td></tr></table></figure><p>   详细资料参考：<br>   <a href="https://blog.csdn.net/prstaxy/article/details/22210829">《面试智力题 — 时针与分针夹角度数问题》</a></p><h4 id="2-用3升，5升杯子怎么量出4升水？"><a href="#2-用3升，5升杯子怎么量出4升水？" class="headerlink" title="2. 用3升，5升杯子怎么量出4升水？"></a>2. 用3升，5升杯子怎么量出4升水？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。</span><br><span class="line"></span><br><span class="line">（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。</span><br><span class="line"></span><br><span class="line">（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</span><br></pre></td></tr></table></figure><h4 id="3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"><a href="#3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？" class="headerlink" title="3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"></a>3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。</span><br><span class="line"></span><br><span class="line">（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。</span><br><span class="line"></span><br><span class="line">（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4</span><br><span class="line">    片药片。</span><br><span class="line"></span><br><span class="line">（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</span><br></pre></td></tr></table></figure><h4 id="4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？"><a href="#4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？" class="headerlink" title="4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？"></a>4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</span><br></pre></td></tr></table></figure><h4 id="5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？"><a href="#5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？" class="headerlink" title="5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？"></a>5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我认为一共至少需要 7 次才能选出最快的三匹马。</span><br><span class="line"></span><br><span class="line">（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直</span><br><span class="line">    接淘汰掉，那么我们现在还剩下了 15 匹马。</span><br><span class="line"></span><br><span class="line">（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余</span><br><span class="line">    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，</span><br><span class="line">    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，</span><br><span class="line">    它们都有竞争最快第二第三的机会。</span><br><span class="line"></span><br><span class="line">（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</span><br></pre></td></tr></table></figure><h4 id="6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"><a href="#6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？" class="headerlink" title="6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"></a>6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。</span><br><span class="line"></span><br><span class="line">（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因</span><br><span class="line">    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。</span><br><span class="line"></span><br><span class="line">（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有</span><br><span class="line">    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。</span><br><span class="line"></span><br><span class="line">（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手</span><br><span class="line">    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数</span><br><span class="line">    为 1 的人是配偶。</span><br><span class="line"></span><br><span class="line">（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。</span><br><span class="line"></span><br><span class="line">（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。</span><br><span class="line"></span><br><span class="line">（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</span><br></pre></td></tr></table></figure><h4 id="7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？"><a href="#7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？" class="headerlink" title="7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？"></a>7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。</span><br><span class="line"></span><br><span class="line">（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路</span><br><span class="line">    程。</span><br></pre></td></tr></table></figure><h4 id="8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"><a href="#8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？" class="headerlink" title="8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"></a>8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。</span><br><span class="line">  </span><br><span class="line">（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。</span><br><span class="line"></span><br><span class="line">（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。</span><br><span class="line"></span><br><span class="line">（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。</span><br><span class="line"></span><br><span class="line">（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</span><br></pre></td></tr></table></figure><h4 id="9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"><a href="#9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？" class="headerlink" title="9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"></a>9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。</span><br><span class="line"></span><br><span class="line">（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。</span><br><span class="line"></span><br><span class="line">（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</span><br></pre></td></tr></table></figure><h4 id="10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"><a href="#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？" class="headerlink" title="10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"></a>10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此</span><br><span class="line">两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</span><br></pre></td></tr></table></figure><h4 id="11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"><a href="#11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？" class="headerlink" title="11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"></a>11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</span><br></pre></td></tr></table></figure><h4 id="12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"><a href="#12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？" class="headerlink" title="12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"></a>12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最少两次可以称出。</span><br><span class="line"></span><br><span class="line">首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。</span><br><span class="line"></span><br><span class="line">第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如</span><br><span class="line">果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</span><br></pre></td></tr></table></figure><h4 id="13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"><a href="#13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？" class="headerlink" title="13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"></a>13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）首先打开一盏灯 10 分钟，然后打开第二盏。</span><br><span class="line">（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开</span><br><span class="line">    的。</span><br></pre></td></tr></table></figure><h4 id="14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"><a href="#14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？" class="headerlink" title="14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"></a>14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</span><br></pre></td></tr></table></figure><h4 id="15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签"><a href="#15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签" class="headerlink" title="15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签"></a>15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。</span><br><span class="line"></span><br><span class="line">对应水果标签的筐的标签改为另一种水果。</span><br><span class="line"></span><br><span class="line">另一种水果标签的框改为混合。</span><br></pre></td></tr></table></figure><h4 id="16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？"><a href="#16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？" class="headerlink" title="16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？"></a>16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。</span><br><span class="line"></span><br><span class="line">（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多</span><br><span class="line">    90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。</span><br><span class="line"></span><br><span class="line">因此三种球都喜欢的人占比为 10%-60%</span><br></pre></td></tr></table></figure><h4 id="17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"><a href="#17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？" class="headerlink" title="17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"></a>17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</span><br></pre></td></tr></table></figure><p>   更多的智力题可以参考：<br>   <a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题200+题和解答》</a></p><h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><p>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动</span><br><span class="line">    ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20</span><br><span class="line">Are%20Happy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”</span><br><span class="line"></span><br><span class="line">str.replace(/\s/g,&quot;%20&quot;)</span><br></pre></td></tr></table></figure><h4 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，从尾到头打印链表每个节点的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的</span><br><span class="line">实现可以利用 Array 的 push 和 pop 方法来模拟。</span><br></pre></td></tr></table></figure><h4 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输</span><br><span class="line">入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左</span><br><span class="line">边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的</span><br><span class="line">时间复杂度为 O(n)，空间复杂度为 O(logn)。</span><br></pre></td></tr></table></figure><h4 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接</span><br><span class="line">将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中</span><br><span class="line">的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line"></span><br><span class="line">当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</span><br></pre></td></tr></table></figure><h4 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的</span><br><span class="line">最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大</span><br><span class="line">小为0，请返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相</span><br><span class="line">    邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。</span><br><span class="line"></span><br><span class="line">（2）二分法</span><br></pre></td></tr></table></figure><p>   相关资料可以参考：<br>   <a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p><h4 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠</span><br><span class="line">加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</span><br></pre></td></tr></table></figure><h4 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一</span><br><span class="line">种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。</span><br><span class="line"></span><br><span class="line">和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</span><br></pre></td></tr></table></figure><h4 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。</span><br><span class="line"></span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。</span><br><span class="line">f(3) = f(3-1) + f(3-2) + f(3-3) </span><br><span class="line">...</span><br><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) </span><br><span class="line"></span><br><span class="line">再次总结可得</span><br><span class="line"></span><br><span class="line">              | 1       ,(n=0 ) </span><br><span class="line">f(n) =        | 1       ,(n=1 )</span><br><span class="line">              | 2*f(n-1),(n&gt;=2)</span><br></pre></td></tr></table></figure><h4 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共</span><br><span class="line">有多少种方法？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">依旧是斐波那契数列的应用</span><br></pre></td></tr></table></figure><h4 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后</span><br><span class="line">面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判</span><br><span class="line">断这个数可以经历多少次这样的过程。</span><br><span class="line"></span><br><span class="line">如：1100&amp;1011=1000 </span><br></pre></td></tr></table></figure><h4 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 </span><br></pre></td></tr></table></figure><h4 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半</span><br><span class="line">部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到</span><br><span class="line">奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间</span><br><span class="line">复杂度为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="14-链表中倒数第-k-个节点"><a href="#14-链表中倒数第-k-个节点" class="headerlink" title="14. 链表中倒数第 k 个节点"></a>14. 链表中倒数第 k 个节点</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，输出该链表中倒数第 k 个结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后</span><br><span class="line">移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</span><br></pre></td></tr></table></figure><h4 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，反转链表后，输出链表的所有元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当</span><br><span class="line">前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne</span><br><span class="line">xt 节点，实现下一次循环。</span><br></pre></td></tr></table></figure><h4 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的方式，依次将两个链表的元素递归进行对比。</span><br></pre></td></tr></table></figure><h4 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的思想来解决</span><br><span class="line"></span><br><span class="line">第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。</span><br><span class="line">第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</span><br></pre></td></tr></table></figure><h4 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。 </span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</span><br></pre></td></tr></table></figure><h4 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下矩阵： 1 2 3 4</span><br><span class="line">           5 6 7 8 </span><br><span class="line">           9 10 11 12 </span><br><span class="line">           13 14 15 16 </span><br><span class="line">则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一</span><br><span class="line">    次需要打印的数据范围。</span><br><span class="line"></span><br><span class="line">（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</span><br></pre></td></tr></table></figure><h4 id="20-定义一个栈，实现-min-函数"><a href="#20-定义一个栈，实现-min-函数" class="headerlink" title="20. 定义一个栈，实现 min 函数"></a>20. 定义一个栈，实现 min 函数</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小</span><br><span class="line">的值。</span><br></pre></td></tr></table></figure><h4 id="21-栈的压入弹出"><a href="#21-栈的压入弹出" class="headerlink" title="21. 栈的压入弹出"></a>21. 栈的压入弹出</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如</span><br><span class="line">序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序</span><br><span class="line">列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出</span><br><span class="line">栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中</span><br><span class="line">的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</span><br></pre></td></tr></table></figure><h4 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子</span><br><span class="line">节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</span><br></pre></td></tr></table></figure><h4 id="23-二叉搜索树的后序遍历"><a href="#23-二叉搜索树的后序遍历" class="headerlink" title="23. 二叉搜索树的后序遍历"></a>23. 二叉搜索树的后序遍历</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两</span><br><span class="line">个数字都互不相同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，</span><br><span class="line">所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我</span><br><span class="line">们可以利用这些特点来递归判断。</span><br></pre></td></tr></table></figure><h4 id="24-二叉树中和为某一值路径"><a href="#24-二叉树中和为某一值路径" class="headerlink" title="24. 二叉树中和为某一值路径"></a>24. 二叉树中和为某一值路径</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经</span><br><span class="line">过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</span><br></pre></td></tr></table></figure><h4 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25. 复杂链表的复制"></a>25. 复杂链表的复制</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为</span><br><span class="line">复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra</span><br><span class="line">    ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复</span><br><span class="line">    制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此</span><br><span class="line">    不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。</span><br><span class="line"></span><br><span class="line">（3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行</span><br><span class="line">    random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点</span><br><span class="line">    。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26. 二叉搜索树与双向链表"></a>26. 二叉搜索树与双向链表</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序</span><br><span class="line">序列。</span><br><span class="line"></span><br><span class="line">基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并</span><br><span class="line">将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点</span><br><span class="line">的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</span><br></pre></td></tr></table></figure><h4 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27. 字符串的排列"></a>27. 字符串的排列</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有</span><br><span class="line">字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可</span><br><span class="line">以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一</span><br><span class="line">个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html">《字符串的排列》</a></p><h4 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28. 数组中出现次数超过一半的数字"></a>28. 数组中出现次数超过一半的数字</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数</span><br><span class="line">字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为</span><br><span class="line">    O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中</span><br><span class="line">    位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随</span><br><span class="line">    机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字</span><br><span class="line">    便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之</span><br><span class="line">    在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数</span><br><span class="line">    字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果</span><br><span class="line">    次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，</span><br><span class="line">    则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/ns_code/article/details/26957383">《出现次数超过一半的数字》</a></p><h4 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29. 最小的 K 个数"></a>29. 最小的 K 个数</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂</span><br><span class="line">    度，最好的情况下为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part</span><br><span class="line">    ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢</span><br><span class="line">    纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢</span><br><span class="line">    纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划</span><br><span class="line">    分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平</span><br><span class="line">    均时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这</span><br><span class="line">    就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最</span><br><span class="line">    大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一</span><br><span class="line">    种方法的平均时间复杂度为 O(nlogk)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579">《寻找最小的 k 个数》</a></p><h4 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30. 连续子数组的最大和"></a>30. 连续子数组的最大和</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计</span><br><span class="line">算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的</span><br><span class="line">正数会弥补它呢？例如：&#123;6,-3,-2,7,-15,1,2,2&#125;，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠</span><br><span class="line">住？（子向量的长度至少是1）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首</span><br><span class="line">    往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。</span><br><span class="line">    因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负</span><br><span class="line">    数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。</span><br><span class="line">    使用这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html">《连续子数组的最大和》</a></p><h4 id="31-整数中1出现的次数（待深入理解）"><a href="#31-整数中1出现的次数（待深入理解）" class="headerlink" title="31. 整数中1出现的次数（待深入理解）"></a>31. 整数中1出现的次数（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、</span><br><span class="line">12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整</span><br><span class="line">数区间中1出现的次数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是求出1出现在每位上的次数，然后进行叠加。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/yi_Afly/article/details/52012593">《从1到n整数中1出现的次数：O(logn)算法》</a></p><h4 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32. 把数组排成最小的数"></a>32. 把数组排成最小的数</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321</span><br><span class="line">&#125;，则打印出这三个数字能排成的最小数字为321323。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）求出数组的全排列，然后对每个排列结果进行比较。</span><br><span class="line"></span><br><span class="line">（2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的</span><br><span class="line">    结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html">《把数组排成最小的数》</a></p><h4 id="33-丑数（待深入理解）"><a href="#33-丑数（待深入理解）" class="headerlink" title="33. 丑数（待深入理解）"></a>33. 丑数（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求</span><br><span class="line">按从小到大的顺序的第 N 个丑数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以</span><br><span class="line">    5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。</span><br><span class="line"></span><br><span class="line">（2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</span><br></pre></td></tr></table></figure><h4 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这</span><br><span class="line">    一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时</span><br><span class="line">    ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35. 数组中的逆序对"></a>35. 数组中的逆序对</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对</span><br><span class="line">的总数 P。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果</span><br><span class="line">    后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比</span><br><span class="line">    较，因此这个算法的时间复杂度是 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂</span><br><span class="line">    度为 O(nlogn)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html">《数组中的逆序对》</a></p><h4 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二</span><br><span class="line">    个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一</span><br><span class="line">    个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈</span><br><span class="line">    ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这</span><br><span class="line">    一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个</span><br><span class="line">    指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，</span><br><span class="line">    判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html">《两个链表的第一个公共结点》</a></p><h4 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37. 数字在排序数组中出现的次数"></a>37. 数字在排序数组中出现的次数</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出</span><br><span class="line">现了 4 次，因此输出 4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要</span><br><span class="line">    去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束</span><br><span class="line">    位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如</span><br><span class="line">    果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值</span><br><span class="line">    是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们</span><br><span class="line">    下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结</span><br><span class="line">    束位置。这一种方法的平均时间复杂度为 O(logn)。</span><br></pre></td></tr></table></figure><h4 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深</span><br><span class="line">度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</span><br></pre></td></tr></table></figure><h4 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39. 平衡二叉树"></a>39. 平衡二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它</span><br><span class="line">    就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。</span><br><span class="line"></span><br><span class="line">（2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深</span><br><span class="line">    度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</span><br></pre></td></tr></table></figure><h4 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40. 数组中只出现一次的数字"></a>40. 数组中只出现一次的数字</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中</span><br><span class="line">    的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下</span><br><span class="line">    的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和</span><br><span class="line">    B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会</span><br><span class="line">    被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</span><br></pre></td></tr></table></figure><h4 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41. 和为 S 的连续正数序列"></a>41. 和为 S 的连续正数序列</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究</span><br><span class="line">竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。</span><br><span class="line">现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序</span><br><span class="line">列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后</span><br><span class="line">判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续</span><br><span class="line">往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连</span><br><span class="line">续序列，直到数组遍历完成终止。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html">《和为 s 的连续正数序列》</a></p><h4 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42. 和为 S 的两个数字"></a>42. 和为 S 的两个数字</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数</span><br><span class="line">的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和</span><br><span class="line">为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素</span><br><span class="line">。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和</span><br><span class="line">比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html">《和为 S 的字符串》</a></p><h4 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43. 左旋转字符串"></a>43. 左旋转字符串</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的</span><br><span class="line">字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “X</span><br><span class="line">YZdefabc”。是不是很简单？OK，搞定它！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">字符串裁剪后拼接</span><br></pre></td></tr></table></figure><h4 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有</span><br><span class="line">一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了</span><br><span class="line">，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</span><br></pre></td></tr></table></figure><h4 id="45-扑克牌的顺子"><a href="#45-扑克牌的顺子" class="headerlink" title="45. 扑克牌的顺子"></a>45. 扑克牌的顺子</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出</span><br><span class="line">了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王</span><br><span class="line">，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作1，J 为11，</span><br><span class="line">Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。</span><br><span class="line">现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数</span><br><span class="line">组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空</span><br><span class="line">缺，这个数组实际上还是连续的。</span><br><span class="line"></span><br><span class="line">于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如</span><br><span class="line">果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0</span><br><span class="line">数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html">《扑克牌的顺子》</a></p><h4 id="46-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#46-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="46. 圆圈中最后剩下的数字（约瑟夫环问题）"></a>46. 圆圈中最后剩下的数字（约瑟夫环问题）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数</span><br><span class="line">字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）使用环形链表进行模拟。</span><br><span class="line"></span><br><span class="line">（2）根据规律得出（待深入理解）</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html">《圆圈中最后剩下的数字》</a></p><h4 id="47-1-2-3-…-n"><a href="#47-1-2-3-…-n" class="headerlink" title="47. 1+2+3+…+n"></a>47. 1+2+3+…+n</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特</span><br><span class="line">性来实现。</span><br></pre></td></tr></table></figure><h4 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过位运算，递归来实现。</span><br></pre></td></tr></table></figure><h4 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49. 把字符串转换成整数"></a>49. 把字符串转换成整数</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描</span><br><span class="line">述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。</span><br></pre></td></tr></table></figure><h4 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50. 数组中重复的数字"></a>50. 数组中重复的数字</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知</span><br><span class="line">道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O</span><br><span class="line">    (n)，空间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值</span><br><span class="line">    交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要</span><br><span class="line">    额外的内存空间。</span><br></pre></td></tr></table></figure><h4 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51. 构建乘积数组"></a>51. 构建乘积数组</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A</span><br><span class="line">[i+1]*...*A[n-1]。不能使用除法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1] </span><br><span class="line"></span><br><span class="line">      D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1] </span><br><span class="line"></span><br><span class="line">      B[i]=C[i]×D[i]</span><br><span class="line"></span><br><span class="line">      将乘积分为前后两个部分，分别循环求出后，再进行相乘。</span><br><span class="line"></span><br><span class="line">（2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://zhuanlan.zhihu.com/p/34804711">《构建乘积数组》</a></p><h4 id="52-正则表达式的匹配"><a href="#52-正则表达式的匹配" class="headerlink" title="52. 正则表达式的匹配"></a>52. 正则表达式的匹配</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;*&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;*&#x27;表示它前面的字符可以出现任</span><br><span class="line">意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，</span><br><span class="line">但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）状态机思路（待深入理解）</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html">《正则表达式匹配》</a></p><h4 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53. 表示数值的字符串"></a>53. 表示数值的字符串</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-</span><br><span class="line">16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用正则表达式实现</span><br></pre></td></tr></table></figure><h4 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54. 字符流中第一个不重复的字符"></a>54. 字符流中第一个不重复的字符</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次</span><br><span class="line">的字符是 &quot;g&quot; 。当从该字符流中读出前六个字符 &quot;google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。 输出描述：如果当前字符流</span><br><span class="line">没有存在出现一次的字符，返回#字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">同第 34 题</span><br></pre></td></tr></table></figure><h4 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个链表中包含环，如何找出环的入口结点？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我</span><br><span class="line">们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此</span><br><span class="line">通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。</span><br><span class="line"></span><br><span class="line">然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇</span><br><span class="line">点就是环的入口节点。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html">《链表中环的入口结点》</a><br>   <a href="https://blog.csdn.net/shansusu/article/details/50285735">《《剑指offer》——链表中环的入口结点》</a></p><h4 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1-&gt;2-&gt;3-</span><br><span class="line">&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头</span><br><span class="line">结点也可能被删除，所以在链表头额外添加一个结点。</span><br><span class="line"></span><br><span class="line">接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除</span><br><span class="line">之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev</span><br><span class="line">要始终与下一个没有重复的结点连接在一起。</span><br></pre></td></tr></table></figure><h4 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57. 二叉树的下一个结点"></a>57. 二叉树的下一个结点</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，</span><br><span class="line">还有一个指向父节点的指针。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">这个问题我们可以分为三种情况来讨论。</span><br><span class="line"></span><br><span class="line">第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点</span><br><span class="line">出发，一直沿着左子节点的指针，就能找到下一个节点。</span><br><span class="line"></span><br><span class="line">第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节</span><br><span class="line">点。</span><br><span class="line"></span><br><span class="line">第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到</span><br><span class="line">一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</span><br></pre></td></tr></table></figure><h4 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58. 对称二叉树"></a>58. 对称二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式</span><br><span class="line">，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉</span><br><span class="line">树。</span><br></pre></td></tr></table></figure><h4 id="59-按之字形顺序打印二叉树（待深入理解）"><a href="#59-按之字形顺序打印二叉树（待深入理解）" class="headerlink" title="59. 按之字形顺序打印二叉树（待深入理解）"></a>59. 按之字形顺序打印二叉树（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照</span><br><span class="line">从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层</span><br><span class="line">，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每</span><br><span class="line">一个栈遍历完成后进入下一层循环。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/Print.html">《按之字形顺序打印二叉树》</a></p><h4 id="60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"><a href="#60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行" class="headerlink" title="60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"></a>60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还</span><br><span class="line">没有打印的结点数，另一个变量表示下一次结点的数目。</span><br></pre></td></tr></table></figure><h4 id="61-序列化二叉树（待深入理解）"><a href="#61-序列化二叉树（待深入理解）" class="headerlink" title="61. 序列化二叉树（待深入理解）"></a>61. 序列化二叉树（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">数组模拟</span><br></pre></td></tr></table></figure><h4 id="62-二叉搜索树的第-K-个节点"><a href="#62-二叉搜索树的第-K-个节点" class="headerlink" title="62. 二叉搜索树的第 K 个节点"></a>62. 二叉搜索树的第 K 个节点</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一颗二叉搜索树，请找出其中的第 k 小的结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</span><br></pre></td></tr></table></figure><h4 id="63-数据流中的中位数（待深入理解）"><a href="#63-数据流中的中位数（待深入理解）" class="headerlink" title="63. 数据流中的中位数（待深入理解）"></a>63. 数据流中的中位数（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据</span><br><span class="line">流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="64-滑动窗口中的最大值（待深入理解）"><a href="#64-滑动窗口中的最大值（待深入理解）" class="headerlink" title="64. 滑动窗口中的最大值（待深入理解）"></a>64. 滑动窗口中的最大值（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的</span><br><span class="line">大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下</span><br><span class="line">6个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2</span><br><span class="line">,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用队列的方式模拟</span><br></pre></td></tr></table></figure><h4 id="65-矩阵中的路径（待深入理解）"><a href="#65-矩阵中的路径（待深入理解）" class="headerlink" title="65. 矩阵中的路径（待深入理解）"></a>65. 矩阵中的路径（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每</span><br><span class="line">一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子</span><br><span class="line">。例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的</span><br><span class="line">第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure><h4 id="66-机器人的运动范围（待深入理解）"><a href="#66-机器人的运动范围（待深入理解）" class="headerlink" title="66. 机器人的运动范围（待深入理解）"></a>66. 机器人的运动范围（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能</span><br><span class="line">进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是</span><br><span class="line">，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure><p>剑指 offer 相关资料可以参考：<br><a href="https://blog.csdn.net/zzl819954692/article/details/79648054">《剑指 offer 题目练习及思路分析》</a><br><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html">《JS 版剑指 offer》</a><br><a href="https://wiki.jikexueyuan.com/project/for-offer/">《剑指 Offer 学习心得》</a></p><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h4 id="1-明星问题"><a href="#1-明星问题" class="headerlink" title="1. 明星问题"></a>1. 明星问题</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个</span><br><span class="line">函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。</span><br><span class="line">    这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明</span><br><span class="line">    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移</span><br><span class="line">    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩</span><br><span class="line">    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f">《一个明星和 n-1 个群众》</a></p><h4 id="2-正负数组求和"><a href="#2-正负数组求和" class="headerlink" title="2. 正负数组求和"></a>2. 正负数组求和</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和</span><br><span class="line">最接近零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分</span><br><span class="line">    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动</span><br><span class="line">    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;算法知识总结&quot;&gt;&lt;a href=&quot;#算法知识总结&quot; class=&quot;headerlink&quot; title=&quot;算法知识总结&quot;&gt;&lt;/a&gt;算法知识总结&lt;/h1&gt;&lt;p&gt;本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识</title>
    <link href="https://qyjs.github.io/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>https://qyjs.github.io/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</id>
    <published>2020-09-21T07:28:18.000Z</published>
    <updated>2022-12-21T07:00:17.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络知识总结"><a href="#计算机网络知识总结" class="headerlink" title="计算机网络知识总结"></a>计算机网络知识总结</h1><p>本部分主要是笔者在复习计算机网络相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93">计算机网络知识总结</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a><ul><li><a href="#http-%E5%8D%8F%E8%AE%AE">HTTP 协议</a><ul><li><a href="#%E6%A6%82%E5%86%B5">概况</a></li><li><a href="#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">HTTP 请求报文</a></li><li><a href="#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">HTTP 响应报文</a></li><li><a href="#%E9%A6%96%E9%83%A8%E8%A1%8C">首部行</a></li><li><a href="#http11-%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%82%B9">HTTP/1.1 协议缺点</a></li></ul></li><li><a href="#http2-%E5%8D%8F%E8%AE%AE">HTTP/2 协议</a><ul><li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE">二进制协议</a></li><li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81">数据流</a></li><li><a href="#%E5%A4%B4%E4%BF%A1%E6%81%AF%E5%8E%8B%E7%BC%A9">头信息压缩</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">服务器推送</a></li><li><a href="#http2-%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%82%B9">HTTP/2 协议缺点</a></li><li><a href="#http3-%E5%8D%8F%E8%AE%AE">HTTP/3 协议</a></li></ul></li><li><a href="#https-%E5%8D%8F%E8%AE%AE">HTTPS 协议</a><ul><li><a href="#http-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">HTTP 存在的问题</a></li><li><a href="#https-%E7%AE%80%E4%BB%8B">HTTPS 简介</a></li><li><a href="#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">TLS 握手过程</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">实现原理</a></li></ul></li><li><a href="#dns-%E5%8D%8F%E8%AE%AE">DNS 协议</a><ul><li><a href="#%E6%A6%82%E5%86%B5-1">概况</a></li><li><a href="#%E5%9F%9F%E5%90%8D%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84">域名的层级结构</a></li><li><a href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B">查询过程</a></li><li><a href="#dns-%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87">DNS 记录和报文</a></li><li><a href="#%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2">递归查询和迭代查询</a></li><li><a href="#dns-%E7%BC%93%E5%AD%98">DNS 缓存</a></li><li><a href="#dns-%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1">DNS 实现负载平衡</a></li></ul></li></ul></li><li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a><ul><li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3">多路复用与多路分解</a></li><li><a href="#udp-%E5%8D%8F%E8%AE%AE">UDP 协议</a><ul><li><a href="#udp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84">UDP 报文段结构</a></li></ul></li><li><a href="#tcp-%E5%8D%8F%E8%AE%AE">TCP 协议</a><ul><li><a href="#tcp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84">TCP 报文段结构</a></li><li><a href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">TCP 三次握手的过程</a></li><li><a href="#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">TCP 四次挥手的过程</a></li><li><a href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E5%9B%BE">状态转化图</a></li><li><a href="#arq-%E5%8D%8F%E8%AE%AE">ARQ 协议</a></li><li><a href="#tcp-%E7%9A%84%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%BE%93%E6%9C%BA%E5%88%B6">TCP 的可靠运输机制</a></li><li><a href="#tcp-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6">TCP 的流量控制机制</a></li><li><a href="#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6">TCP 的拥塞控制机制</a></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a></li><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li></ul></li><li><a href="#%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98">常考面试题</a><ul><li><a href="#1-post-%E5%92%8C-get-%E7%9A%84%E5%8C%BA%E5%88%AB">1. Post 和 Get 的区别？</a></li><li><a href="#2-tlsssl-%E4%B8%AD%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E4%B8%89%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9D%A5%E7%94%9F%E6%88%90%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5">2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？</a></li><li><a href="#3-ssl-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D">3. SSL 连接断开后如何恢复？</a></li><li><a href="#4-rsa-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BF%9D%E9%9A%9C">4. RSA 算法的安全性保障？</a></li><li><a href="#5-dns-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-udp-%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE">5. DNS 为什么使用 UDP 协议作为传输层协议？</a></li><li><a href="#6-%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-googlecom-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</a></li><li><a href="#7-%E8%B0%88%E8%B0%88-cdn-%E6%9C%8D%E5%8A%A1">7. 谈谈 CDN 服务？</a></li><li><a href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">8. 什么是正向代理和反向代理？</a></li><li><a href="#9-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">9. 负载平衡的两种实现方式？</a></li><li><a href="#10-http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95-options-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">10. http 请求方法 options 方法有什么用？</a></li><li><a href="#11-http11-%E5%92%8C-http10-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB">11. http1.1 和 http1.0 之间有哪些区别？</a></li><li><a href="#12-%E7%BD%91%E7%AB%99%E5%9F%9F%E5%90%8D%E5%8A%A0-www-%E4%B8%8E%E4%B8%8D%E5%8A%A0-www-%E7%9A%84%E5%8C%BA%E5%88%AB">12. 网站域名加 www 与不加 www 的区别？</a></li><li><a href="#13-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9F%AD%E8%BD%AE%E8%AF%A2%E9%95%BF%E8%BD%AE%E8%AF%A2sse-%E5%92%8C-websocket-%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</a></li><li><a href="#14-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81">14. 怎么实现多个网站之间共享登录状态</a></li></ul></li></ul></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、<br>有哪些字段等等。</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传<br>输层协议，保证了数据传输的可靠性。</p><p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p><p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护<br>一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP<br>连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a<br>live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持<br>同时建立 6 个持久连接。</p><span id="more"></span><h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 请求报文的格式如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应<br>中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但<br>更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p><h4 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 响应报文的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</p><p>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</p><p>实体部分是报文的主要部分，它包含了所请求的对象。</p><p>常见的状态有</p><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。</p><p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p><p>更多关于状态码的可以查看：</p><p><a href="http://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。</p><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修<br>改时间。</p><p>更多关于首部的资料可以查看：</p><p><a href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a></p><p><a href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p><h4 id="HTTP-1-1-协议缺点"><a href="#HTTP-1-1-协议缺点" class="headerlink" title="HTTP/1.1 协议缺点"></a>HTTP/1.1 协议缺点</h4><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序<br>是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许<br>多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他<br>资源请求完成后才能发起请求。</p><p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。</p><h3 id="HTTP-2-协议"><a href="#HTTP-2-协议" class="headerlink" title="HTTP/2 协议"></a>HTTP/2 协议</h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明<br>可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p><p>HTTP/2 主要有以下新的特性：</p><h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是<br>二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。<br>帧的概念是它实现多路复用的基础。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回<br>应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的<br>请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每<br>个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p><h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是<br>重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，<br>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引<br>号，这样就能提高速度了。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源<br>，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用<br>SSE 等方式向客户端发送即时数据的推送是不同的。</p><p>详细的资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">《HTTP/2 服务器推送（Server Push）教程》</a></p><h4 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h4><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵<br>守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都<br>会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p><h4 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h4><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC<br>协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/302412059">《如何看待 HTTP/3 ？》</a></p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h4 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h4><ol><li><p>HTTP 报文使用明文方式发送，可能被第三方窃听。</p></li><li><p>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</p></li><li><p>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</p></li></ol><h4 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h4><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/<br>SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立<br>刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p><h4 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h4><ol><li><p>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p></li><li><p>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p></li><li><p>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服<br>务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p></li><li><p>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p></li><li><p>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥<br>来加密信息。</p></li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>TLS 的握手过程主要用到了三个方法来保证传输的安全。</p><p>首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就<br>是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。<br>这就要用到非对称加密的方法。</p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只<br>有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，<br>都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加<br>密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以<br>非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存<br>在的问题。</p><p>但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取<br>了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥<br>解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成<br>一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合<br>在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证<br>处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改<br>了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有<br>这样我们才能保证数据的安全。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA">《一个故事讲完 https》</a><br><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS 协议运行机制的概述》</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 SSL/TLS 协议》</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA 算法原理（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">《RSA 算法原理（二）》</a><br><a href="https://juejin.im/post/5ad6ad575188255c272273c4">《分分钟让你理解 HTTPS》</a></p><h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><h4 id="概况-1"><a href="#概况-1" class="headerlink" title="概况"></a>概况</h4><p>DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分<br>布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号<br>端口。</p><h4 id="域名的层级结构"><a href="#域名的层级结构" class="headerlink" title="域名的层级结构"></a>域名的层级结构</h4><p>域名的层级结构可以如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"></span><br><span class="line"># 即</span><br><span class="line"></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure><p>根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。</p><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。</p><ol><li>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从”次级域名服务器”查出”主机名”的 IP 地址。</li></ol><p>比如我们如果想要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务<br>器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名<br>服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com<br>的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服<br>务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h4 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h4><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p>（Name，Value，Type，TTL）</p><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li><p>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标<br>准的主机名到 IP 地址的映射。</p></li><li><p>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式<br>查询时，返回下一级需要查询的 DNS 服务器的信息。</p></li><li><p>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名<br>对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供<br>一个便于记忆的简单的别名。</p></li><li><p>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一<br>样的，都是为了解决规范主机名不利于记忆的缺点。</p></li></ol><h4 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h4><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归<br>查询，用户只需要发出一次查询请求。</p><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出<br>多次的查询请求。</p><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我<br>们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次<br>查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本<br>地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</p><h4 id="DNS-实现负载平衡"><a href="#DNS-实现负载平衡" class="headerlink" title="DNS 实现负载平衡"></a>DNS 实现负载平衡</h4><p>DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应<br>多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在<br>每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不<br>同的服务器上，这样来实现负载均衡。</p><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">《DNS 原理入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html">《根域名的知识》</a></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。</p><h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。</p><p>在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。</p><p>无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一<br>个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端<br>口号，那么不同的报文段将会转交到同一个 UDP 套接字中。</p><p>面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了<br>源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个<br>值来将报文段定向到相应的套接字。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差<br>错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。</p><p>特点：</p><ol><li><p>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手<br>过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。</p></li><li><p>UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</p></li><li><p>UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</p></li><li><p>因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互<br>通信。</p></li><li><p>UDP 首部小，只有 8 个字节。</p></li></ol><h4 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h4><p>UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长<br>度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。<br>虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" alt="UDP 报文段结构"></p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p><p>特点：</p><ol><li><p>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。</p></li><li><p>TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</p></li><li><p>TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。</p></li><li><p>TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。</p></li><li><p>TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。</p></li><li><p>TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送<br>速率，避免因为缓存填满而造成的数据包的丢失。</p></li></ol><h4 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h4><p>TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。</p><p>源端口和目的端口号用于报文段的多路复用和分解。</p><p>32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。</p><p>16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。</p><p>4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。</p><p>6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字<br>段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。</p><p>校验和提供了对数据的差错检测。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" alt="TCP 报文段结构"></p><h4 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h4><p>第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的<br>随机数。它代表的是客户端数据的初始序号。</p><p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向<br>客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，<br>同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加<br>一。</p><p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务<br>器端的报文段的确认。第三次握手可以在报文段中携带数据。</p><p>在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否<br>已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/24853633">《TCP 为什么是三次握手，而不是两次或四次？》</a><br><a href="https://blog.csdn.net/qzcsu/article/details/72861891">《TCP 的三次握手与四次挥手》</a></p><h4 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h4><p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p><p>第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的<br>连接。发送后客户端进入 FIN_WAIT_1 状态。</p><p>第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的<br>请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务<br>器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</p><p>第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS<br>T_ACK 状态。</p><p>第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，<br>这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到<br>服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被<br>释放了。</p><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代<br>表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器<br>端不能正常关闭。</p><p>详细资料可以参考：</p><p><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c447392e51d45524b02eaf5">《前端面试之道》</a></p><h4 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h4><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-18.png" alt="客户端状态图"></p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-19.png" alt="服务端状态图"></p><h4 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h4><p>ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的<br>机制。</p><p>它分为停止等待 ARQ 协议和连续 ARQ 协议。</p><p>一、停止等待 ARQ 协议</p><p>停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认<br>回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。</p><p>对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余<br>分组的确认。当收到分组损坏的情况的时候，直接丢弃。</p><p>使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。</p><p>二、连续 ARQ 协议</p><p>连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的<br>确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。</p><ol><li>滑动窗口协议</li></ol><p>使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发<br>送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分<br>组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定<br>时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没<br>有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分<br>组。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那<br>么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，<br>所以发送窗口可以移动到已确认分组的后面。</p><p>滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况<br>的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。</p><ol start="2"><li>选择重传协议</li></ol><p>因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。</p><p>选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，<br>已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协<br>议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的<br>定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分<br>组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。</p><p>在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分<br>组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/guoweimelon/article/details/50879588">《TCP 连续 ARQ 协议和滑动窗口协议》</a></p><h4 id="TCP-的可靠运输机制"><a href="#TCP-的可靠运输机制" class="headerlink" title="TCP 的可靠运输机制"></a>TCP 的可靠运输机制</h4><p>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但<br>未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发<br>送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。<br>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如<br>果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送<br>但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，<br>说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发<br>送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文<br>段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都<br>已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文<br>段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重<br>传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h4 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h4><p>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大<br>于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据<br>接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p><h4 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h4><p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的<br>速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p><p>TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。</p><p>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探<br>，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达<br>到一个阈值的时候就进入拥塞避免算法。</p><p>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。<br>这样将窗口的增长速率由指数增长，变为加法线性增长。</p><p>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的<br>丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p><p>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥<br>塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p><p>TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四<br>种机制来达到拥塞控制的目的。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/7d59f9292b03">《TCP 的拥塞控制机制》</a><br><a href="http://www.voidcn.com/article/p-vrdkquop-ms.html">《网络基本功：TCP 拥塞控制机制》</a></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选<br>择协议。</p><p>IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用<br>32 位来分配地址，还有 IPv6 使用 128 位来分配地址。</p><p>路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，<br>这是由网络适配器决定的，在全世界都是独一无二的。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质<br>是什么。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e#heading-1">《搞定计算机网络面试，看这篇就够了（补充版）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">《互联网协议入门（二）》</a></p><h2 id="常考面试题"><a href="#常考面试题" class="headerlink" title="常考面试题"></a>常考面试题</h2><h4 id="1-Post-和-Get-的区别？"><a href="#1-Post-和-Get-的区别？" class="headerlink" title="1. Post 和 Get 的区别？"></a>1. Post 和 Get 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Post 和 Get 是 HTTP 请求的两种方法。</span><br><span class="line"></span><br><span class="line">（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网</span><br><span class="line">页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。</span><br><span class="line"></span><br><span class="line">（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</span><br><span class="line"></span><br><span class="line">（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</span><br><span class="line"></span><br><span class="line">（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，</span><br><span class="line">因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时</span><br><span class="line">的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。</span><br></pre></td></tr></table></figure><h4 id="2-TLS-SSL-中什么一定要用三个随机数，来生成”会话密钥”？"><a href="#2-TLS-SSL-中什么一定要用三个随机数，来生成”会话密钥”？" class="headerlink" title="2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？"></a>2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主</span><br><span class="line">机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，</span><br><span class="line">一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。</span><br></pre></td></tr></table></figure><h4 id="3-SSL-连接断开后如何恢复？"><a href="#3-SSL-连接断开后如何恢复？" class="headerlink" title="3. SSL 连接断开后如何恢复？"></a>3. SSL 连接断开后如何恢复？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</span><br><span class="line"></span><br><span class="line">使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器</span><br><span class="line">如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是</span><br><span class="line">这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那</span><br><span class="line">么就无法恢复对话。</span><br><span class="line"></span><br><span class="line">另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的</span><br><span class="line">，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器</span><br><span class="line">上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</span><br></pre></td></tr></table></figure><h4 id="4-RSA-算法的安全性保障？"><a href="#4-RSA-算法的安全性保障？" class="headerlink" title="4. RSA 算法的安全性保障？"></a>4. RSA 算法的安全性保障？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在102</span><br><span class="line">4位的 RSA 密钥基本安全，2048位的密钥极其安全。</span><br></pre></td></tr></table></figure><h4 id="5-DNS-为什么使用-UDP-协议作为传输层协议？"><a href="#5-DNS-为什么使用-UDP-协议作为传输层协议？" class="headerlink" title="5. DNS 为什么使用 UDP 协议作为传输层协议？"></a>5. DNS 为什么使用 UDP 协议作为传输层协议？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地</span><br><span class="line">址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大</span><br><span class="line">多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</span><br><span class="line"></span><br><span class="line">使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，</span><br><span class="line">UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的</span><br><span class="line">DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不</span><br><span class="line">会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一</span><br><span class="line">个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。</span><br><span class="line"></span><br><span class="line">DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，</span><br><span class="line">所以现在有了 DNS over HTTPS 来解决这个问题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/310145373">《为什么 DNS 使用 UDP 而不是 TCP？》</a></p><h4 id="6-当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#6-当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，</span><br><span class="line">将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字</span><br><span class="line">符，则对非法字符进行转义后再进行下一过程。</span><br><span class="line"></span><br><span class="line">（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新</span><br><span class="line">的请求。</span><br><span class="line"></span><br><span class="line">（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果</span><br><span class="line">有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域</span><br><span class="line">名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地</span><br><span class="line">址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用</span><br><span class="line">户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</span><br><span class="line"></span><br><span class="line">（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源</span><br><span class="line">端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给</span><br><span class="line">数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地</span><br><span class="line">址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果</span><br><span class="line">在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该</span><br><span class="line">转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应</span><br><span class="line">该为网关的地址。</span><br><span class="line"></span><br><span class="line">（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接</span><br><span class="line">收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的</span><br><span class="line">确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立</span><br><span class="line">状态，此时双方的连接就建立起来了。</span><br><span class="line"></span><br><span class="line">（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版</span><br><span class="line">本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证</span><br><span class="line">书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后</span><br><span class="line">发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解</span><br><span class="line">密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加</span><br><span class="line">密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</span><br><span class="line"></span><br><span class="line">（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行</span><br><span class="line">解析，开始页面的渲染过程。</span><br><span class="line"></span><br><span class="line">（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端</span><br><span class="line">是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建</span><br><span class="line">立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页</span><br><span class="line">面进行绘制。这个时候整个页面就显示出来了。</span><br><span class="line"></span><br><span class="line">（9）最后一步是 TCP 断开连接的四次挥手过程。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://blog.jobbole.com/84870/">《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》</a></p><h4 id="7-谈谈-CDN-服务？"><a href="#7-谈谈-CDN-服务？" class="headerlink" title="7. 谈谈 CDN 服务？"></a>7. 谈谈 CDN 服务？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的</span><br><span class="line">功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源</span><br><span class="line">的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h4 id="8-什么是正向代理和反向代理？"><a href="#8-什么是正向代理和反向代理？" class="headerlink" title="8. 什么是正向代理和反向代理？"></a>8. 什么是正向代理和反向代理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的</span><br><span class="line">服务都被代理服务器代替来请求。</span><br><span class="line"></span><br><span class="line">反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知</span><br><span class="line">道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向</span><br><span class="line">代理器一般用来实现负载平衡。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/ikrI3rmSYs83wdSWqq2QIg">《正向代理与反向代理有什么区别》</a><br><a href="https://segmentfault.com/q/1010000017502539/a-1020000017532348">《webpack 配置 proxy 反向代理的原理是什么？》</a></p><h4 id="9-负载平衡的两种实现方式？"><a href="#9-负载平衡的两种实现方式？" class="headerlink" title="9. 负载平衡的两种实现方式？"></a>9. 负载平衡的两种实现方式？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实</span><br><span class="line">现集群的负载平衡。</span><br><span class="line"></span><br><span class="line">另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一</span><br><span class="line">个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在</span><br><span class="line">每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服</span><br><span class="line">务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解</span><br><span class="line">析仍然返回的是那个 IP 地址，就会造成访问的问题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5Njc2OTg4NQ==&mid=2247483870&idx=1&sn=bab36544ec62c394c104df699cf85154&chksm=90aa43eca7ddcafa01634cefee12fd8a332250d3f49d8b6647f536c215ac297e4b6a53af8253#rd">《负载均衡的原理》</a></p><h4 id="10-http-请求方法-options-方法有什么用？"><a href="#10-http-请求方法-options-方法有什么用？" class="headerlink" title="10. http 请求方法 options 方法有什么用？"></a>10. http 请求方法 options 方法有什么用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请</span><br><span class="line">求方法，该方法会用&#x27;*&#x27;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest</span><br><span class="line">对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</span><br></pre></td></tr></table></figure><p>相关资料可以参考：<br><a href="https://itbilu.com/other/relate/EkwKysXIl.html">《HTTP 请求方法》</a></p><h4 id="11-http1-1-和-http1-0-之间有哪些区别？"><a href="#11-http1-1-和-http1-0-之间有哪些区别？" class="headerlink" title="11. http1.1 和 http1.0 之间有哪些区别？"></a>11. http1.1 和 http1.0 之间有哪些区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http1.1 相对于 http1.0 有这样几个区别：</span><br><span class="line">（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</span><br><span class="line">（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</span><br><span class="line"></span><br><span class="line">（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</span><br><span class="line"></span><br><span class="line">（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。</span><br><span class="line"></span><br><span class="line">（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5981c5df518825359a2b9476">《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="https://blog.csdn.net/netdxy/article/details/51195560">《网络—一篇文章详解请求头 Host 的概念》</a></p><h4 id="12-网站域名加-www-与不加-www-的区别？"><a href="#12-网站域名加-www-与不加-www-的区别？" class="headerlink" title="12. 网站域名加 www 与不加 www 的区别？"></a>12. 网站域名加 www 与不加 www 的区别？</h4><p>详细资料可以参考：<br><a href="https://www.f9seo.com/post-816.html">《为什么域名前要加 www 前缀 www 是什么意思？》</a><br><a href="https://www.zhihu.com/question/20414602">《为什么越来越多的网站域名不加「www」前缀？》</a><br><a href="https://blog.csdn.net/andybruse/article/details/7982278">《域名有 www 与没有 www 有什么区别？》</a></p><h4 id="13-即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#13-即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</span><br><span class="line"></span><br><span class="line">短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行</span><br><span class="line">响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客</span><br><span class="line">户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 ht</span><br><span class="line">tp 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</span><br><span class="line"></span><br><span class="line">长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将</span><br><span class="line">这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</span><br><span class="line">客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的</span><br><span class="line">优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</span><br><span class="line"></span><br><span class="line">SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通</span><br><span class="line">方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断</span><br><span class="line">地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机</span><br><span class="line">制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不</span><br><span class="line">需要建立过多的 http 请求，相比之下节约了资源。</span><br><span class="line"></span><br><span class="line">上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协</span><br><span class="line">议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置</span><br><span class="line">比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能</span><br><span class="line">由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://cloud.tencent.com/developer/article/1076547">《轮询、长轮询、长连接、websocket》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">《Server-Sent Events 教程》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">《WebSocket 教程》</a></p><h4 id="14-怎么实现多个网站之间共享登录状态"><a href="#14-怎么实现多个网站之间共享登录状态" class="headerlink" title="14. 怎么实现多个网站之间共享登录状态"></a>14. 怎么实现多个网站之间共享登录状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</span><br><span class="line"></span><br><span class="line">我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发</span><br><span class="line">送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该</span><br><span class="line">token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站</span><br><span class="line">点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将</span><br><span class="line">页面重定向会单点登录页面。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/35906139">《HTTP 是个无状态协议，怎么保持登录状态？》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络知识总结&quot;&gt;&lt;a href=&quot;#计算机网络知识总结&quot; class=&quot;headerlink&quot; title=&quot;计算机网络知识总结&quot;&gt;&lt;/a&gt;计算机网络知识总结&lt;/h1&gt;&lt;p&gt;本部分主要是笔者在复习计算机网络相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93&quot;&gt;计算机网络知识总结&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%9B%AE%E5%BD%95&quot;&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BA%94%E7%94%A8%E5%B1%82&quot;&gt;应用层&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#http-%E5%8D%8F%E8%AE%AE&quot;&gt;HTTP 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A6%82%E5%86%B5&quot;&gt;概况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87&quot;&gt;HTTP 请求报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87&quot;&gt;HTTP 响应报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%A6%96%E9%83%A8%E8%A1%8C&quot;&gt;首部行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#http11-%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%82%B9&quot;&gt;HTTP/1.1 协议缺点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#http2-%E5%8D%8F%E8%AE%AE&quot;&gt;HTTP/2 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE&quot;&gt;二进制协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8&quot;&gt;多路复用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E6%8D%AE%E6%B5%81&quot;&gt;数据流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%B4%E4%BF%A1%E6%81%AF%E5%8E%8B%E7%BC%A9&quot;&gt;头信息压缩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81&quot;&gt;服务器推送&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#http2-%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%82%B9&quot;&gt;HTTP/2 协议缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#http3-%E5%8D%8F%E8%AE%AE&quot;&gt;HTTP/3 协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#https-%E5%8D%8F%E8%AE%AE&quot;&gt;HTTPS 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#http-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;HTTP 存在的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#https-%E7%AE%80%E4%BB%8B&quot;&gt;HTTPS 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B&quot;&gt;TLS 握手过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&quot;&gt;实现原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dns-%E5%8D%8F%E8%AE%AE&quot;&gt;DNS 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A6%82%E5%86%B5-1&quot;&gt;概况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9F%9F%E5%90%8D%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&quot;&gt;域名的层级结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B&quot;&gt;查询过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dns-%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87&quot;&gt;DNS 记录和报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2&quot;&gt;递归查询和迭代查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dns-%E7%BC%93%E5%AD%98&quot;&gt;DNS 缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dns-%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1&quot;&gt;DNS 实现负载平衡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BC%A0%E8%BE%93%E5%B1%82&quot;&gt;传输层&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3&quot;&gt;多路复用与多路分解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#udp-%E5%8D%8F%E8%AE%AE&quot;&gt;UDP 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#udp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84&quot;&gt;UDP 报文段结构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E5%8D%8F%E8%AE%AE&quot;&gt;TCP 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84&quot;&gt;TCP 报文段结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B&quot;&gt;TCP 三次握手的过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B&quot;&gt;TCP 四次挥手的过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E5%9B%BE&quot;&gt;状态转化图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#arq-%E5%8D%8F%E8%AE%AE&quot;&gt;ARQ 协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E7%9A%84%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%BE%93%E6%9C%BA%E5%88%B6&quot;&gt;TCP 的可靠运输机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6&quot;&gt;TCP 的流量控制机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6&quot;&gt;TCP 的拥塞控制机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BD%91%E7%BB%9C%E5%B1%82&quot;&gt;网络层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&quot;&gt;数据链路层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%89%A9%E7%90%86%E5%B1%82&quot;&gt;物理层&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98&quot;&gt;常考面试题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-post-%E5%92%8C-get-%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;1. Post 和 Get 的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-tlsssl-%E4%B8%AD%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E4%B8%89%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9D%A5%E7%94%9F%E6%88%90%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5&quot;&gt;2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-ssl-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D&quot;&gt;3. SSL 连接断开后如何恢复？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-rsa-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BF%9D%E9%9A%9C&quot;&gt;4. RSA 算法的安全性保障？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-dns-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-udp-%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE&quot;&gt;5. DNS 为什么使用 UDP 协议作为传输层协议？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-googlecom-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88&quot;&gt;6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-%E8%B0%88%E8%B0%88-cdn-%E6%9C%8D%E5%8A%A1&quot;&gt;7. 谈谈 CDN 服务？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86&quot;&gt;8. 什么是正向代理和反向代理？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&quot;&gt;9. 负载平衡的两种实现方式？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10-http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95-options-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8&quot;&gt;10. http 请求方法 options 方法有什么用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11-http11-%E5%92%8C-http10-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB&quot;&gt;11. http1.1 和 http1.0 之间有哪些区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-%E7%BD%91%E7%AB%99%E5%9F%9F%E5%90%8D%E5%8A%A0-www-%E4%B8%8E%E4%B8%8D%E5%8A%A0-www-%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;12. 网站域名加 www 与不加 www 的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#13-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9F%AD%E8%BD%AE%E8%AF%A2%E9%95%BF%E8%BD%AE%E8%AF%A2sse-%E5%92%8C-websocket-%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#14-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81&quot;&gt;14. 怎么实现多个网站之间共享登录状态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h2&gt;&lt;p&gt;应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、&lt;br&gt;有哪些字段等等。&lt;/p&gt;
&lt;h3 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h3&gt;&lt;h4 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概况&quot;&gt;&lt;/a&gt;概况&lt;/h4&gt;&lt;p&gt;HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传&lt;br&gt;输层协议，保证了数据传输的可靠性。&lt;/p&gt;
&lt;p&gt;HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。&lt;/p&gt;
&lt;p&gt;HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护&lt;br&gt;一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP&lt;br&gt;连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a&lt;br&gt;live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持&lt;br&gt;同时建立 6 个持久连接。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://qyjs.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://qyjs.github.io/2019/12/21/hello-world/"/>
    <id>https://qyjs.github.io/2019/12/21/hello-world/</id>
    <published>2019-12-21T00:46:08.000Z</published>
    <updated>2022-12-21T07:00:17.377Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="Hello Worlds" scheme="https://qyjs.github.io/categories/Hello-Worlds/"/>
    
    <category term="Hello World" scheme="https://qyjs.github.io/categories/Hello-Worlds/Hello-World/"/>
    
    
    <category term="Hello World" scheme="https://qyjs.github.io/tags/Hello-World/"/>
    
  </entry>
  
  <entry>
    <title>不蒜子统计常见问题</title>
    <link href="https://qyjs.github.io/2019/12/21/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://qyjs.github.io/2019/12/21/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-21T00:46:08.000Z</published>
    <updated>2022-12-21T07:00:17.380Z</updated>
    
    <content type="html"><![CDATA[<p>不蒜子统计官网：<a href="http://busuanzi.ibruce.info/">http://busuanzi.ibruce.info/</a></p><p>详细使用教程：<a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a></p><p>目前支持的功能：（两行代码，搞定计数；方便、简洁、实用）</p><p>a、显示站点总访问量</p><p>b、显示单页面访问量</p><span id="more"></span><p>c、显示站点总访问量和单页面访问量</p><p>d、只计数不显示</p><p>关于怎么实现当天、昨天、本月、上月（即具体时间段）的访问量目前没有支持，请配合目前不蒜子支持的功能自行实现。</p><h3 id="1-常见问题400错误，统计不生效"><a href="#1-常见问题400错误，统计不生效" class="headerlink" title="1.常见问题400错误，统计不生效"></a>1.常见问题400错误，统计不生效</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085006.png">            </p><p>如图<strong>（1）</strong>的地方没有加载出统计数据</p><p>此时F12打开浏览器控制台，找到<strong>（2）</strong>network地方，刷新一下页面找到<strong>（3）</strong>，请求统计的网址如图所示，查看<strong>（4）</strong>referrer-policy是否如图所示，如图的话是不能访问的，需要更改。</p><p><strong>导致此问题原因</strong>，检查网页源码中，一般header有如下标签</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085114.png">    </p><p><strong>解决方法</strong>，去掉此标签，之后访问如下<strong>（1）</strong>已有统计值，<strong>（2）</strong>已改变。可详细对比正常使用不蒜子统计网址<a href="https://removeif.github.io/">https://removeif.github.io/</a> 中请求<strong>busuanzi?jsonpCallback=BusuanziCallback_236107382952地址</strong>的请求和返回参数的差异！</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085231.png"></p><p><strong>这样设置带来的影响</strong>，可能有些图床的图片不能显示，会图裂，如新浪图床。解决方法，可以用其他不冲突的图床。</p><h3 id="2-统计访问数巨大（清零问题）"><a href="#2-统计访问数巨大（清零问题）" class="headerlink" title="2.统计访问数巨大（清零问题）"></a>2.统计访问数巨大（清零问题）</h3><p><a href="http://localhost:4000/">http://localhost:4000/</a> 或<a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 访问时，统计数巨大，这是正常的，不用清零。部署到线上，用线上域名网址访问数据就正常了。</p><h3 id="3-统计无法访问如图所示"><a href="#3-统计无法访问如图所示" class="headerlink" title="3.统计无法访问如图所示"></a>3.统计无法访问如图所示</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085258.png"></p><p>查看红色url部分如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085320.png"></p><p>此问题是Request URL填写错误，请确保Request URL前部分为<a href="http://busuanzi.ibruce.info/busuanzi"><strong>http://busuanzi.ibruce.info/busuanzi?</strong></a><strong>，，，，如下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085345.png"></p><p>同时查看Response，出现如下数据，就是成功访问了不蒜子统计，如果网站中还没出统计数据，就是自己的代码写错了，检查代码</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085405.png"></p><h3 id="4-其余问题"><a href="#4-其余问题" class="headerlink" title="4.其余问题"></a>4.其余问题</h3><p><strong>(1)</strong>.同一个页面，同名的id标签确保只能放一个如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同一个页面id名为busuanzi_value_site_uv只能放一个!</p><p><strong>(2)</strong>.safari（包括移动端的safari）浏览器页面pv统计问题，如下，因为Safari浏览器referer在文章页面时也上送的域名（而单个页面的pv统计是根据页面路径，即上送的referer），所以此时页面的pv返回的站点的pv值。暂时没解决方法，可自行搜索解决方案构造正确的referer值。对于此问题可以换个浏览器看哇，比如Chrome，哈哈。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085514.png"></p><p><strong>(3)</strong>.部分live2d可能与不蒜子统计有冲突，出现此问题时，请查看网页源码引用统计id处是否被隐藏，一般网页上会自动加上display: none;自行选择性的使用。网友的解决方法，修改源码为以下，并引用修改后的js文件</p><p>不蒜子源码文件：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085823.png"></p><p> 修改为如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">var bszCaller, bszTag;</span><br><span class="line"><span class="addition">!function() &#123;</span></span><br><span class="line">    var c, d, e, a = !1, b = [];</span><br><span class="line">    ready = function(c) &#123;</span><br><span class="line">        return a || &quot;interactive&quot; <span class="comment">=== document.readyState || &quot;complete&quot; === document.readyState ? c.call(document) : b.push(function() &#123;</span></span><br><span class="line">            return c.call(this)</span><br><span class="line">        &#125;),</span><br><span class="line">        this</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    d = function() &#123;</span><br><span class="line">        for (var a = 0, c = b.length; c &gt; a; a++)</span><br><span class="line">            b[a].apply(document);</span><br><span class="line">        b = []</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    e = function() &#123;</span><br><span class="line">        a || (a = !0,</span><br><span class="line">        d.call(window),</span><br><span class="line">        document.removeEventListener ? document.removeEventListener(&quot;DOMContentLoaded&quot;, e, !1) : document.attachEvent &amp;&amp; (document.detachEvent(&quot;onreadystatechange&quot;, e),</span><br><span class="line">        window == window.top &amp;&amp; (clearInterval(c),</span><br><span class="line">        c = null)))</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    document.addEventListener ? document.addEventListener(&quot;DOMContentLoaded&quot;, e, !1) : document.attachEvent &amp;&amp; (document.attachEvent(&quot;onreadystatechange&quot;, function() &#123;</span><br><span class="line">        /loaded|complete/.test(document.readyState) &amp;&amp; e()</span><br><span class="line">    &#125;),</span><br><span class="line">    window == window.top &amp;&amp; (c = setInterval(function() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            a || document.documentElement.doScroll(&quot;left&quot;)</span><br><span class="line">        &#125; catch (b) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        e()</span><br><span class="line">    &#125;, 5)))</span><br><span class="line">&#125;(),</span><br><span class="line">bszCaller = &#123;</span><br><span class="line">    fetch: function(a, b) &#123;</span><br><span class="line">        var c = &quot;BusuanziCallback_&quot; + Math.floor(1099511627776 * Math.random());</span><br><span class="line">        window[c] = this.evalCall(b),</span><br><span class="line">        a = a.replace(&quot;=BusuanziCallback&quot;, &quot;=&quot; + c),</span><br><span class="line">        scriptTag = document.createElement(&quot;SCRIPT&quot;),</span><br><span class="line">        scriptTag.type = &quot;text/javascript&quot;,</span><br><span class="line">        scriptTag.defer = !0,</span><br><span class="line">        scriptTag.src = a,</span><br><span class="line">        document.getElementsByTagName(&quot;HEAD&quot;)[0].appendChild(scriptTag)</span><br><span class="line">    &#125;,</span><br><span class="line">    evalCall: function(a) &#123;</span><br><span class="line">        return function(b) &#123;</span><br><span class="line">            ready(function() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    a(b), </span><br><span class="line"><span class="deletion">-                      // 此处为修改的逻辑</span></span><br><span class="line"><span class="deletion">-                      scriptTag.parentElement.removeChild(scriptTag)</span></span><br><span class="line"><span class="addition">+                      if(scriptTag != null &amp;&amp; scriptTag.parentElement != null)&#123;</span></span><br><span class="line"><span class="addition">+                       scriptTag.parentElement.removeChild(scriptTag)</span></span><br><span class="line"><span class="addition">+                      &#125;</span></span><br><span class="line">                &#125; catch (c) &#123;</span><br><span class="line">                    bszTag.hides()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">bszCaller.fetch(&quot;//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback&quot;, function(a) &#123;</span><br><span class="line">    bszTag.texts(a),</span><br><span class="line">    bszTag.shows()</span><br><span class="line">&#125;),</span><br><span class="line">bszTag = &#123;</span><br><span class="line">    bszs: [&quot;site_pv&quot;, &quot;page_pv&quot;, &quot;site_uv&quot;],</span><br><span class="line">    texts: function(a) &#123;</span><br><span class="line">        this.bszs.map(function(b) &#123;</span><br><span class="line">            var c = document.getElementById(&quot;busuanzi_value_&quot; + b);</span><br><span class="line">            c &amp;&amp; (c.innerHTML = a[b])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    hides: function() &#123;</span><br><span class="line">        this.bszs.map(function(a) &#123;</span><br><span class="line">            var b = document.getElementById(&quot;busuanzi_container_&quot; + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = &quot;none&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    shows: function() &#123;</span><br><span class="line">        this.bszs.map(function(a) &#123;</span><br><span class="line">            var b = document.getElementById(&quot;busuanzi_container_&quot; + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = &quot;inline&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="5-官方群！！！"><a href="#5-官方群！！！" class="headerlink" title="5.官方群！！！"></a>5.官方群！！！</h3><p>群号：419260983，有其余问题进群讨论，<strong>提问时遇到其他的问题请同时发出问题的在线网址！！！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不蒜子统计官网：&lt;a href=&quot;http://busuanzi.ibruce.info/&quot;&gt;http://busuanzi.ibruce.info/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细使用教程：&lt;a href=&quot;http://ibruce.info/2015/04/04/busuanzi/&quot;&gt;http://ibruce.info/2015/04/04/busuanzi/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前支持的功能：（两行代码，搞定计数；方便、简洁、实用）&lt;/p&gt;
&lt;p&gt;a、显示站点总访问量&lt;/p&gt;
&lt;p&gt;b、显示单页面访问量&lt;/p&gt;</summary>
    
    
    
    <category term="工具教程" scheme="https://qyjs.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客统计插件" scheme="https://qyjs.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="博客统计插件" scheme="https://qyjs.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
</feed>
